/*
 Navicat Premium Data Transfer

 Source Server         : aliyun
 Source Server Type    : MySQL
 Source Server Version : 50729
 Source Host           : 39.106.163.62:3306
 Source Schema         : cms

 Target Server Type    : MySQL
 Target Server Version : 50729
 File Encoding         : 65001

 Date: 08/01/2021 19:53:45
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for tb_article
-- ----------------------------
DROP TABLE IF EXISTS `tb_article`;
CREATE TABLE `tb_article`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `channel_id` int(11) NOT NULL COMMENT '栏目id',
  `title` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '标题',
  `title_img` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '标题图',
  `summary` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL COMMENT '摘要',
  `url` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '外链URL',
  `content` mediumtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL COMMENT '正文',
  `status` int(1) NULL DEFAULT NULL COMMENT '0待发布1发布',
  `comment_status` int(1) NULL DEFAULT NULL COMMENT '0/Null允许评论，不允许评论',
  `rotation` int(1) NULL DEFAULT NULL COMMENT '0/NULL非轮播 1 轮播',
  `top` int(1) NULL DEFAULT NULL COMMENT '0/null不置顶，1置顶',
  `orderby` int(11) NULL DEFAULT NULL COMMENT '排序',
  `create_date` date NULL DEFAULT NULL COMMENT '创建时间',
  `create_user` int(11) NULL DEFAULT NULL COMMENT '创建人',
  `update_date` date NULL DEFAULT NULL,
  `article_view` int(11) NULL DEFAULT 0,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `id_articleId_id`(`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 80 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '文章' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tb_article
-- ----------------------------
INSERT INTO `tb_article` VALUES (60, 22, 'Redis', 'http://39.106.163.62:8081/cms/upload/a663311b-0a72-4f80-a6cc-c09558a4e8fa.jpg', 'Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。', '', '\n\n\n\n# Redis\n\n\n\n## Nosql概述\n\n大数据时代；\n\n大数据一般数据库无法进行分析处理了。\n\n压力越来越大，适者生存！一定要逼着自己学习，这是在这个社会生存的唯一法则！\n\n#### 为什么要使用Nosql?\n\n> 1、单击Mysql的年代\n\n1. 数据量如果太大，一个机器放不下\n2. 数据的索引（B+Tree），一个机器也放不下\n3. 访问量（读写混合），一个服务区承受不了\n\n只要你出现以上的三种情况之一，那么你就必须要晋级\n\n\n\n> Memcached(缓存)+Mysql+垂直拆分\n\n网站80%的情况都是在读，每次都要去查询的话就十分麻烦!所以说我们越希望减轻数据的压力，我们可以使用缓存来保证效率\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105091800653.png\" alt=\"image-20201105091800653\" style=\"zoom:50%;\" />\n\n\n\n> 分库分表+水平拆分+\n\n技术1和业务在发展的同时，对人的要求也越来越高\n\n==本质：数据库（读，写）==\n\n早些年MylSAM:表锁,十分影响效率！高并发下就会出现严重的锁问题\n\n转战Innodb: 行锁\n\n慢慢的就开始使用分库分表来解决写的压力\n\nMysql的集群\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105092719168.png\" alt=\"image-20201105092719168\" style=\"zoom: 67%;\" />\n\n\n\n> 如今最近年代\n\n2010---2020十年之间，世界已经发生了翻天覆地的变化。\n\nMysql 等关型数据库就不够用了！数据量很多，变化很大！\n\n> 目前一个基本的互联网样子		\n\n\n\n![image-20201105094508658](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105094508658.png)\n\n> 为什么要用NoSQL！\n\n用户的信息，社交网络、地理位置。用户自己产生的数据用户日志等等爆发式增长。\n\n这时候我们就需要使用NoSql数据库的，Nosql可以很好的处理以上的情况。\n\n\n\n#### 什么是NoSQL\n\n> NoSQL\n\n(不仅仅是SQL)\n\n关系型数据库：表格，行，列\n\n泛指非关系型数据库，随着web2.0互联网的诞生！传统的关系型数据库，很难对付web2.0时代！尤其是超大规模的高并发的社区！暴露出很多难以克服的问题，NoSQL在当今大数据环境下发展的十分迅速，\n\n> NoSQl\n\n1. 方便扩展（数据之间没有关系，很好扩展）\n2. 大数据量高性能（Redis 一秒可以写8万次，读取11万次，NoSQL的缓存记录级，是一种细粒度的缓存，性能比较高）\n3. 数据库类型是多样型的！（不需要设计数据库，随去随用！如果是数据库量十分大的表，很多人就无法设计了！）\n4. 传统的RDBMS和NOSQL\n\n```\n传统的RDBMS\n- 结构化组织\n- SQL\n- 数据和关系都存在单独的表中\n- 操作，数据定义语言\n- 基础的事务\n```\n\n```\nnosql\n- 不仅仅是数据\n- 没有固定的查询语言\n键值对存储，列存储，文档存储，图形数据库（社交关系）\n- 最终一致性\n- CAP定理和BASE（异地多活）\n- 高性能，高可用，高可扩展\n```\n\n> 了解：3V+3高\n\n大数据时代的3V:主要描述问题的\n\n1. 海量Volume\n2. 多样Variety\n3. 实时Velocity\n\n大数据时代的3高：主要是对程序的要求\n\n1. 高并发\n2. 高可扩\n3. 高性能\n\n真正在公司中的时间 ：NoSQL+RDBMS 一起使用才是最强的\n\n技术没有高低之分，就看你如何去使用！（提升内功，思维的提高！）\n\n#### 阿里巴演进分析\n\n\n\n```bash\n#1、商品的基本信息\n名称、价格、商家信息；\n关系性数据库就可以解决了! /Oracle/ mysql （淘宝早年就去IOE了-王坚 ：推荐文章：阿里云的这群疯子：40分钟）\n	淘宝内部的Mysql 不是大家用的Mysql\n#2、 商品的描述 、评论（文字比较多）\n	文档数据库中，MongoDB\n	\n#3、 图片\n	分布式文件系统 FastDFS\n	-淘宝自己的 TFS\n	-Gooale的 GFS\n	-Hadoop 的 HDFS\n	-阿里云的OsS存储\n#4、商品的关键字	（搜索）\n	-搜索引擎 solr elasticsearch\n	-Iserach：多隆\n	所有牛逼的人都有一段苦逼的岁月！但是你只要想SB一样的坚持，终将牛逼\n	\n#5、商品热门的波段信息\n	-内存数据库\n	-Redis tair、Memache...\n	\n#6、商品的交易、外部的支付接口\n	-三方应用\n```\n\n要知道一个简单地网页背后的技术一定不是想的那么简单\n\n大型互联网应用问题\n\n- 数据类型太多了\n- 数据源繁多。经常重构！\n- 数据要改造，大面积改造\n\n\n\n#### NoSQL的四大分类\n\n**KV键值对**：\n\n- 新浪：**Redis**\n- 美团:Redis+Tair\n- 阿里、百度：Redis+Menmecache\n\n**文档型数据库（bson和json）**：\n\n- **MongoDB**（一般必须要掌握）\n  - MongoDB是一个基于分布式文件存储的数据库，C++编写，主要用来处理大量的文档\n  - MongoDB是一个介于关系型数据库和非关系型数据中中间的产品！MongoDB是非关系型数据库中功能最丰富，最像关系型数据库的！\n- ConthDB\n\n**列存储数据库**\n\n- **HBase**\n- 分布式文件系统\n\n**图关系数据库**\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105130753396.png\" alt=\"image-20201105130753396\" style=\"zoom:67%;\" />\n\n- 他不是存图形的，放的是关系，比如朋友圈社交网络，广告推荐\n- **Neo4j**\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105131101775.png\" alt=\"image-20201105131101775\" style=\"zoom:67%;\" />\n\n敬畏之心可以使人进步！\n\n\n\n## Redis\n\n### 概述\n\n> Redis是什么？\n\n==Redis（Remote Dictionary Server )，即远程字典服务！==\n\n是一个开源的使用ANSI [C语言](https://baike.baidu.com/item/C语言)编写、支持网络、可基于内存亦可持久化的日志型、Key-Value[数据库](https://baike.baidu.com/item/数据库/103728)，并提供多种语言的API\n\n区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。\n\n> Redis能干嘛？\n\n1. 内存存储、持久化，内存中是断电即失、所以说持久化很重要（rdb、aof）\n2. 效率高，可以用于高速缓存\n3. 发布订阅系统\n4. 地图信息分析\n5. 计时器、计数器（浏览量）\n6. ......\n\n> 特性\n\n1. 多样的数据类型\n2. 持久化\n3. 集群\n4. 事务\n5. .....\n\n\n\n> 学习中需要用到的东西\n\n1. 狂神公众号：狂神说\n\n2. 官网：https://redis.io/\n\n3. 中文网：https://redis.cn/\n\n4. 下载地址，官方下载即可\n\n   <img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105132940425.png\" alt=\"image-20201105132940425\" style=\"zoom:50%;\" />\n\n   注意：windows在github上下载，（停更很久了！）\n\n\n\n### Windows安装\n\n1. 下载安装包\n\n2. 下载完毕得到压缩包\n\n3. 解压到自己电脑的环境目录下的就可以了\n\n   ![image-20201105142733690](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105142733690.png)\n\n4. 开启Redis 双击运行服务即可\n\n   <img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105142846757.png\" alt=\"image-20201105142846757\" style=\"zoom: 50%;\" />\n\n5. 使用redis客户端来连接redis\n\n   **<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105143140662.png\" alt=\"image-20201105143140662\" style=\"zoom:50%;\" />**\n\n6. \n\n\n\n### Linux安装\n\n1. 下载安装包！`redis-6.0.9.tar.gz`\n\n2. 解压Redis安装包！程序放在Opt目录下\n\n   解压命令：tar -zxvf 压缩包\n\n   ![image-20201105145458201](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105145458201.png)\n\n3. 进入解压后的文件可以看到redis的配置文件\n\n   ![image-20201105145708186](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105145708186.png)\n\n4. 环境安装\n\n   ```bash\n   yum install gcc-c++\n   \n   make\n   make install PREFIX=/usr/local/redis  安装到一个自定义的文件夹\n   ```\n\n5. 安装完路径在 `usr/local/redis/bin `\n\n   ![image-20201105163747347](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105163747347.png)\n\n6. redis 默认不是后台启动的，修改配置文件！，改为yes\n\n   ![image-20201105164219211](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105164219211.png)\n\n7. 启动redis服务！\n\n   ![image-20201105170730678](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105170730678.png)\n\n8. 使用redis-cli进行测试连接\n\n   ![image-20201105171050884](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105171050884.png)\n\n9. 查看redis的进程是否开启\n\n   ![image-20201105171342657](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105171342657.png)\n\n10. 如何关闭redis服务呢？`shutdown`\n\n    ![image-20201105171524129](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105171524129.png)\n\n11. 再次查看进程是否存在\n\n    ![image-20201105171617419](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105171617419.png)\n\n12. 后面我们会使用单机多Redis启动集群测试！\n\n\n\n### 测试性能\n\n**redis-benchmarks**是一个压力测试工具\n\n官方自带的性能测试工具！\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105191058824.png\" alt=\"image-20201105191058824\" style=\"zoom: 80%;\" />\n\n\n\n我们来测试一下\n\n```bash\n#测试 100个并发连接 100000个请求\nredis-benchmark -h localhost -p 6379 -c 100 -n 100000\n```\n\n![image-20201105191906373](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105191906373.png\n\n![image-20201105192120889](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105192120889.png)\n\n\n\n\n\n### 基础知识\n\nredis默认有16个数据库\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201106084716251.png\" alt=\"image-20201106084716251\" style=\"zoom:67%;\" />\n\n默认使用的是第0个\n\n可以使用select进行切换\n\n```bash\n127.0.0.1:6379> select 3  #切换数据库\nOK\n127.0.0.1:6379[3]> DBSIZE 	#查看DB大小\n(integer) 0\n127.0.0.1:6379[3]> \n\n```\n\n```bash\n127.0.0.1:6379[3]> keys *   #查看所有的key\n1) \"name\"\n127.0.0.1:6379[3]> \n```\n\n清楚当前数据库内容`flushdb`\n\n```bash\n127.0.0.1:6379[3]> flushdb		#清除当前数据库\nOK\n127.0.0.1:6379[3]> keys *\n(empty list or set)\n127.0.0.1:6379[3]> \n```\n\n清除全部数据库的内容`FLUSHALL`\n\n\n\n\n\n> Redis是单线程的\n\n明白Redis是很快的，官方表示，Redis是基于内存操作的，CPU不是Redis的性能瓶颈，Redis的瓶颈是根据机器的内存和网络带宽，既然可以使用单线程来实现，就是用单线程了！\n\nRedis是C语言写的，官方提供的数据为100000+QPS，完全不比是使用的key-value的Memecache差\n\nRedis为什么还这么快？\n\n1. 误区1：高性能的服务器一定是多线程的？\n2. 误区2：多线程（CPU上下文切换）一定比单线程效率高\n\n核心：redis是将所有的数据全部放在内存中的，所有说使用单线程去操作效率就是最高的，多线程（CPU上下文会切换：耗时的操作！），对于内存系统来说，没有上下文切换效率就是最该的！多次读写都是在一个cpu上的，在内存情况下，这个就是最佳的方案\n\n## 五大数据类型\n\n\n\n\n\nRedis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作==数据库、缓存和消息中间件==。 它支持多种类型的数据结构，如 [字符串（strings）](http://redis.cn/topics/data-types-intro.html#strings)， [散列（hashes）](http://redis.cn/topics/data-types-intro.html#hashes)， [列表（lists）](http://redis.cn/topics/data-types-intro.html#lists)， [集合（sets）](http://redis.cn/topics/data-types-intro.html#sets)， [有序集合（sorted sets）](http://redis.cn/topics/data-types-intro.html#sorted-sets) 与范围查询， [bitmaps](http://redis.cn/topics/data-types-intro.html#bitmaps)， [hyperloglogs](http://redis.cn/topics/data-types-intro.html#hyperloglogs) 和 [地理空间（geospatial）](http://redis.cn/commands/geoadd.html) 索引半径查询。 Redis 内置了 [复制（replication）](http://redis.cn/topics/replication.html)，[LUA脚本（Lua scripting）](http://redis.cn/commands/eval.html)， [LRU驱动事件（LRU eviction）](http://redis.cn/topics/lru-cache.html)，[事务（transactions）](http://redis.cn/topics/transactions.html) 和不同级别的 [磁盘持久化（persistence）](http://redis.cn/topics/persistence.html)， 并通过 [Redis哨兵（Sentinel）](http://redis.cn/topics/sentinel.html)和自动 [分区（Cluster）](http://redis.cn/topics/cluster-tutorial.html)提供高可用性（high availability）。\n\n\n\n#### Redis-Key\n\n```bash\n127.0.0.1:6379> keys *    #查看所有的key \n1) \"name\"\n127.0.0.1:6379> set shunshun 1  #set key \nOK\n127.0.0.1:6379> keys *\n1) \"name\"\n2) \"shunshun\"\n127.0.0.1:6379> EXISTS name 	#判断当前的key 是否存在\n(integer) 1\n127.0.0.1:6379> move name 1		#移除当前的key \n(integer) 1\n127.0.0.1:6379> keys *\n1) \"shunshun\"\n127.0.0.1:6379> set name guoshun\nOK\n127.0.0.1:6379> keys *\n1) \"name\"\n2) \"shunshun\"\n127.0.0.1:6379> clear\n127.0.0.1:6379> keys *\n(empty list or set)\n127.0.0.1:6379> clear\n127.0.0.1:6379> keys *\n1) \"name\"\n2) \"shunshun\"\n127.0.0.1:6379> get name\n\"guoshun\"\n127.0.0.1:6379> EXPIRE name 10  #设置key的过期时间  单位是秒 \n(integer) 1\n127.0.0.1:6379> ttl name		#查看当前key的剩余时间\n(integer) -2\n127.0.0.1:6379> get name\n(nil)\n1) \"shunshun\" \n127.0.0.1:6379> type shunshun 		#查看当前key 的类型\nstring\n127.0.0.1:6379> \n\n```\n\n\n\n#### String（字符串）\n\n```bash\n################################################### #################################################\n127.0.0.1:6379> set key1 v1 			#设置值\nOK\n127.0.0.1:6379> EXISTS key1				#判断某一个Key是否存在\n(integer) 1\n127.0.0.1:6379> APPEND key1 \"hello\"		#追加字符串，如果当前key不存在，就相当与setkey\n(integer) 7\n127.0.0.1:6379> get key1			#获得值\n\"v1hello\"\n127.0.0.1:6379> STRLEN key1         #获取字符串的长度\n(integer) 7\n127.0.0.1:6379> APPEND key1 \",loveguohun\"\n(integer) 18\n127.0.0.1:6379> \n#####################################################################################################\n#i++\n#步长\n127.0.0.1:6379> get views			初始浏览量为0\n\"0\"\n127.0.0.1:6379> incr views 			#自增1\n(integer) 1\n127.0.0.1:6379> incr views\n(integer) 2\n127.0.0.1:6379> get views\n\"2\"\n127.0.0.1:6379> decr views			#自减1 浏览量减一\n(integer) 1\n127.0.0.1:6379> decr views\n(integer) 0\n127.0.0.1:6379> get views\n\"0\"\n127.0.0.1:6379> INCRBY view 10  	#可以设置步长，指定浏览量！\n(integer) 10\n127.0.0.1:6379> DECRBY view 5  		\n(integer) 5\n127.0.0.1:6379> \n#####################################################################################################\n#字符串范围 range\n127.0.0.1:6379> set key1 \"hello,zhaoguoshun\"	#设置key1 的值\nOK\n127.0.0.1:6379> get key1\n\"hello,zhaoguoshun\"\n127.0.0.1:6379> GETRANGE key1 0 3				#截取字符串 【0，3】\n\"hell\"\n127.0.0.1:6379> GETRANGE key1 0 -1				#获取全部的字符串，和get key是一样的\n\"hello,zhaoguoshun\"\n127.0.0.1:6379> \n\n#替换\n127.0.0.1:6379> set key2 abcde\nOK\n127.0.0.1:6379> get key2\n\"abcdefg\"\n127.0.0.1:6379> SETRANGE key2 1 xx    #替换指定位置开始的字符串！\n(integer) 7\n127.0.0.1:6379> get key2\n\"axxdefg\"\n127.0.0.1:6379> \n\n#####################################################################################################\n#setex (set with expire) #设置过期时间\n#setnx	(set if not exist)#不存在设置  （在分布式锁中会常常使用!）\n127.0.0.1:6379> setex key3 30 \"hello\"		#设置key3 的值为hello。30秒后过期\nOK\n127.0.0.1:6379> ttl keys\n(integer) -2\n127.0.0.1:6379> ttl key3\n(integer) 19\n127.0.0.1:6379> get key3\n\"hello\"\n127.0.0.1:6379> setnx mykey \"redis\"			#如果mykey 不存在创建redis\n(integer) 1\n127.0.0.1:6379> keys *\n1) \"mykey\"\n2) \"key2\"\n3) \"key1\"\n127.0.0.1:6379> setnx mykey \"MongeDB\"		#如果mykey存在，就创建失败\n(integer) 0\n127.0.0.1:6379> \n\n#####################################################################################################mse\nmset \nmget\n127.0.0.1:6379> mset k1 v1 ke1 v2 k2 v3 k3 			#同时设置多个值\n(error) ERR wrong number of arguments for MSET\n127.0.0.1:6379> mset k1 v1 k2 v2 k3 v3\nOK\n127.0.0.1:6379> keys *\n1) \"k3\"\n2) \"k2\"\n3) \"k1\"\n127.0.0.1:6379> mget k1 k2 k3  						#同时获取多个值\n1) \"v1\"\n2) \"v2\"\n3) \"v3\"\n127.0.0.1:6379> msetnx k1 v1 k4 v4					#msetnx  是一个原子性的操作，要么一起成功要么一起失败！\n(integer) 0\n127.0.0.1:6379> get key4\n(nil)\n127.0.0.1:6379> \n\n#对象\n\nset user :1 {name :guoshun,age 3} 		#设置user：对象，值为json字符串来保存一个对象\n#这里的key是一个巧妙的设计：user：{id}:{filed} ,在redis中是完全ok的\n127.0.0.1:6379> mset user:1:name guohun user:1:age 2\n127.0.0.1:6379> mset user:1:name:guoshun user:1:age 2\n(error) ERR wrong number of arguments for MSET\n127.0.0.1:6379> mget user:1:name user:1:age\n1) \"guohun\"\n2) \"2\"\n127.0.0.1:6379> \n\n#######################################################################################################\ngetset #先get 在set \n\n127.0.0.1:6379> getset db redis			#如果不存在值，则返回null\n(nil)\n127.0.0.1:6379> get db		\n\"redis\"\n127.0.0.1:6379> getset db mongdb		#如果存在值，获取原来的值，并设置新的值\n\"redis\"\n127.0.0.1:6379> get db\n\"mongdb\"\n127.0.0.1:6379> \n\n```\n\n数据结构是相同的！\n\nString类型的使用类型：value除了是我们我都字符串还可以是我们的数字！\n\n- 计数器\n- 统计多单位的数量 uid \n- 粉丝数az\n- 对象缓存存储\n\n\n\n\n\n\n\n#### List（列表）\n\n基本的数据类型，列表\n\n在Redis里面，我们可以把list玩成，栈，队列，阻塞队列！\n\n所有的list命令都是l开头的\n\n```bash\n################################################################################################################\n127.0.0.1:6379> LPUSH list one					#将一个值，或多个值插入到列表头部 （左）\n(integer) 1\n127.0.0.1:6379> Lpush list two \n(integer) 2\n127.0.0.1:6379> Lpush list three\n(integer) 3\n127.0.0.1:6379> Lrange list 0 -1\n1) \"three\"\n2) \"two\"\n3) \"one\"\n127.0.0.1:6379> lrange - 1\n1) \"three\"\n2) \"two\"\n127.0.0.1:6379> \n\n127.0.0.1:6379> rpush list right				#将一个值或多个值，查到列表尾部（右）\n(integer) 4\n127.0.0.1:6379> lrange list 0 -1				#获取list中值\n1) \"three\"\n2) \"two\"\n3) \"one\"\n4) \"right\"\n127.0.0.1:6379> \n################################################################################################################\nLPOP\nRPOP\n\n127.0.0.1:6379> Lpop list 				#移除list 的第一个元素\n\"two\"\n127.0.0.1:6379> Rpop list\n\"right\"\n127.0.0.1:6379> lrange list 0 -1		#移除list的最后一个元素\n1) \"one\"\n127.0.0.1:6379> \n################################################################################################################\nLindex\n127.0.0.1:6379> clear\n127.0.0.1:6379> lindex list 0 	#通过下标获得list中的某一个值\n\"one\"\n127.0.0.1:6379> \n\n################################################################################################################\nLlen\n 127.0.0.1:6379> Lpush list one\n(integer) 1\n127.0.0.1:6379> lpush list two\n(integer) 2\n127.0.0.1:6379> \n127.0.0.1:6379> lpush list three\n(integer) 3\n127.0.0.1:6379> Llen list			返回列表的长度\n(integer) 3\n127.0.0.1:6379> \n################################################################################################################\n移除指定的值！\n取关 uid\nlrem  \n\n127.0.0.1:6379> lrange list 0 -1 \n1) \"three\"\n2) \"three\"\n3) \"two\"\n4) \"one\"\n127.0.0.1:6379> lrem list 1 one   					#移除list 中一个value ，精确匹配\n(integer) 1\n127.0.0.1:6379> lrange list 0 -1\n1) \"three\"\n2) \"three\"\n3) \"two\"\n127.0.0.1:6379> \n################################################################################################################\n\ntrim 修剪  ： list 截断\n127.0.0.1:6379> rpush mylist \"hello\"\n(integer) 1\n127.0.0.1:6379> rpush mylist \"hello1\"\n(integer) 2\n127.0.0.1:6379> rpush mylist \"hello2\"\n(integer) 3\n127.0.0.1:6379> rpush mylist \"hello3\"\n(integer) 4\n127.0.0.1:6379> ltrim mylist 1 2					#通过下标截取指定的长度，这个list已经被改变了，截取了只剩下截取的元素！\nOK\n127.0.0.1:6379> lrange mylist 0 -1\n1) \"hello1\"\n2) \"hello2\"\n127.0.0.1:6379> \n################################################################################################################\nlroplpush  #移除列表的最后一个元素，将它移动到新的列表中\n\n127.0.0.1:6379> rpush mylist \"hello\"\n(integer) 1\n127.0.0.1:6379> rpush mylist \"hello1\"\n(integer) 2\n127.0.0.1:6379> rpush mylist \"hello12\"\n(integer) 3\n127.0.0.1:6379> rpoplpush mylist myotherlist 		#移除列表的最后一个元素，将它移动到新的列表中\n\"hello12\"\n127.0.0.1:6379> lrange mylist 0 -1					#查看原来的表\n1) \"hello\"\n2) \"hello1\"\n127.0.0.1:6379> lrange myotherlist 0 -1				#查看目标列表中。确实存在该值\n1) \"hello12\"\n127.0.0.1:6379> \n\n################################################################################################################\nlset 将列表中指定下标的值替换为另一个值，更新操作\n127.0.0.1:6379> Exists list				#判断这一个列表是否存在\n(integer) 0\n127.0.0.1:6379> lset list 0 item		#如果不存在列表我们去更新就会报错\n(error) ERR no such key\n127.0.0.1:6379> lpush list value1\n(integer) 1\n127.0.0.1:6379> lrange list 0 0\n1) \"value1\"\n127.0.0.1:6379> lset list 0 item 		#如果存在，更新当前下标的值\nOK\n127.0.0.1:6379> lrange list 0 0		\n1) \"item\"	\n127.0.0.1:6379> 						#如果不存在，就会报错\n################################################################################################################\nlinsert #将某一个具体的value 插入到列表中，某个元素的前面或者后面\n\n127.0.0.1:6379> Rpush mylist hello\n(integer) 1\n127.0.0.1:6379> Rpush mylist word\n(integer) 2\n127.0.0.1:6379> Linsert mylist before \"word\" \"other\"\n(integer) 3\n127.0.0.1:6379> LRANGE mylist 0 -1\n1) \"hello\"\n2) \"other\"\n3) \"word\"\n127.0.0.1:6379> linsert mylist after word new \n(integer) 4\n127.0.0.1:6379> LRANGE mylist 0 -1\n1) \"hello\"\n2) \"other\"\n3) \"word\"\n4) \"new\"\n127.0.0.1:6379> \n\n```\n\n> 小结\n\n- 实际上是一个链表，before Node after ，left，right都可以插入值\n- 如果key 不存在，创建新的链表\n- 如果key 存在，新增内容\n- 如果移除了所有的值，空链表，也代表不存在！\n- 再两边插入或者改动值效率最高！中间元素，相对来水效率会低一点点\n\n消息排队！消息队列 Lpush Rpop 栈（Lpush ,Lpop）\n\n\n\n#### Set(集合)\n\nset中的值是不能重复的！\n\n```bash\n################################################################################################################\n\n127.0.0.1:6379> sadd myset \"hello\"					#set集合中添加元素\n(integer) 1\n127.0.0.1:6379> sadd myset \"guoshun\"				\n(integer) 1\n127.0.0.1:6379> sadd myset \"love guoshun\"\n(integer) 1\n127.0.0.1:6379> SMEMBERS myset						#查看指定set的所有值\n1) \"love guoshun\"\n2) \"guoshun\"\n3) \"hello\"\n127.0.0.1:6379> sismember mylist hello				#判断某一个值存不存在\n(integer) 0\n127.0.0.1:6379> sismember myset  hello\n(integer) 1\n127.0.0.1:6379> sismember myset word\n(integer) 0\n127.0.0.1:6379> \n################################################################################################################\n127.0.0.1:6379> scard myset 				#获取set集合中的内容元素个数！\n(integer) 3\n127.0.0.1:6379> \n################################################################################################################\nsrem \n127.0.0.1:6379> srem myset \"hello\"				#移除set集合中的指定元素\n(integer) \n127.0.0.1:6379> scard myset \n(integer) 2\n127.0.0.1:6379> SMEMBERS myset\n1) \"love guoshun\"\n2) \"guoshun\"\n127.0.0.1:6379> \n################################################################################################################\nset无序不重复集合\n\n127.0.0.1:6379> SMEMBERS myset			随机抽选出一个元素\n1) \"love guoshun\"\n2) \"guoshun\"\n127.0.0.1:6379> SRandmeMber myset\n\"love guoshun\"\n127.0.0.1:6379> SRandmeMber myset\n\"love guoshun\"\n127.0.0.1:6379> SRandmeMber myset\n\"guoshun\"\n127.0.0.1:6379> \n################################################################################################################\n删除指定的key，随机删除key ！\n127.0.0.1:6379> SMEMBERS myset\n1) \"love guoshun\"\n2) \"guoshun\"\n127.0.0.1:6379> spop myset					#随机移除元素\n\"guoshun\"\n127.0.0.1:6379> spop myset \n\"love guoshun\"\n127.0.0.1:6379> SMEMBERS myset\n(empty list or set)\n127.0.0.1:6379> \n################################################################################################################\n将一个指定的值，移动到另外一个set集合中\n\n127.0.0.1:6379> sadd myset \"hello\"\n(integer) 1\n127.0.0.1:6379> sadd myset \"hello1\"\n(integer) 1\n127.0.0.1:6379> sadd myset \"hello12\"\n(integer) 1\n127.0.0.1:6379> sadd myset \"set2\"\n(integer) 1\n127.0.0.1:6379> smove myset myset2 \"hello\"\n(integer) 1\n127.0.0.1:6379> SMEMBERS myset\n1) \"hello12\"\n2) \"set2\"\n3) \"hello1\"\n127.0.0.1:6379> SMEMBERS myset2\n1) \"hello\"\n127.0.0.1:6379> \n################################################################################################################\n微博 b站 共同关注（并集）\n数字集合类 \n	-差集\n	-交集\n	-并集\n127.0.0.1:6379> sadd key1 a\n(integer) 1\n127.0.0.1:6379> sadd key1 b\n(integer) 1\n127.0.0.1:6379> sadd key1 c\n(integer) 1\n127.0.0.1:6379> sadd key1 d\n(integer) 1\n127.0.0.1:6379> sadd key2 c\n(integer) 1\n127.0.0.1:6379> sadd key2 d\n(integer) 1\n127.0.0.1:6379> sadd key2 e\n(integer) 1\n127.0.0.1:6379> sdiff key key2 					#差集\n(empty list or set)\n127.0.0.1:6379> sdiff key1 key2 				\n1) \"b\"\n2) \"a\"\n127.0.0.1:6379> sdiff key2 key1\n1) \"e\"\n127.0.0.1:6379> sinter key1 key2				#交集\n1) \"d\"\n2) \"c\"\n127.0.0.1:6379> sunion key1 key2				#并集\n1) \"a\"\n2) \"c\"\n3) \"d\"\n4) \"b\"\n5) \"e\"\n127.0.0.1:6379>\n\n```\n\n微博，A用户将所有关注的人放在一个set集合中！将粉丝也放在一个集合中\n\n\n\n\n\n#### Hash(哈希)\n\n\n\nMap 集合，key-<key,vlaue>时候这个值是一个Map集合!本质和String类型没有太大区别\n\nhset myhash field guoshun\n\n\n\n```bash\n127.0.0.1:6379> hset myhash field guoshun					#set一个具体 key-value\n(integer) 1\n127.0.0.1:6379> hget myhash field							#获取一个字段值\n\"guoshun\"\n127.0.0.1:6379> hmset myhash field hello field2 world		#set 多个key-value\nOK\n127.0.0.1:6379> keys *\n1) \"key2\"\n2) \"key\"\n3) \"myhash\"\n127.0.0.1:6379> hget myhash field \n\"hello\"\n127.0.0.1:6379> hmget myhash field field2					#获取多个字段值\n1) \"hello\"\n2) \"world\"\n127.0.0.1:6379> hgetall myhash								#获取全部的字段\n1) \"field\"\n2) \"hello\"\n3) \"field2\"\n4) \"world\"\n127.0.0.1:6379> \n	\n127.0.0.1:6379> hdel myhash field					#删除hash指定的key字段！对应的value值也就消失了\n(integer) 1\n127.0.0.1:6379> hgetall myhash\n1) \"field2\"\n2) \"world\"\n127.0.0.1:6379> \n################################################################################################################\nhlen \n\n127.0.0.1:6379> hgetall myhash\n1) \"field2\"\n2) \"world\"\n3) \"field1\"\n4) \"hello\"\n127.0.0.1:6379> hlen myhash					#获取hash表的字段数量！\n(integer) 2\n127.0.0.1:6379> \n################################################################################################################\n127.0.0.1:6379> Hexists myhash field1				#判断hash中的指定字段是否存在！\n(integer) 1\n127.0.0.1:6379> hexists myhash filed3\n(integer) 0\n127.0.0.1:6379> \n################################################################################################################\n#只获得所有的field\n#只获得所有的value\n\n127.0.0.1:6379> hkeys myhash				#只获得所有的field\n1) \"field2\"\n2) \"field1\"\n127.0.0.1:6379> hvals myhash				#只获得所有的value\n1) \"world\"\n2) \"hello\"\n127.0.0.1:6379> \n################################################################################################################\nincr   decr\n\n127.0.0.1:6379> hincrby myhash fiedl3 1 			#指定增量\n(integer) 7\n127.0.0.1:6379> hincrby myhash fied3 -1\n(integer) -1\n127.0.0.1:6379> hincrby myhash fiedl3 -1\n(integer) 6\n127.0.0.1:6379> hsetnx myhash field4 hello				#如果不存在可以设置\n(integer) 1\n127.0.0.1:6379> hsetnx myhash field4 word				#如果存在则不可以设置\n(integer) 0\n127.0.0.1:6379> \n```\n\nhash应用场景：\n\n​	hash变更数据 user name age ，尤其是用户信息之类的，经常变动的信息！hash更适合于对象的存储，String更加适合字符串存储\n\n\n\n#### Zset（有序集合）\n\n在set的基础上，增加了一个值，set k1 v1  zset k1 score1 v1\n\n```bash\n127.0.0.1:6379> zadd mytset 1 one 				#添加一个值\n(integer) 1\n127.0.0.1:6379> zadd mytset 2 two 3 three		#添加多个值\n(integer) 2\n127.0.0.1:6379> zrange mytset 0 -1				#查看所有的值\n1) \"one\"\n2) \"two\"\n3) \"three\"\n127.0.0.1:6379> \n################################################################################################################\n排序\n\n127.0.0.1:6379> zadd salary 2500 xiaohong			#添加三个用户\n(integer) 1\n127.0.0.1:6379> zadd salary 5000 zhangsan\n(integer) 1\n127.0.0.1:6379> zadd salary 50  guoshun\n(integer) 1\n127.0.0.1:6379> ZRANGEByscore salary -inf +inf		显示全部用户 从小到大\n1) \"guoshun\"\n2) \"xiaohong\"\n3) \"zhangsan\"\n127.0.0.1:6379> ZRANGEByscore salary -inf +inf\n1) \"guoshun\"\n2) \"xiaohong\"\n3) \"zhangsan\"\n127.0.0.1:6379> zrangebyscore salary -inf +inf withscores		#显示所有用户，并且附带成绩\n1) \"guoshun\"\n2) \"50\"\n3) \"xiaohong\"\n4) \"2500\"\n5) \"zhangsan\"\n6) \"5000\"\n127.0.0.1:6379> zrangebyscore salary -inf 50 withscores			#显示工资小于50 员工的升序排序\n1) \"guoshun\"\n2) \"50\"\n127.0.0.1:6379> zrevrange salary 0 -1							#从大到小进行排序\n1) \"zhangsan\"\n2) \"guoshun\"\n127.0.0.1:6379> \n\n################################################################################################################\n移除rem 中的 \n\n127.0.0.1:6379> zrange salary 0 -1\n1) \"guoshun\"\n2) \"xiaohong\"\n3) \"zhangsan\"\n127.0.0.1:6379> zrem salary xiaohong			#移除有序集合中的元素\n(integer) 1\n127.0.0.1:6379> zcard salary\n(integer) 2\n################################################################################################################\n\n```\n\n案列思路：set 排序，存储班级成绩，工资表排序\n\n\n\n普通消息：重要消息 2、带权重进行判断\n\n排行榜应用实现，取top N测试\n\n\n\n### 三种特殊数据类型\n\n#### geospatial  地理位置\n\n朋友的定位，附近的人，打车距离计算\n\n\n\nRedis的Geo，版本就推出了！这个功能可以推算地理位置信息，两地之间的距离，方圆几里的人！\n可以查询一些测试数据\n\n>geoadd\n\n```bash\n#geoadd 添加地理位置信息、\n#规则：两级无法直接添加，我们一般会下载城市数据，直接通过java程序一次性导入\n有效经度从-180到180度。\n\n有效纬度从 -85.05112878 到 85.05112878 度。\n#参数 key 值（经度、维度、名称）\n127.0.0.1:6379> geoadd china:city 112.98 28.1844 chgangsha\n(integer) 1\n127.0.0.1:6379> geoadd china:city 115.54226 34.826 heze\n(integer) 1\n127.0.0.1:6379> geoadd china:city 120.369 36.09 qingdao\n(integer) 1\n127.0.0.1:6379> geoadd china:city 116.49 39.90 beijing 114.05 22.52 shengzhen\n(integer) 2\n127.0.0.1:6379> geoadd china:city 120.16 30.24 hangzhou 108.96 34.26 xian\n(integer) 2\n127.0.0.1:6379> \n\n```\n\n\n\n> geopos \n\n获得当前定位：一定是一个坐标值\n\n```bash\n127.0.0.1:6379> geopos china:city chgangsha			#获取城市的经度和纬度、\n1) 1) \"112.9800000786781311\"\n   2) \"28.18439976131180202\"\n127.0.0.1:6379> geopos china:city heze\n1) 1) \"115.54226070642471313\"\n   2) \"34.82600034434852176\"\n127.0.0.1:6379> \n\n```\n\n\n\n>Geodist\n\n两人之间的距离\n\n单位：\n\n- **m** 表示单位为米。\n- **km** 表示单位为千米。\n- **mi** 表示单位为英里。\n- **ft** 表示单位为英尺。\n\n```bash\n127.0.0.1:6379> geodist china:city  chgangsha  beijing     #查看长沙到北京的直线距离\n\"1342311.5318\"\n127.0.0.1:6379> geodist china:city  chgangsha  beijing  km		#查看长沙到北京的直线距离\n\"1342.3115\"\n127.0.0.1:6379> geodist china:city chgangsha heze km\n\"777.5632\"\n127.0.0.1:6379> \n\n```\n\n>georadius \n\n我附近的人？（获得所有人的地址，定位！）通过半径来查询\n\n获得指定数量的人，200\n\n所有数据应该都录入：china：city，才会让结果更加清晰\n\n```bash\n127.0.0.1:6379> GEORadius china:city 112 20 10000 km			#以112 20 这个经纬度为中心，寻找方圆1000km的城市\n1) \"xian\"\n2) \"shengzhen\"\n3) \"chgangsha\"\n4) \"hangzhou\"\n5) \"heze\"\n6) \"qingdao\"\n7) \"beijing\"\n127.0.0.1:6379> GEORadius china:city 112 20 10000 km withdis				#显示到中间距离的位置\n1) 1) \"xian\"\n   2) \"1614.1206\"\n2) 1) \"shengzhen\"\n   2) \"351.7187\"\n3) 1) \"chgangsha\"\n   2) \"915.7281\"\n4) 1) \"hangzhou\"\n   2) \"1403.3277\"\n5) 1) \"heze\"\n   2) \"1685.3538\"\n6) 1) \"qingdao\"\n   2) \"1967.0316\"\n7) 1) \"beijing\"\n   2) \"2254.4608\"\n127.0.0.1:6379> georadius china:city 112 20 500 km withdist withcoord count 1  #筛选出指定的结果\n1) 1) \"shengzhen\"\n   2) \"351.7187\"\n   3) 1) \"114.04999762773513794\"\n      2) \"22.5200000879503861\"\n127.0.0.1:6379> \n\n```\n\n\n\n> GEORaDiusBymenber\n\n```bash\n#找出位于指定元素周围的其他元素\n127.0.0.1:6379> GEORADIUSBYMEMBER china:city beijing  4000 km 			#\n1) \"xian\"\n2) \"shengzhen\"\n3) \"chgangsha\"\n4) \"hangzhou\"\n5) \"heze\"\n6) \"qingdao\"\n7) \"beijing\"\n127.0.0.1:6379> GEORADIUSBYMEMBER china:city beijing  1000 km \n1) \"heze\"\n2) \"qingdao\"\n3) \"beijing\"\n4) \"xian\"\n127.0.0.1:6379> \n\n```\n\n> GEO 底层的实现原理其实就是Zset! 我们可以使用Zset命令来操作 geo\n\n```bash\n127.0.0.1:6379> zrange china:city 0 -1						#查看地图中全部元素\n1) \"xian\"\n2) \"shengzhen\"\n3) \"chgangsha\"\n4) \"hangzhou\"\n5) \"heze\"\n6) \"qingdao\"\n7) \"beijing\"\n127.0.0.1:6379> zrem china:city beijing						#移除指定元素\n(integer) 1\n127.0.0.1:6379> zrange china:city 0 -1\n1) \"xian\"\n2) \"shengzhen\"\n3) \"chgangsha\"\n4) \"hangzhou\"\n5) \"heze\"\n6) \"qingdao\"\n127.0.0.1:6379> \n```\n\n\n\n\n\n#### Hyperloglog\n\n\n\n基础（不重复的元素）\n\n> 简介\n\nRedis 2.8.9版本就更新了，Hyperloglog数据结构\n\n\n\nredis Hyperloglog 基数统计算法\n\n优点：占用的内存是固定的！如果从内存角度来比较的话，Hyperloglog首选\n\n\n\n> 测试使用\n\n```bash\n127.0.0.1:6379> Pfadd mykey a b c d e f g h i  j  			#创建第一组元素 \n(integer) 1\n127.0.0.1:6379> pfcount mykey								#统计mykey中的基数数量\n(integer) 10	\n127.0.0.1:6379> pfadd mykey2 k l m n o p q r s t 			#创建第二组\n(integer) 1\n127.0.0.1:6379> pfcount mykey2\n(integer) 10\n127.0.0.1:6379> pfmerge mykey3 mykey mykey2					#合并两组\nOK\n127.0.0.1:6379> pfcount mykey3								#看并集的数量\n(integer) 19\n127.0.0.1:6379> \n```\n\n如果允许容错，那么一定可以使用 Hyperloglog\n\n如果不允许那么就使用set或者自己的数据类型即可！\n\n\n\n\n\n#### Bitmap\n\n>位存储\n\n应用场景：\n\n统计用户信息：活跃，不活跃！ 登录、未登录！两个状态的都可以使用  Bitmaps\n\nBitmap位图，数据结构！都是操作二进制位来进行记录，就只有0和1两个状态\n\n365天=365bit 1字节=8bit 46字节左右\n\n\n\n使用bitmaps来记录周一到周日的打卡\n\n周一:1 周二：0  周三:1   \n\n![image-20201107143207558](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201107143207558.png)\n\n查看某一天是否打卡\n\n```bash\n127.0.0.1:6379> getbit sign 0	\n(integer) 1\n127.0.0.1:6379> getbit sign 6\n(integer) 0\n127.0.0.1:6379> \n\n```\n\n\n\n统计操作,统计打卡的天数\n\n```bash\n127.0.0.1:6379> bitcount sign 			#统计这周打卡记录，就可以看到是否有全勤\n(integer) 3\n127.0.0.1:6379> \n\n```\n\n\n\n## 事务\n\nRedis事务本质：一组命令的集合！一个事务中的所有命令都叫被序列化，在事务执行过程中，会按照顺序执行。\n\n一次性、顺序性、排他性！执行一些列的命令！\n\n==Redis事务没有隔离级别的概念==\n\n所有的命令在事务中，并没有直接执行！只有发起执行命令的时候才会执行！Exec\n\n==Redis单条命令是保存原子性的，但是事务是不保存原子性的。==\n\n\n\nRedis事务\n\n- 开启事务（multi）\n- 命令入队（.....）\n- 执行事务（exec）\n\n> 正常执行事务！\n\n```bash\n127.0.0.1:6379> multi							#开启事务\nOK\n\n#命令入队\n127.0.0.1:6379> set k1 v1\nQUEUED\n127.0.0.1:6379> set k2 v2 \nQUEUED\n127.0.0.1:6379> get k2\nQUEUED\n127.0.0.1:6379> set k3 v3\nQUEUED\n\n#执行事务\n127.0.0.1:6379> exec\n1) OK\n2) OK\n3) \"v2\"\n4) OK\n\n```\n\n> 放弃事务\n\n```bash\n127.0.0.1:6379> MULTI \nOK\n127.0.0.1:6379> set k1 v1 \nQUEUED\n127.0.0.1:6379> set k4 v4\nQUEUED\n127.0.0.1:6379> DISCARD											#取消事务\nOK\n127.0.0.1:6379> get k4											#事务队列中命令都不会被执行\n(nil)\n127.0.0.1:6379> \n\n```\n\n> 编译型异常（代码有问题！命令有错），事务中所有的命令都不会被执行\n\n```bash\n127.0.0.1:6379> multi \nOK\n127.0.0.1:6379> set k1 v1 \nQUEUED\n127.0.0.1:6379> set k2 v2 \nQUEUED\n127.0.0.1:6379> set k3 v3\nQUEUED\n127.0.0.1:6379> getset k3									#错误的命令\n(error) ERR wrong number of arguments for \'getset\' command	\n127.0.0.1:6379> set k4 v4\nQUEUED\n127.0.0.1:6379> set k5 v5\nQUEUED\n127.0.0.1:6379> exec										#执行事务报错\n(error) EXECABORT Transaction discarded because of previous errors.  #所有的命令都不会执行\n127.0.0.1:6379> \n\n```\n\n\n\n\n\n> 运行时异常（1/0）,如果事务队列中存在语法中错误，其他命令是可以正常执行的，错误命令会抛出异常\n\n```bash\n127.0.0.1:6379> set k1 \"v1\"\nOK\n127.0.0.1:6379> MULTI\nOK\n127.0.0.1:6379> incr k1\nQUEUED\n127.0.0.1:6379> \n127.0.0.1:6379> set k2 v2\nQUEUED\n127.0.0.1:6379> set k3 v3\nQUEUED\n127.0.0.1:6379> exec\n1) (error) ERR value is not an integer or out of range					#虽然第一条命令报错了，但是依旧正常执行成功了\n2) OK\n3) OK\n127.0.0.1:6379> get k2\n\"v2\"\n127.0.0.1:6379> get k3\n\"v3\"\n127.0.0.1:6379> \n\n```\n\n\n\n> 监控！Watch （面试常问）\n\n**悲观锁：**\n\n- 很悲观，什么时候都会出问题，无论做什么都会加锁！\n\n**乐观锁：**\n\n- 很乐观，认为什么时候都不会出现问题，所以不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据，version！\n- 获取version\n- 更新的时候比较version\n\n> Redis测监视测试\n\n正常执行成功\n\n```bash\n127.0.0.1:6379> set money 100\nOK\n127.0.0.1:6379> set out 0\nOK\n127.0.0.1:6379> watch money		#监视money \nOK	\n127.0.0.1:6379> multi				#事务正常结束，数据期间没有发生变动，这个时候就正常执行成功！\nOK\n127.0.0.1:6379> decrby money 20\nQUEUED\n127.0.0.1:6379> incrby out 20\nQUEUED\n127.0.0.1:6379> exec\n1) (integer) 80\n2) (integer) 20\n127.0.0.1:6379> \n\n```\n\n测试多线程修改完值，使用watch可以当做redis的乐观锁操作！\n\n```bash\n127.0.0.1:6379> set money 100\nOK\n127.0.0.1:6379> set out 0\nOK\n127.0.0.1:6379> watch money						#监视money\nOK\n127.0.0.1:6379> multi\nOK\n127.0.0.1:6379> decrby money 20\nQUEUED\n127.0.0.1:6379> incrby out 20\nQUEUED\n127.0.0.1:6379> exec							#执行之前，另一个线程，修改了我们的值，这个时候就会导致事务执行失败！\n1) (integer) 80\n2) (integer) 20\n127.0.0.1:6379> \n\n```\n\n如果修改失败，获取最新的值就好\n\n![image-20201107154225168](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201107154225168.png)\n\n\n\n\n\n## Jedis\n\n我们要使用java来操作Redis\n\n> 什么是Jedis  是redis官方推荐的java连接开发工具！使用java来操作Redis中间件！如果要使用Java操作Redis,那么一定要对Jedis十分的熟悉！\n\n> 测试\n\n1. 导入对应的依赖\n\n   ```xml\n       <dependencies>\n           <!--  导入jedis包-->\n           <dependency>\n               <groupId>redis.clients</groupId>\n               <artifactId>jedis</artifactId>\n               <version>3.2.0</version>\n           </dependency>\n   \n           <!--fastjson-->\n           <dependency>\n               <groupId>com.alibaba</groupId>\n               <artifactId>fastjson</artifactId>\n               <version>1.2.75</version>\n           </dependency>\n       </dependencies>\n   ```\n\n   \n\n2. 编码测试\n\n   1. 连接数据库\n   2. 操作命令\n   3. 断开连接\n\n   ```java\n   import redis.clients.jedis.Jedis;\n   \n   public class TestPing {\n       public static void main(String[] args) {\n           // 1、new 一个Jedis 对象即可\n           Jedis jedis = new Jedis(\"127.0.0.1\",6379);\n           //jedis 所有的命令就是我们之前学习的指令\n           System.out.println(jedis.ping());\n       }\n   }\n   ```\n\n   连接成功后输出pong\n\n### 常用APi\n\nString\n\nList\n\nSet \n\nHash\n\nZset\n\n> 所有api就是上面学习的指令\n\n\n\n\n\n## Spirngboot整合\n\n\n\nSpingBoot 操作数据：spring-data \n\nspringdata也是和springboot齐名的项目！\n\n说明：在spring2.x之后jedis被替换成了lettuce\n\njedis:	采用的是直连，多个线程操作的话，是不安全的，如果想要避免不安全的，使用jeds连接池！\n\nlettuce:	采用netty，实例可以在多个线程中共享，不存在线程不安全的情况！可以减少线程数据了，更像\n\n\n\n源码分析：\n\n```java\n	@Bean\n	@ConditionalOnMissingBean(name = \"redisTemplate\")	//我们可以自定义一个redisTemplate来替换这个默认的\n	public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory)\n			throws UnknownHostException {\n        //默认的RedisTempate 没有过多的配置，redis 对象都是需要序列化！\n        //两个泛型都是Object，Object的类型，我们后使用需要强制转型<String,Object>\n		RedisTemplate<Object, Object> template = new RedisTemplate<>();\n		template.setConnectionFactory(redisConnectionFactory);\n		return template;\n	}\n\n	@Bean\n	@ConditionalOnMissingBean	//由于String是redis中最常使用的类型，所以说单独提出来了一个bean\n	public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory)\n			throws UnknownHostException {\n		StringRedisTemplate template = new StringRedisTemplate();\n		template.setConnectionFactory(redisConnectionFactory);\n		return template;\n	}\n```\n\n\n\n> 整合测试\n\n1. 导入依赖\n\n   ```xml\n   <!--操作redis-->\n           <dependency>\n               <groupId>org.springframework.boot</groupId>\n               <artifactId>spring-boot-starter-data-redis</artifactId>\n           </dependency>\n   ```\n\n   \n\n2. 配置连接\n\n   ```xml\n   #配置redis\n   spring.redis.host=127.0.0.1\n   spring.redis.port=6379\n   ```\n\n   \n\n3. 测试！\n\n   ```java\n   package com.zhaoguoshun;\n   \n   import org.junit.jupiter.api.Test;\n   import org.springframework.beans.factory.annotation.Autowired;\n   import org.springframework.boot.test.context.SpringBootTest;\n   import org.springframework.data.redis.connection.RedisConnection;\n   import org.springframework.data.redis.core.RedisTemplate;\n   \n   @SpringBootTest\n   class Redis02SpringbootApplicationTests {\n   \n       @Autowired\n       private RedisTemplate redisTemplate;\n   \n       @Test\n       void contextLoads() {\n           //redisTemplate 操作不同的数据类型，api和我们的指令是一样的\n           // opsForValue() 操作字符串的 类似String\n           //opsForList() 操作List 类似List\n           //opsForSet() \n           //opsForHash\n           //opsForGeo（）\n           //opsForHyperLogLog() \n           \n           \n           //除啦基本的操作，我们常用的方法都可以直接通过redsTemplate来操作，比如事务和基本你的CRUD \n           \n           //获取reds的连接对象\n   //        RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();\n   //        connection.flushAll();\n           \n           \n       }\n   \n   }\n   ```\n\n   \n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201108101356250.png\" alt=\"image-20201108101356250\" style=\"zoom:50%;\" />\n\n![image-20201108101542746](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201108101542746.png)\n\n\n\n对象的保存：\n\n![image-20201108152348100](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201108152348100.png)\n\n\n\n我们来编写一个自己的RedisTemplete\n\n```java\n    //这是一个固定模板，在企业中拿去就可以直接使用1\n    //编写我们自己的redisTemplate\n    @Bean\n    @SuppressWarnings(\"all\")\n    public RedisTemplate<String ,Object> redisTemplate(RedisConnectionFactory redisConnectionFactory){\n        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();\n\n        //json的序列化\n        Jackson2JsonRedisSerializer<Object> jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer<Object>(Object.class);\n\n\n        ObjectMapper om = new ObjectMapper();\n        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n        jackson2JsonRedisSerializer.setObjectMapper(om);\n\n        //String的序列化\n        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();\n\n        //key采用String的序列化方式\n        redisTemplate.setKeySerializer(jackson2JsonRedisSerializer);\n        //Hash的key也采用String的序列化方式\n        redisTemplate.setHashKeySerializer(stringRedisSerializer);\n        redisTemplate.setConnectionFactory(redisConnectionFactory);\n        //value序列化方式采用jackson\n        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);\n        //hash的value序列化方式采用jackson\n        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);\n        redisTemplate.afterPropertiesSet();\n        return redisTemplate;\n    }\n```\n\n\n\n所有的redis操作，对于java开发人员来说十分的简单，更总要的是要去理解redis的思想，和每一种数据类型，和应用场景。\n\n\n\n\n\n\n\n## Redis.conf详解\n\n启动的时候，就通过配置文件来启动！\n\n> 单位\n\n![image-20201108184458109](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201108184458109.png)\n\n1. 配置文件 unit单位对大小写不敏感\n\n> 包含\n\n![image-20201108184853056](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201108184853056.png)\n\n> 网络\n\n```bash\n bind 127.0.0.1  #绑定你的ip\n protected-mode no  #保护模式\n port 6379  		#端口设置\n\n```\n\n> 通用  GENERAL\n\n```bash\ndaemonize yes   #默认是no 以守护进程的方式运行，我们需要自己开启为yes\npidfile /var/run/redis_6379.pid   #如果以后台的方式运行，我们就需要指定一个pid文件！\n\n\n#日志\n# Specify the server verbosity level.\n# This can be one of:\n# debug (a lot of information, useful for development/testing)\n# verbose (many rarely useful info, but not a mess like the debug level)\n# notice (moderately verbose, what you want in production probably)		生产环境使用\n# warning (only very important / critical messages are logged)\nloglevel notice\nlogfile \"\"  		#日志默认的文件名\ndatabases 16        #数据库的数量默认 16个\nalways-show-logo yes   #是否总是显示logo\n\n```\n\n> 快照\n\n持久化，在规定的时间内，执行了多少次操作则会持久化到文件 .rdb.aof\n\nredis是内存数据库，没有持久化，数据断电就没了\n\n```bash\n#如果900秒内，如果至少有一个key进行了修改，我们就进行了持久化\nsave 900 1\n#如果300秒内，如果至少有一个10key进行了修改，我们就进行了持久化\nsave 300 10\n#如果60秒内，如果至少有一个10000key进行了修改，我们就进行了持久化\nsave 60 10000\nstop-writes-on-bgsave-error yes				#持久化出现错误之后，是否继续工作\nrdbcompression yes				#是否压缩rdb文件，需要消耗cpu资源\nrdbchecksum yes 				#保存rdb文件的时候，进行错误的检查校验\ndir ./							#rdb文件保存的目录\n \n```\n\n> REPLICATION  复制，我们后面讲主从复制的时候再进行讲解\n\n\n\n\n\n> SECURITY 安全\n\n可以在这里设置redis的密码，默认是没有密码的！\n\n```bash\n127.0.0.1:6379> config get requirepass					#获取redis的密码\n1) \"requirepass\"\n2) \"\"\n127.0.0.1:6379> config set requirepass \"985211\"			#设置redis的面膜\nOK\n127.0.0.1:6379> config get requirepass					#发现所有的命令都没有权限了\n(error) NOAUTH Authentication required.\n127.0.0.1:6379> ping\n(error) NOAUTH Authentication required.	\n127.0.0.1:6379> auth 985211								#使用密码进行登录\nOK\n127.0.0.1:6379> ping\nPONG\n127.0.0.1:6379> \n\n```\n\n> 限制 CLIENTS\n\n```bash\nmaxclients 10000  #设置redis的最大客户端的数量\n\nmaxmemory <bytes> #redis最大内存数量\naxmemory-policy noeviction	#内存到达上限的成功优酷策略\n	#移除一些过期的key\n	#报错\nnoeviction: 不进行置换，表示即使内存达到上限也不进行置换，所有能引起内存增加的命令都会返回error\n    \nallkeys-lru: 优先删除掉最近最不经常使用的key，用以保存新数据\n    \nvolatile-lru: 只从设置失效（expire set）的key中选择最近最不经常使用的key进行删除，用以保存新数据\n    \nallkeys-random: 随机从all-keys中选择一些key进行删除，用以保存新数据\n    \nvolatile-random: 只从设置失效（expire set）的key中，选择一些key进行删除，用以保存新数据\n    \nvolatile-ttl: 只从设置失效（expire set）的key中，选出存活时间（TTL）最短的key进行删除，用以保存新数据\n \n```\n\n> APPEND ONLY MODE 模式，aof配置\n\n```bash\nappendonly no		#默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部门情况下，rdb完全够用！\nappendfilename \"appendonly.aof\"			#持久化文件的名字\n	\n# appendfsync always		#每次修改都会 sync 消耗性能\nappendfsync everysec		#每秒执行一次	sync 可能会丢失这一秒数据\n# appendfsync no			#不执行 sync 这个时候操作系统自己同步数据，速度快\n```\n\n\n\n\n\n## Redis持久化\n\n\n\nRedis是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器退出，服务器中的数据库状态也会消失。所以Redis提供了持久化功能。\n\n\n\n### RDB(Redis DataBase)\n\n\n\n> 什么是RDB?\n\n![image-20201109092815426](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201109092815426.png)\n\n在指定的时间间隔内将内存中的数据集快照写入磁盘。\n\nredis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。我们默认就是RDB,一般不需要修改这个配置。\n\n有时候在生产环境我们会将这个dump.rdb备份\n\n==rdb保存的文件是 dump.rdb==\n\n![image-20201109093825315](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201109093825315.png)\n\n![image-20201109094109819](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201109094109819.png)\n\n\n\n> 触发机制\n\n1. save的规则满足情况下，会自动触发rdn规则\n2. 执行flushdb 、flushall 也会触发我们的rdb规则\n3. 退出redis，也会产生rdb文件\n\n备份就会自动生成一个dump.rdb文件\n\n\n\n> 如果恢复rdb文件！\n\n1. 只需要将rdb文件放在redis目录就可以了，redis启动的时候回自动检查dump.rdb 恢复其中的数据！\n2. 查看需要存在的位置\n\n```bash\n127.0.0.1:6379> config get dir						#查看我们\n1) \"dir\"\n2) \"/usr/local/redis/bin\"							#如果在这个目录下存在dump这个文件，启动的时候就会自动恢复其中的数据\n127.0.0.1:6379> \n\n```\n\n> 几乎就他自己默认的配置就够用了，但是我们还是需要去学习\n\n优点：\n\n1. 适合大规模的数据恢复！\n2. 如果你对数据的完整性要求不高\n\n缺点：\n\n1. 需要一定的时间间隔，如果redis意外宕机了\n2. fork进程的时候，会占用一定的内存空间。\n\n\n\n## AOF (Append Only File)\n\n将我们的所有命令都记录下来，history，恢复的时候就把这个文件全部执行一遍\n\n> 是什么\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201109102115334.png\" alt=\"image-20201109102115334\" style=\"zoom:50%;\" />\n\n\n\n> append\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201109102423377.png\" alt=\"image-20201109102423377\" style=\"zoom:50%;\" />\n\n默认是不开启的，需要手动配置！我们就需要将 appendoly 改为yes开启了aof!\n\n重启，redis就可以生效了。\n\n\n\n如果这个aof文件有错误，这时候，redis是启动不起来的，我们需要修复这个aof文件\n\nredis给我们提供了一个工具`redis-check-aof `\n\n![image-20201109104034460](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201109104034460.png)\n\n如果文件正常，重启就可以直接恢复了！\n\n![image-20201109104245563](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201109104245563.png)\n\n==恢复以后发现我们有错误的那一行数据被丢弃，找不到了==\n\n\n\n> 重写规则说明\n\naof默认就是文件的无限追加，文件会越来越大\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201109105158979.png\" alt=\"image-20201109105158979\" style=\"zoom: 50%;\" />\n\n\n\n如果aof文件大于64m ，太大了！fork一个新的进程来将我们的文件进行重写！\n\n> 优点和缺点\n\n优点：\n\n1. 每一次修改都同步，文件完整会更好\n2. 每秒同步一次，可能会丢失一秒的数据\n3. 从不同步，效率是最高的\n\n缺点：\n\n1. 相对于数据文件来说，aog远远大于rdb，修复的速度也比rdb慢\n2. Aof运行效率也比rdb慢，所有我们redis默认配置就是rdb\n\n\n\n\n\n## Redis发布订阅\n\nredis发布订阅是一种==消息通信模式==：发送者（pub）发送消息，订阅者（sub）接受消息。\n\nredis可以订阅任意数量的频道\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201109144148795.png\" alt=\"image-20201109144148795\" style=\"zoom: 67%;\" />\n\n> 命令\n\n这些命令被广泛构建即时通信应用，比如网络聊天室和实时广播，实时提醒等。\n\n![image-20201109145021914](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201109145021914.png)\n\n> 测试\n\n订阅端：\n\n```bash\n127.0.0.1:6379> SUBSCRIBE zhaoguoshun				#订阅以一个频道\nReading messages... (press Ctrl-C to quit)\n1) \"subscribe\"\n2) \"zhaoguoshun\"\n3) (integer) 1\n\n#等待推送信息\n1) \"message\"\n2) \"zhaoguoshun\"\n3) \"helloo\"\n1) \"message\"\n2) \"zhaoguoshun\"\n3) \"guoshun\"\n\n```\n\n发送端：\n\n```bash\n127.0.0.1:6379> PUBLISH zhaoguoshun \"helloo\"			#发布者发布消息到频道 \n(integer) 1\n127.0.0.1:6379> publish zhaoguoshun guoshun\n(integer) 1\n127.0.0.1:6379> \n\n```\n\n\n\n> 原理\n\n1. Redis是用C实现的，通过分析Redis源码里的pubsub.c文件，了解发布和订阅机制的底层实现，即此加深对redis的理解\n2. Redis 通过PUBLISH 、SUBSCRIBE 、 PSUBSCRUBE 等命令实现发布和订阅的功能\n\n\n\n使用场景:\n\n1. ​	实时消息系统！\n2. 实时聊天！（聊天室，将信息给回显给所有人）\n3. 订阅、关注系统都是可以的\n\n稍微复杂的场景我们就会使用消息中间件 MQ()\n\n\n\n\n\n\n\n## Redis主从复制\n\n==默认情况下，每台服务器都是一个主节点；==\n\n\n\n\n\n主从复制的作用主要包括：\n\n1. 数据冗余 ：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式\n2. 故障恢复：当主节点出现问题时，可以由节点提供服务，实现快速的故障恢复；实际是一种服务的沉余\n\n主从复制，读写分离! 80%的情况下都是在进行读操作！减缓服务器的压力！架构经常使用！\n\n\n\n==单台Redis最大使用内存不应该超过20G==\n\n\n\n\n\n只要在公司中，主从复制就是必须要使用的，因为在真实的项目中不可能单机使用redis!\n\n\n\n### 环境配置\n\n只配置从库，不用配置主库\n\n```bash\n127.0.0.1:6379> inf replication			\n(error) ERR unknown command `inf`, with args beginning with: `replication`, \n127.0.0.1:6379> info replication			#查看当前库的信息	\n# Replication\nrole:master						#角色 master\nconnected_slaves:0				#没有从机\nmaster_replid:ef682f65b4fbba8840024aa9fc3e74456ee16ba6\nmaster_replid2:0000000000000000000000000000000000000000\nmaster_repl_offset:0\nsecond_repl_offset:-1\nrepl_backlog_active:0\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:0\nrepl_backlog_histlen:0\n127.0.0.1:6379> \n\n```\n\n复制3个配置文件，修改对应信息\n\n1. 端口\n2. pid名字\n3. log文件名字\n4. dump.rdb 文件\n\n修改完毕之后，启动我们的三个redis服务器，可以通过进程信息查看！\n\n![image-20201109172704125](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201109172704125.png)\n\n### 一主二从\n\n==默认情况下，每台Redis服务器都是主节点；==我们一般情况下，只用配置之从机就好了\n\n\n\n认老大\n\n```bash\n127.0.0.1:6380> SLaveof 127.0.0.1 6379			#SLaveof   host 6379 \nOK\n127.0.0.1:6380> info replication\n# Replication\nrole:slave\nmaster_host:127.0.0.1							#可以看到主机的信息\nmaster_port:6379\nmaster_link_status:up\nmaster_last_io_seconds_ago:3\nmaster_sync_in_progress:0\nslave_repl_offset:28\nslave_priority:100\nslave_read_only:1\nconnected_slaves:0\nmaster_replid:13a460c853effea31b096e1652826fbbaf619caf\nmaster_replid2:0000000000000000000000000000000000000000\nmaster_repl_offset:28\nsecond_repl_offset:-1\nrepl_backlog_active:1\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:1\nrepl_backlog_histlen:28\n127.0.0.1:6380> \n\n#在主机中查看\n127.0.0.1:6379> info replication\n# Replication\nrole:master\nconnected_slaves:1				#多了从机的配置\nslave0:ip=127.0.0.1,port=6380,state=online,offset=182,lag=0\nmaster_replid:13a460c853effea31b096e1652826fbbaf619caf\nmaster_replid2:0000000000000000000000000000000000000000\nmaster_repl_offset:182\nsecond_repl_offset:-1\nrepl_backlog_active:1\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:1\nrepl_backlog_histlen:182\n127.0.0.1:6379> \n\n```\n\n两个都配置完以后，\n\n![image-20201110092137064](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201110092137064.png)\n\n真实的主从配置，应该在配置文件中配置，这样的话是永久的，我们这里使用的是命令，是暂时的\n\n\n\n> 配置文件中配置主机\n\n![image-20201110102633198](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201110102633198.png)\n\n这里写上主机的IP，和端口\n\n启动了主机和从机就可以看到配置成功\n\n![image-20201110102739862](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201110102739862.png)\n\n![image-20201110102805319](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201110102805319.png)\n\n> 细节\n\n主机可以写从机只能读！主机中的所有信息和数据，都会自动被从机保存\n\n\n\n主机写：\n\n![image-20201110093042065](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201110093042065.png)\n\n从机只能读取内容：\n\n![image-20201110093203284](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201110093203284.png)\n\n\n\n测试：主机断开连接，从机依旧连接到主机的，但是没有写操作了买这个时候，如果主机回来了，依旧可以直接获取到主机写的信息！\n\n\n\n如果是使用命令行，来配置的主从，如果重启了，就会变回主机！只要变为从机立马就会从主机中获取值！\n\n> 复制原理\n\n- Slave 启动成功连接到master后会发送一个sync命令\n\n- Master 接到命令，启动后台的存盘进程，同时收集所有的用于修改数据集命令，在后台进程执行完毕之后，==master将传送整个数据文件到slave，并完成一次完全同步。==\n\n- 全量复制：而Slave服务在接收到数据库文件时，将其存盘并加载到内存中\n\n- 增量复制：Master继续新的所有收集，到的修改命令依次传给slave，完成同步\n\n  但是只要是重新连接master，一次完全同步（全量复制）将被自动执行\n\n\n\n> 层层链路\n\n上一个master链接下一个S\n\n![image-20201110095841711](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201110095841711.png)\n\n\n\n> 如果主机断开，这个时候能不能选择一个主机？\n\n==谋朝篡位==\n\n如果主机断开了连接，我们可以使用 ·`SLAveof no one`使自己变成主机\n\n\n\n\n\n\n\n## 哨兵模式\n\n（自动选举老大的模式）\n\n> 概述\n\n主从技术的方法是，当服务器宕机后，需要手动配置一台服务器切换为主服务器，这就是得需要人工干预，费时费力，还会造成一段时间内服务不可用。这不是一种推荐方式更多的时候，我们优先考虑哨兵模式。\n\n\n\n能够后台监控主机是否故障，如果故障了个根据票数==自动将从库转换为主库。==\n\n\n\n哨兵是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，他会独立运行。其原理是哨兵通过发送命令，等待Redis服务响应，从而监控运行的多个Redis实例\n\n![image-20201110144951985](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201110144951985.png)\n\n我配置一个哨兵，如果哨兵宕机了怎么办？通常情况下我们会配置多个哨兵模式。\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201110145102170.png\" alt=\"image-20201110145102170\" style=\"zoom:67%;\" />\n\n\n\n假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为这个服务器不可用，这个现象称之为**主观下线**。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover故障转移操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称之为**客观下线**。\n\n\n\n> 测试\n\n1. 配置哨兵配置文件 sentinel.conf\n\n   ```bash\n   #sentinel monitor  被监控的名称 127.0.0.1 6379 1\n   sentinel monitor myredis 127.0.0.1 6379 1\n   ```\n\n   后面这个数字，代表主机挂了，slave投票看谁接替成为主机，票数最多的，就会成为主机！\n\n2. 启动哨兵\n\n   ```bash\n   [root@guoshun bin]# redis-sentinel guoshunconfig/sentinel.conf \n   16482:X 10 Nov 2020 15:19:17.834 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo\n   16482:X 10 Nov 2020 15:19:17.834 # Redis version=5.0.8, bits=64, commit=00000000, modified=0, pid=16482, just started\n   16482:X 10 Nov 2020 15:19:17.834 # Configuration loaded\n                   _._                                                  \n              _.-``__ \'\'-._                                             \n         _.-``    `.  `_.  \'\'-._           Redis 5.0.8 (00000000/0) 64 bit\n     .-`` .-```.  ```\\/    _.,_ \'\'-._                                   \n    (    \'      ,       .-`  | `,    )     Running in sentinel mode\n    |`-._`-...-` __...-.``-._|\'` _.-\'|     Port: 26379\n    |    `-._   `._    /     _.-\'    |     PID: 16482\n     `-._    `-._  `-./  _.-\'    _.-\'                                   \n    |`-._`-._    `-.__.-\'    _.-\'_.-\'|                                  \n    |    `-._`-._        _.-\'_.-\'    |           http://redis.io        \n     `-._    `-._`-.__.-\'_.-\'    _.-\'                                   \n    |`-._`-._    `-.__.-\'    _.-\'_.-\'|                                  \n    |    `-._`-._        _.-\'_.-\'    |                                  \n     `-._    `-._`-.__.-\'_.-\'    _.-\'                                   \n         `-._    `-.__.-\'    _.-\'                                       \n             `-._        _.-\'                                           \n                 `-.__.-\'                                               \n   \n   16482:X 10 Nov 2020 15:19:17.835 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.\n   16482:X 10 Nov 2020 15:19:17.835 # Sentinel ID is b3fd3fbdc8199bfdb03544b1ee4e575925f38fc7\n   16482:X 10 Nov 2020 15:19:17.835 # +monitor master myredis 127.0.0.1 6379 quorum 1\n   \n   ```\n\n   如果主机（Master）节点断开了，这个时候会从随机中选择一个服务器！（这里面有一个投票算法）。\n\n   自己总结的实战发现:\n\n   ==当我们的主机宕机服务回来之后，不会在成为主服务器（不会在成为老大），会成为从节点（跟其新老大）==\n\n   ​	哨兵日志：\n\n   <img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201110155131481.png\" alt=\"image-20201110155131481\" style=\"zoom:50%;\" />\n\n   此时如果主机回来了，只能归并到新的主机下，当做从机，这就是哨兵模式的规则\n\n   > 哨兵模式\n\n\n\n优点：\n\n1. 哨兵集群，基于主从复制，所有的主机从配置优点，它全有\n2. 主从可以切换，故障可以转移，系统的可用性就会更好。\n3. 哨兵模式就是主从模式的升级，手动到自动，更加健壮！\n\n缺点：\n\n1. Redis不好再线扩容的，集群容量一旦到达上限，在线扩容就十分麻烦！\n2. 实现哨兵模式的配置其实是很麻烦的，里面有很多选择！\n\n> 哨兵模式的全部配置\n\n```bahs\nprotected-mode no       #关闭保护模式                                                                                                 \n\nport 26479                    #端口                                                                                           \n\ndaemonize yes             #使用后台模式启动                                                                                               \n\npidfile \"/var/run/redis-sentinel_26479.pid\"                       #进程id文件                                                       \n\nlogfile \"/usr/local/redis/sentinel/sentinel_26479.log\"           #日志文件                                                        \n\ndir \"/usr/local/redis/sentinel\" 　　　　　　　　　　　　　　#工作目录\n\n \n\n核心配置\n\n1、sentinel monitor <master-name> <ip> <port> <quorum>\n\nmaster-name：redis主节点昵称。\n\nip：redis主机ip。\n\nport：redis主机端口。\n\nquorum：哨兵判断主节点是否发生故障的票数。如果设置为2，表示2个哨兵节点认为主节点发生了故障，一般设置为：哨兵节点数/2+1。\n\n2、sentinel down-after-milliseconds <master-name> <times>\n\n哨兵会定期的向redis节点发送ping命令来判断redis是否可达，若超过指定的times毫秒内还未得到pong回复，则判读该redis不可达。\n\n3、sentinel parallel-syncs <master-name> <nums>\n\n当redis主节点挂了后，哨兵会选出新的master，此时，剩余的slave会向新的master发起同步数据，这个设置表示允许并行同步的slave个数。\n\n4、sentinel failover-timeout <master-name>  <times>\n\n进行故障转移时，如果超过设置的times毫秒，表示故障转移失败。\n\n5、sentinel auth-pass <master-name> <password>\n\n如果redis主节点设置了密码，则需要进行这个配置。\n\n \n\n*****备注配置redis主从复制、读写分离*******\n\n配置思路：master配置文件不需要动，修改slave的配置文件。\n\n1、添加一行：replicaof <masterip> <masterport>\n\n2、如果master配置有密码，则需要配置这一行\n\n　　masterauth <master-password>\n\n3、replica-read-only yes　　　　#表示slave中的数据是只读的\n\n \n\n*****springboot整合redis哨兵模式*******\n\n添加yml配置文件\n\nspring:\n\n　　redis:\n　　　　database: 0\n　　　　password: 12345678\n　　　　sentinel:\n　　　　　　master: mymaster\n　　　　　　nodes: 192.168.0.1:26379,192.168.0.1:26479,192.168.0.1:26579\n```\n\n\n\n\n\n## Redis缓存穿透和雪崩\n\n\n\n![image-20201110164708522](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201110164708522.png)\n\n\n\n### 缓存穿透（查不到）\n\n> 概念\n\n缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库中没有，也就是缓存中没有，于是向数据库查询。发现也没有，于是本次查询失败。当很多用户的时候，缓存都没有命中,于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。\n\n\n\n> 解决方案\n\n**布隆过滤器**\n\n布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合规则丢弃，从而避免了对底层储存系统的从查询压力。\n\n\n\n**缓存空对象**\n\n当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据会从缓存中获取，保护了后端的数据源；\n\n\n\n### 缓存击穿（量太大，缓存过期！）\n\n> 概述\n\n这里需要主要和缓存击穿的区别，缓存击穿，是指一个key非常热点，再不停的扛着大并发，大并发集中对这一个点访问，当这个key在失效的瞬间，持续的大并发就能穿破缓存，直接请求数据库。就像在屏幕上凿开了一个洞。\n\n\n\n> 解决方案\n\n**设置热点数据永不过期**\n\n从缓存层面来看，没有设置过期时间，所以不会出现热点key过期产生的问题。\n\n\n\n**加互斥锁**\n\n分布式锁：使用分布式锁，保证每一个key只有一个线程取查询后端服务，其他线程没有获得分布式锁的权限，因此需要等待即可。这种方式将高并发的压力转到了分布式锁，因此对分布式锁的考验很大。\n\n\n\n\n\n\n\n### 缓存雪崩\n\n\n\n> 概念\n\n缓存某个节点宕机，断电或者断网都可能会产生缓存雪崩的现象。\n\n\n\n**redis高可用**\n\n这会的思想含义是，既然redis可能挂掉，那就多增加几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。\n\n（异地多活）\n\n**限流降级**（在SpringCloud有）\n\n这个解决方案的思想是，在缓存失效后，通过加锁或队列来控制·数据库写缓存的线程数量。\n\n\n\n\n\n> 小结\n\n\n\n', NULL, 0, 0, 0, NULL, '2021-01-01', 353, '2021-01-01', 9);
INSERT INTO `tb_article` VALUES (61, 37, 'Vue简单入门', 'http://39.106.163.62:8081/cms/upload/b9bb2ddf-6522-4be7-9833-c66bca5bf2db.jpg', '\\  Vue    HTML CSS JS  视图   给用户看 刷新后台的数据     网络通信 axios    页面跳转 vue-router    状态管理 vuex    MVVM model-view-view-model     HTML先加载js     \\   xml    \\                v-bind   \"\"        \\   v-if v-else  ', '', '\\# Vue\n\n\n\nHTML+CSS+JS :视图: `给用户看，刷新后台的数据`\n\n\n\n网络通信：axios\n\n\n\n页面跳转：vue-router\n\n\n\n状态管理：vuex\n\n\n\nMVVM(model-view-view-model)\n\n\n\nHTML先加载js：\n\n\n\n\\```xml\n\n<script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js\"></script>\n\n\\```\n\n\n\n{{}}\n\n\n\n v-bind: =\"\"\n\n\n\n\n\n\n\n\\## v-if v-else\n\n\n\n判断if  属性 v-if\n\n\n\n循环for v-for\n\n\n\n\\```html\n\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\n\n\n​    \"http://www.w3.org/TR/html4/loose.dtd\">\n\n<html>\n\n<head>\n\n\n  <title>Title</title>\n\n</head>\n\n<body>\n\n<div id=\"app\">\n\n\n\n\n  <h1 v-if=\"type===\'A\'\">A</h1>\n  <h1 v-else-if=\"type===\'B\'\">B</h1>\n  <h1 v-else-if=\"type===\'C\'\">C</h1>\n  <h1 v-else>No</h1>\n\n</div>\n\n\n\n<!--导入vue.js-->\n\n<script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js\"></script>\n<script>\n\n\n\n\n  var vue=new Vue({\n\n​    el: \"#app\",\n\n​    data : {\n\n​      type: \"A\"\n\n​    }\n\n  });\n\n</script>\n\n</body>\n\n</html>\n\n\\```\n\n\n\n\n\n\n\n\\# v-for\n\n\n\n\\```html\n\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\n\n\n​    \"http://www.w3.org/TR/html4/loose.dtd\">\n\n<html>\n\n<head>\n\n\n    <meta charset=\"UTF-8\">\n\n\n  <title>Title</title>\n\n</head>\n\n<body>\n\n\n\n<div id=\"app\">\n\n\n\n\n\n\n  <li v-for=\" item in items\">\n\n​    {{item.message}}\n\n  </li>\n\n</div>\n\n\n\n<!--导入vue.js-->\n\n<script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js\"></script>\n<script>\n\n\n\n\n  var vue=new Vue({\n\n​    el: \"#app\",\n\n​    data:{\n\n​      items: [\n\n​        {message : \'Java\'},\n\n​        {message : \'Vue\'},\n\n​        {message : \'运维\'},\n\n​        {message : \'赵国顺\'}\n\n​      ]\n\n​    }\n\n  });\n\n</script>\n\n</body>\n\n</html>\n\n\\```\n\n\n\n\n\n\n\n\n\n\n\n\\## 事件: on\n\n\n\n 可以用 `v-on` 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。 v\n\n\n\n\\```HTML\n\n<!DOCTYPE html>\n\n\n<html lang=\"en\" xmlns:v-on=\"http://www.w3.org/1999/xhtml\">\n\n<head>\n\n\n    <meta charset=\"UTF-8\">\n\n\n  <title>事件</title>\n\n</head>\n\n<body>\n\n\n\n<div id=\"app\">\n\n\n\n\n  <button v-on:click=\"sayHi\">click me</button>\n\n</div>\n\n\n\n<!--导入vue.js-->\n\n<script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js\"></script>\n<script>\n\n\n\n\n  var vue=new Vue({\n\n​    el: \"#app\",\n\n​    data: {\n\n​      message: \"顺总学Java\"\n\n​    },\n\n​    methods :{//方法必须定义在vue的method对象中\n\n​      sayHi: function () {\n\n​        alert(this.message);\n\n​      }\n\n​    }\n\n  });\n\n</script>\n\n</body>\n\n</html>\n\n\\```\n\n\n\n**网络通信**\n\n- JQuery.ajax\n\n## 什么是Axios?\n\nAxios是一个·开源的可以在浏览器端和`Nodejs`的异步通讯框架，它的主要作用就是实现AJAX异步通信,其功能特点如下：\n\n- 从浏览器创建XMLHttpRequests\n- 从 node.js 创建 [http](http://nodejs.org/api/http.html) 请求\n- 支持 [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) API\n- 拦截请求和响应\n- 转换请求数据和响应数据\n- 取消请求\n- 自动转换 JSON 数据\n- 客户端支持防御 [XSRF](http://en.wikipedia.org/wiki/Cross-site_request_forgery)\n\n\n\n## Vue生命周期\n\nVue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染->更新->渲染 卸载等一系列过程，我们称这是Vue的生命周期。\n\n\n\n\n\n\n\n## Vue计算属性、内容分发、自定义事件\n\n### 什么是计算属性？\n\n计算属性：计算出来的结果保存在属性中~，内存中运行：虚拟dom\n\n计算属性的特点突出在`属性`两个字上（属性是个名词），首先它必须是个`属性`其次这个属性有`计算`功能(计算是动词) 这里的计算是个函数；**简单点说它就是一个能将计算结果缓存存储起来的属性**（将行为转换为静态的属性）。仅此而已可以想象为缓存\n\n\n\n````html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>计算属性</title>\n</head>\n<body>\n<div id=\"app\">\n\n    <p>currentTime1:{{currentTime1()}}</p>\n    <p>currentTime2{{currentTime2}}</p>\n</div>\n\n<!--导入vue.js-->\n<script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js\"></script>\n\n<script>\n\n\n    var vue =new Vue({\n        el: \"#app\",\n      data: {\n            message : \"hello,Java\"\n      },\n      methods :{\n        currentTime1: function () {\n            return Date.now();//返回一个时间戳\n        }\n      },\n        computed:{//计算属性  methods和computed方法名不能重名，重名之后只会调用methods方法中的\n            currentTime2: function () {\n                this.message;\n                return Date.now();//返回一个时间戳\n            }\n        }\n    })\n</script>\n</body>\n</html>\n````\n\n**说明**：\n\n- methods:定义方法，调用方法使用currentTime1（）需要带括号\n\n- computed：定义计算属性，调用currentTime2,不需要带括号；this.message是为了能让currentTime2观察到数据变化而变化。\n- 如果在方法中的值发生了变化，则缓存就会刷新，可以在控制台使用`vue.message=\"hello,Java\"`，改变下数据的值。再次测试观察效果\n\n**结论**：\n\n​		调用方法时每次都需要进行进行计算，既然有计算过程必然产生系统开销，那如果这个结果是不经常变化的呢？此时我们可以考虑将这个结果存储起来，采用计算属性可以很方便的做到这一点，**计算属性的主要特征就是为了将不经常变化的计算结果进行缓存，以节约我们的系统开销。**\n\n\n\n### 内容分发（重要)\n\n在Vue.js中我们使用<slot>元素作为承载分发内容的出口作者其成为‘插槽’，可以应用在组合组件的场景中\n\n插槽\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>组件</title>\n</head>\n<body>\n<div id=\"app\">\n    <todo-title slot=\"todo-title\" :title=\"title\">{}</todo-title>\n    <todo-items slot=\"todo-items\" v-for=\"item in TodoItems\" :item=\"item\"></todo-items>\n</div>\n\n<!--导入vue.js-->\n<script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js\"></script>\n\n<script>\n\n    Vue.component(\"todo\",{\n        template: \'<div>\\\n        <slot name=\"todo-title\"></slot>\\\n            <ui>\\\n                <slot name=\"todo-items\"></slot>\\\n            </ui>\\\n        </div>\'\n    });\n\n    Vue.component(\"todo-title\",{\n        props: [\'title\'],\n        template: \'<div>{{title}}</div>\'\n    });\n    Vue.component(\"todo-items\",{\n        props: [\'item\'],\n        template: \'<li>{{item}}</li>\'\n    });\n\n\n\n    var vue =new Vue({\n        el: \"#app\",\n        data: {\n            title: \"赵国顺学习\",\n            TodoItems: [\"Java\",\"Vue\",\"前端\"]\n        }\n    })\n</script>\n</body>\n</html>·\n```\n\n### 自定义事件（*）\n\n组件内部绑定事件需要用到`this$emit(\'事件名\'，参数)`\n\n通过以上代码不难发现，数据项在Vu实例中，\n\n但删除操作要在组件中完成，那组件如何才能删除Vue实例中的数据呢？此时就设计到参数传递和事件分发了，Vue为我们提供了自定义的功能很好的帮助了我们解决了这个问题；使用this.$emit(\'自定义事件·名\'，参数)，操作过程如下：\n\n1-在Vue实例中，增加了methods对象并义了一个为removeItems的方法```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>自定义事件内容分发</title>\n</head>\n<body>\n<div id=\"app\">\n    <todo-title slot=\"todo-title\" :title=\"title\"></todo-title>\n    <todo-items slot=\"todo-items\" v-for=\"(item,index) in TodoItems\"\n                :item=\"item\" v-bind:index=\"index\" v-on:remove=\"removeItems(index)\"></todo-items>\n</div>\n\n<!--导入vue.js-->\n<script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js\"></script>\n\n<script>\n\n    Vue.component(\"todo\",{\n        template: \'<div>\\\n        <slot name=\"todo-title\"></slot>\\\n            <ui>\\\n                <slot name=\"todo-items\"></slot>\\\n            </ui>\\\n        </div>\'\n    });\n\n    Vue.component(\"todo-title\",{\n        props: [\'title\'],\n        template: \'<div>{{title}}</div>\'\n    });\n    Vue.component(\"todo-items\",{\n        props: [\'item\',\'index\'],\n        //只能绑定当组件的方法\n        template: \'<li>{{index}}----{{item}}<button @click=\"remove\">删除</button></li>\',\n\n        methods:{\n            remove: function (index) {\n                this.$emit(\'remove\',index)\n            }\n        }\n    });\n\n\n\n    var vue =new Vue({\n        el: \"#app\",\n        data: {\n            title: \"赵国顺学习\",\n            TodoItems: [\"Java\",\"Vue\",\"前端\"]\n        },\n\n        methods: {\n            removeItems: function (ins) {\n                console.log(\"删除了\"+this.TodoItems[ins]+\"ok\");\n                this.TodoItems.splice(ins,1);//一次删除一个元素\n            }\n        }\n    })\n</script>\n</body>\n</html>\n```\n\n\n\n### 说明\n\nVue的开发都是基NodeJs,实际开发始于vue-cli脚手架开发，vue-router路由，vuex做状态管；Vue-UI.界面我们一使用ElementUI(饿了么出品)，或者ICE(阿里巴巴)快速搭建前端项目\n\n\n\n## Vue：第一个Vue-cli项目\n\n\n\n### 什么是Vue-cli？\n\nvue-cli是官方官方提供的一个脚手架，用于快速生成一个vue的项目模板。\n\n预先定义好的目录结构及基础代码，就好比创建Maven项目时，可以选择创建一个骨架项目，这个骨架项目就是脚手架，使我们开发更加的迅速。\n\n\n\n**主要功能**\n\n- 统一的目录结构\n- 本地调试\n- 热部署\n- 单元测试\n- 集成打包上线\n\n### 需要环境\n\nnodejs: http://nodejs.cn/download/ \n\n**确认nodejs安装成功**\n\n- cmd下输入`node -v` 查看能否正确打印出版本号即可\n- cmd下输入`npm -v` 查看能否正确打印出版本号即可\n\n**安装node.js淘宝镜像加速器（cnpm）**\n\n这样的话，下载会快很多\n\n```\n# -g就是全局安装\nnpm install cnpm -g\n\n#使用如下语句解决，npm速度慢问题\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n\n```\n\n![1598694072561](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1598694072561.png)\n\n### 安装vue-cli\n\n```\ncnpm install vue-cli -g\n\n#测试是否安装成功\n#查看可以基于那些模板创建vue应用程序，通常我们选择webpack\nvue list\n```\n\n\n\n创建vue目录\n\nvue init webpack myvue\n\n![1598695123711](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1598695123711.png)\n\n### **初始化并运行**\n\n```\ncd myvue\n#导入所有依赖\nnpm install\n启动vue\n#npm run dev\n停止 Ctrl+c\n```\n\n\n\n## webPack\n\n### 什么是WebPack?\n\n本质上，webpack是一个现代JavaScript应用程序的静态模块打包器(module bundler)。当webpack处理应用程序时，他会\n\n递归地构建一个依赖关系图，其中包含应应程序需要的每个模块，然后讲所有这些模块打包成一个huo多个bundle.\n\n\n``` \nimport \"jquery\";导入\nexport  function doStuff(){}导出\nmodule \"localModule\"{} \n```\n\n\n\n\n\n### 安装Webpack\n\nwebPack是一款模块加载器兼打包工具，他能把各种资源，如JS、JSX、ES6、SASS、Less、图片等都作为模块来处理1和使用。\n\n\n\n**安装**：\n\n```nodejs\nnpm install webpack -g\nnpm install webpack-cli -g\n```\n\n测试安装成功：\n\n- webpack -v\n- webpack-cli -v\n- ![1599463449212](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1599463449212.png)\n\n### 配置\n\n创建`webpack.config.js`配置文件\n\n- ​	entry：入口文件，指定WebPack用那个文件作为项目的入口\n- output：输出，指定WebPack把处理完后的文件放置到指定路径\n- module：模块，用于处理各种类型的文件\n- plugins：插件，如：热更新、代码重用等\n- resolve：设置路径指向\n- watch：监听，用于设置文件改动后直接打包\n\n\n\n### 使用Webpack\n\n1. 创建项目\n2. 创建一个名为modules的目录，用于放置JS模块等资源文件\n3. 在modules下创建模块文件，如hello.js，用于编写JS模块相关代码\n\n\n\n\n\n## Vue vue-router路由\n\n### vue-router是什么?\n\n这里的路由并不是指我们平时所说的硬件路由器，**这里的路由就是SPA（单页应用）的路径管理器**。再通俗的说，vue-router就是WebApp的链接路径管理系统。\n vue-router是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。vue的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。传统的页面应用，是用一些超链接来实现页面切换和跳转的。在vue-router单页面应用中，则是路径之间的切换，也就是组件的切换。**路由模块的本质 就是建立起url和页面之间的映射关系**。\n\n\n\n### vue-router实现原理\n\nSPA(single page application):单一页面应用程序，只有一个完整的页面；它在加载页面时，不会加载整个页面，而是只更新某个指定的容器中内容。**单页面应用(SPA)的核心之一是: 更新视图而不重新请求页面**;vue-router在实现单页面前端路由时，提供了两种方式：Hash模式和History模式；根据mode参数来决定采用哪一种方式。\n\n\n\n### 1、Hash模式：\n\n**vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。** hash（#）是URL 的锚点，代表的是网页中的一个位置，单单改变#后的部分，浏览器只会滚动到相应位置，不会重新加载网页，也就是说**hash 出现在 URL 中，但不会被包含在 http 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面**；同时每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置；所以说**Hash模式通过锚点值的改变，根据不同的值，渲染指定DOM位置的不同数据。hash 模式的原理是 onhashchange 事件(监测hash值变化)，可以在 window 对象上监听这个事件**。\n\n\n\n\n\n### 2、History模式：\n\n\n\n由于hash模式会在url中自带#，如果不想要很丑的 hash，我们可以用路由的 history 模式，只需要在配置路由规则时，加入\"mode: \'history\'\",**这种模式充分利用了html5 history interface 中新增的 pushState() 和 replaceState() 方法。这两个方法应用于浏览器记录栈，在当前已有的 back、forward、go 基础之上，它们提供了对历史记录修改的功能。只是当它们执行修改时，虽然改变了当前的 URL ，但浏览器不会立即向后端发送请求**。\n\n  ![1599481868239](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1599481868239.png)\n\n\n\nVue-router是Vue.js官方的路由管理器。它和vue.js的核心深度集成，让构建单页面应用变得易如反掌。包括功能有：\n\n- 嵌套的路由/视图表\n- 模块化的、基于组件的路由配置\n- 路由参数、查询、通配符\n- 等\n\n\n\n\n\n\n\n\n\n### 安装\n\n基于第一个`vue-cli`进行测试学习；先查看node_modules中是否存在 vue-router\n\nvue-router是一个插件包，所以我们还需要npm/cnpm来进行安装的。打开命令行工具，进入到你都项目目录，输入以下命令\n\n```nodejs\nnpm install vue-router --save-dev\n```\n\n\n\n如果在一个模块化工程中使用它，必须要通过vue.use()明确地安装路由功能\n\n\n\n\n\n## Vue+ElementUI\n\n\n\n我们采用实战教学模式并结合`ElementUi`组件库，将所需要知识点应用到实际中，最快速度掌握Vue\n\n\n\n### 创建工程\n\n注意：命令行都要使用管理员模式\n\n\n\n1. 创建一个Hello-vue的工程`vue init webpack hello-vue`\n2. 安装依赖，我们需要安装vue-router 、element-ui、sass-loader喝node-sass四个插件\n\n```vue\n#进入目录工程\ncd hello-vue\n#安装vue-router\nnpm install vue-router --save-dev\n#安装elementUI\nnpm i element-ui -S\n#安装依赖\nnpm install\n#安装Sass加载器\ncnpm install sass-loader node-sass --save-dev\n#启动测试\nnpm run dev\n```\n\n\n\nmain.js引入element-ui\n\n```vue\nimport ElementUI from \'element-ui\';\nimport \'element-ui/lib/theme-chalk/index.css\';\n\n\nnew Vue({\n  el: \'#app\',\n  render: h => h(App)\n});\n```\n\n\n\n\n\n创建一个router文件,router下创建index.js\n\n```Vue\nimport  Vue from \'vue\'\nimport Router from \'vue-router\'\nimport Main from \'../views/Main\'\nimport login from \'../views/Login\'\n\nVue.use(Router);\n\n\nexport default new Router({\n  routes: [\n    {\n      path: \'/main\',\n      component: Main\n    },{\n        path: \'/login\',\n        component: login\n    }\n  ]\n})\n\n```\n\n\n\n定义的login页面\n\n```vue\n<template>\n\n  <el-form :model=\"ruleForm\" status-icon :rules=\"rules\" ref=\"ruleForm\" label-width=\"100px\" class=\"demo-ruleForm\">\n    <el-form-item label=\"密码\" prop=\"pass\">\n      <el-input type=\"password\" v-model=\"ruleForm.pass\" autocomplete=\"off\"></el-input>\n    </el-form-item>\n    <el-form-item label=\"确认密码\" prop=\"checkPass\">\n      <el-input type=\"password\" v-model=\"ruleForm.checkPass\" autocomplete=\"off\"></el-input>\n    </el-form-item>\n\n    <el-form-item>\n      <el-button type=\"primary\" @click=\"submitForm(\'ruleForm\')\">提交</el-button>\n      <el-button @click=\"resetForm(\'ruleForm\')\">重置</el-button>\n    </el-form-item>\n  </el-form>\n</template>\n<script>\n  export default {\n    data() {\n      var checkAge = (rule, value, callback) => {\n        if (!value) {\n          return callback(new Error(\'年龄不能为空\'));\n        }\n        setTimeout(() => {\n          if (!Number.isInteger(value)) {\n            callback(new Error(\'请输入数字值\'));\n          } else {\n            if (value < 18) {\n              callback(new Error(\'必须年满18岁\'));\n            } else {\n              callback();\n            }\n          }\n        }, 1000);\n      };\n      var validatePass = (rule, value, callback) => {\n        if (value === \'\') {\n          callback(new Error(\'请输入密码\'));\n        } else {\n          if (this.ruleForm.checkPass !== \'\') {\n            this.$refs.ruleForm.validateField(\'checkPass\');\n          }\n          callback();\n        }\n      };\n      var validatePass2 = (rule, value, callback) => {\n        if (value === \'\') {\n          callback(new Error(\'请再次输入密码\'));\n        } else if (value !== this.ruleForm.pass) {\n          callback(new Error(\'两次输入密码不一致!\'));\n        } else {\n          callback();\n        }\n      };\n      return {\n        ruleForm: {\n          pass: \'\',\n          checkPass: \'\',\n          age: \'\'\n        },\n        rules: {\n          pass: [\n            { validator: validatePass, trigger: \'blur\' }\n          ],\n          checkPass: [\n            { validator: validatePass2, trigger: \'blur\' }\n          ],\n          age: [\n            { validator: checkAge, trigger: \'blur\' }\n          ]\n        }\n      };\n    },\n    methods: {\n      submitForm(formName) {\n        this.$refs[formName].validate((valid) => {\n          if (valid) {\n            alert(\'submit!\');\n          } else {\n            console.log(\'error submit!!\');\n            return false;\n          }\n        });\n      },\n      resetForm(formName) {\n        this.$refs[formName].resetFields();\n      }\n    }\n  }\n</script>\n\n```\n\n\n\nmain.js下\n\n```Vue\nimport Vue from \'vue\'\nimport App from \'./App\'\nimport router from \'./router\'\nimport ElementUI from \'element-ui\';\nimport \'element-ui/lib/theme-chalk/index.css\';//不导入样式不会加载\n\nVue.use(ElementUI)\n\n/* eslint-disable no-new */\nnew Vue({\n  el: \'#app\',\n  router,\n  render: h => h(App)\n});\n\n```\n\n\n\n\n\napp.vue\n\n```vue\n<template>\n  <div id=\"app\">\n    <router-link to=\"/login\">login</router-link>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\n\nexport default {\n  name: \'App\',\n\n}\n</script>\n\n```\n\n\n\n嵌套路由：\n\n在router js 中的路径中用children\n\n```vue\nexport default new Router({\n  routes: [\n    {\n      path: \'/main\',\n\n      component: Main,\n\n      //嵌套路由\n      children: [\n        {path: \'/user/profile\',\n          name: UserProfile,\n          component: UserProfile, props: true},\n        {path: \'/user/list\',component: UserList}\n      ]\n    },{\n        path: \'/login\',\n        component: login\n    },\n    {\n      path: \'/goHome\',\n      redirect:\'/main\'\n    }\n  ]\n})\n```\n\n\n\n\n\n## 路由传递参数\n\n### 第一种:\n\n1. 路由传递参数方式，在路由中使用name传递，参数使用params方式\n\n```vue\n<template>\n\n  <ui>\n    <li><router-link :to=\"{name:\'UserProfile\',params:{id: 1}}\">个人信息</router-link></li>\n    <li><router-link :to=\"{name:\'UserList\',params:{id: 5}}\">所有用户</router-link></li>\n    <router-view></router-view>\n  </ui>\n\n</template>\n\n```\n\n\n\n2.而router js中的path路径就要改为加/：参数名称\n\n```vue\nchildren:[\n        {\n          path:\'/user/list/:id\',\n          name: \'UserList\',\n          component: UserList\n        },{\n        path: \'/user/profile/:id\',\n          name: \'UserProfile\',\n          component:  UserProfile\n        }\n      ]\n```\n\n3.去出参数可以使用{{$route.params.参数名}}\n\n```vue\n<template>\n  <div>\n    <h1>个人信息</h1>\n    {{this.$route.params.id}}\n  </div>\n</template>\n\n<script>\n    export default {\n        name: \"UserProfile\"\n    }\n</script>\n\n<style scoped>\n\n</style>\n\n```\n\n\n\n### 第二种：通过**props**解耦\n\n\n\n1. 直接在router js  routes种加入props：true\n\n```vue\nroutes:[\n      children:[\n        {\n          path:\'/user/list/:id\',\n          name: \'UserList\',\n          component: UserList,\n          props:true\n        },{\n       \n      ]\n```\n\n2.路由传递的参数不变\n\n```vue\n<template>\n\n  <ui>\n    <li><router-link :to=\"{name:\'UserProfile\',params:{id: 1}}\">个人信息</router-link></li>\n    <li><router-link :to=\"{name:\'UserList\',params:{id: 5}}\">所有用户</router-link></li>\n    <router-view></router-view>\n  </ui>\n\n</template>\n```\n\n\n\n3.接收的参数，用props组件接收，不需要在{{$route.params.参数名称}}了\n\nprops[]种一定要用\'\'\n\n```vue\n<template>\n  <div>\n    <h1>用户信息</h1>\n    {{id}}\n  </div>\n\n\n</template>\n\n<script>\n    export default {\n      props:[\'id\'],\n        name: \"UserList\"\n    }\n</script>\n\n<style scoped>\n\n</style>\n\n```\n\n\n\n\n\n路由模式有两种，上面说过了\n\nhash:路径带#符号，如 http://localhost:8080/#/login \n\nhistory：路径不带\n\n```vue\nexport default new Router({\n  mode:\'history\',\n    routes:[\n    ]\n```\n\n\n\n## 路由钩子与异步请求\n\nbeforeRouteEnter:在进入路由前执行\n\nbeforeRouteLeave:在离开路由前执行\n\n\n\n他们都有三个参数   to,from,next\n\nbeforeRouteEnter:(to,from,next)=>{\n\n}\n\n参数说明：\n\n- to:路由将要跳转的路径信息\n- from:路径跳转前的路径信息\n- next :路由的控制参数\n  - next()：跳入下一个页面\n  - next(\'/path\'):改变路由的跳转方向，使其跳转到另一个方向\n  - next（Flase）：返回到原来页面\n  - next((vm)=>{})：仅在BeforeRouteEnter中可以，vm是组件\n\n\n\n### 安装axios\n\n```\ncnpm install axios -s\n#cnpm 有可能安装失败，多安装几次\n```\n\n```\n<template>\n  <div>\n    <h1>个人信息</h1>\n   {{id}}\n  </div>\n</template>\n\n<script>\n    export default {\n      props:[\'id\'],\n        name: \"UserProfile\",\n      //过滤器一样\n      beforeRouteEnter: (to,from,next)=>{\n        console.log(\"进入路由之前\");\n        next(vm=>{\n          vm.getData();\n        });\n    },\n      beforeRouteLeave: (to,from,next)=>{\n        console.log(\"进入路由之后\");\n        next();\n      },\n      methods:{\n        getData: function () {\n          this.axios({\n            method: \'get\',\n            url: \'http://localhost:8080/static/mock/data.json\',\n\n          }).then(function (response) {\n            console.log(response)\n          })\n        }\n      }\n\n    }\n</script>\n\n<style scoped>\n\n</style>\n\n```\n\n\n\n\n\n', NULL, 0, 0, 0, NULL, '2021-01-01', 353, '2021-01-01', 14);
INSERT INTO `tb_article` VALUES (62, 35, 'Dubbo', 'http://39.106.163.62:8081/cms/upload/9c82b2e4-d1b2-4d18-8fb3-39f5243169ff.jpg', 'Dubbo  ORM 单一应用架构 数据庞大不能分布  MVC架构 将单一应用分成多块 缺点不好维护  RPC 分布式架构 缺点不好调用   分布式服务框架 RPC      1601800132446 ', '', 'Dubbo\n\n\nORM:单一应用架构，数据庞大不能分布\n\nMVC架构：将单一应用分成多块，缺点不好维护\n\nRPC:分布式架构，缺点不好调用。\n\n分布式服务框架（RPC）：\n\n![1601800132446](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1601800132446.png)\n\n 如图分布式 用户页面service 相互调用。\n\n\n\nRPC:远程过程调用\n\n\n\n \n\n流动计算架构：\n\n![1601800347413](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1601800347413.png)\n\n\n\n\n\n## RPC:\n\n### 什么叫RPC?\n\nRPC是指远程过程调用，是一种进程间通信方式，它是一种技术的思想，而不是规范，它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显示编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同\n\n​	![1601803951653](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1601803951653.png)\n\nRPC框架有很多如：\n\ndubbo、gRPC、Thrift、HSE 、 HSF\n\n\n\nDubbo优点：\n\n- 面向接口代理的高性能RPC调用\n- 智能负载均衡\n- 服务自动注册与发现\n- 高度可扩展能力\n- 运行期流量调度\n- 可视化的服务治理与运维\n- <img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1601879553011.png\" alt=\"1601879553011\" style=\"zoom: 33%;\" />\n\n负载均衡：自动帮我们查找空闲的服务器，不造成资源浪费\n\n注册中心：那些服务器出了问题就会了解到\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1601804878934.png\" alt=\"1601804878934\" style=\"zoom: 50%;\" />\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1601805731586.png\" alt=\"1601805731586\" style=\"zoom:50%;\" />\n\n## 安装zookeeper注册中心\n\n注册中心有很多 dubbo推荐使用zookeeper\n\n1. 下载配置zookeeper \n\n   [zookeeper-3.4.11.tar.gz](D:\\zookeeper\\zookeeper-3.4.11.tar.gz) \n\n2. 配种Zookeper\n\n   1. bin中有个zkServer.cmd,在命令行启动，会发现一个错误，那是信息传送路径不存在。我们找到config目录下的zoo_sample.cfg 重新复制一份命名为zoo,配置里面dataDir=../data （注意要创建好data目录）。\n\n   2. 再在命令行里启动 bin 中的zkServer.cmd，将已经开启好\n\n      <img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1601879715699.png\" alt=\"1601879715699\" style=\"zoom: 33%;\" />\n\n   3. 再命令行里启动bin目录下的zkCli.cmd\n\n      ​	get / 查看根节点\n\n      ​	ls /查看所有根节点\n\n      ​	配置根节点： create -e /文件名称 参数值（例如：123456)\n\n      <img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1601879792916.png\" alt=\"1601879792916\" style=\"zoom:33%;\" />\n\n   ​	\n\n## 安装监控中心\n\n\n\n1. 解压好包  [incubator-dubbo-ops-master.zip](D:\\zookeeper\\监控中心\\incubator-dubbo-ops-master.zip) \n\n2. 找到dubbo-admin目录下的 java  application.properties确定好端口是zookeeper默认的端口号 mvn clean webpack\n\n   <img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1601880066655.png\" alt=\"1601880066655\" style=\"zoom: 50%;\" />\n\n3. 找到pom.xml目录，cmd   mvn clean package 用maven打成jar包。\n\n   \n\n4. 把jar包用cmd,java 运行 -java -jar 包名   ，运行完成浏览器输入默认端口号\n\n   http://localhost:7001/  默认的用户名和密码都是root\n\n   (注意zookeeper一定要启动，不然是访问不到的)\n\n   <img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1601891779653.png\" alt=\"1601891779653\" style=\"zoom:33%;\" />\n\n\n\n## 快速使用Dubbo\n\n导入Dubbo依赖\n\n```xml\n <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>dubbo</artifactId>\n            <version>2.6.2</version>\n        </dependency>\n<!--注册中心使用的是zookeeper，引入操作zookeeper的客户端-->\n<!--\n注意如果Duboo是2.6以前版本使用  zkclient操作zookeeper\n如果Duboo是2.6以后版本使用 curator操作zookeeper\n-->\n        <dependency>\n            <groupId>org.apache.curator</groupId>\n            <artifactId>curator-framework</artifactId>\n            <version>2.12.0</version>\n        </dependency>\n\n```\n\n\n\n```\n1.将服务提供者注册到注册中心\n	1.导入Dubbo依赖(2.6.2) /操作zookeeper的客户端（curator）\n	2.\n	\n2.让服务消费者去注册中心订阅服务提供者服务地址\n```\n\n​	\n\n### 整合spring\n\n\n\n添加好依赖以后  在resources 目录下添加  provider.xml\n\n配置提供者配置文件	`provider.xml`\n\ndubbo名称空间 ‘xmlns:dubbo=\"http://dubbo.apache.org/schema/dubbo\"’\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:dubbo=\"http://dubbo.apache.org/schema/dubbo\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-4.3.xsd        http://dubbo.apache.org/schema/dubbo        http://dubbo.apache.org/schema/dubbo/dubbo.xsd\">\n\n\n    <!-- 1.指定当前服务/应用的名字 （同样的服务名称相同，不要和别的服务相同）-->\n    <dubbo:application name=\"user-service-provider\"></dubbo:application>\n\n    <!-- 2. 指定注册中心位置-->\n    <!--    <dubbo:registry address=\"zookeeper://127.0.0.1:2181\"></dubbo:registry>-->\n    <dubbo:registry protocol=\"zookeeper\" address=\"127.0.0.1:2181\"></dubbo:registry>\n\n\n    <!--    3.指定通信规则 （通信协议？通信端口？）-->\n    <dubbo:protocol name=\"dubbo\" port=\"20880\"></dubbo:protocol>\n\n    <!--4.暴露服务 ref: 指向服务的真正实现对象 -->\n    <dubbo:service interface=\"com.zhaoguoshun.service.UserService\" ref=\"UserServiceImpl\"></dubbo:service>\n\n    <!--服务实现-->\n    <bean id=\"UserServiceImpl\" class=\"com.zhaoguoshun.gmall.service.Impl.UserServiceImpl\"/>\n\n</beans>\n\n```\n\n测试类：\n\n```java\npublic class MainApplication {\n\n    public static void main(String[] args) throws IOException {\n        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"provider.xml\");\n\n        applicationContext.start();\n        System.in.read();\n    }\n}\n```\n\n\n\n\n\n\n\n配置消费者配置文件  `consumer.xml`\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:dubbo=\"http://dubbo.apache.org/schema/dubbo\" xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-4.3.xsd        http://dubbo.apache.org/schema/dubbo        http://dubbo.apache.org/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <context:component-scan base-package=\"com.zhaoguoshun.service.Impl\"></context:component-scan>\n    <!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 -->\n    <dubbo:application name=\"order-service-provider\"  />\n\n    <!-- 使用multicast广播注册中心暴露发现服务地址 -->\n    <dubbo:registry address=\"zookeeper://127.0.0.1:2181\" />\n\n    <!-- 生成远程服务代理，可以和本地bean一样使用demoService -->\n    <dubbo:reference id=\"userService\" interface=\"com.zhaoguoshun.service.UserService\" />\n</beans>\n\n```\n\n（注意小心资源导出问题）：\n\n```xml\n    <build>\n        <resources>\n            <resource>\n                <directory>src/main/resources</directory>\n                <includes>\n                    <include>**/*.properties</include>\n                    <include>**/*.xml</include>\n                </includes>\n                <filtering>true</filtering>\n            </resource>\n            <resource>\n            <directory>src/main/java</directory>\n            <includes>\n                <include>**/*.properties</include>\n                <include>**/*.xml</include>\n            </includes>\n            <filtering>true</filtering>\n            </resource>\n        </resources>\n    </build>\n\n```\n\n现在提供者和消费者也都已经完成\n\n\n\n\n\n## 安装监控中心\n\n上面我们已经安装了一个监控中心 dubbo-admin,但dubbo还为我们提供了一个dubbo-monitor-simple\n\n\n\n- dubbo-admin:	\n\n  ​	图形化的服务管理页面，安装时需要指定注册中心地址，即可从注册中心中获取到所有的提供者/消费者进行配置管理\n\n- Dubbo-monitor-simple\n\n  简单的监控中心\n\n\n\n### 安装\n\n1. 找到  [incubator-dubbo-ops-master.zip](D:\\zookeeper\\监控中心\\incubator-dubbo-ops-master.zip) 下的dubbo-monitor-simple文件夹。pom.xml打包成target文件，我们把打包好的压缩包拿过去，这次不使用jar文件。\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1601899907434.png\" alt=\"1601899907434\" style=\"zoom: 67%;\" />\n\n2.压缩完，找到config文件下的 dubbo.properties文件，编辑文件默认为\n\n​	<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1601900089635.png\" alt=\"1601900089635\" style=\"zoom: 67%;\" />\n\n3.找到assembly.bin文件夹下的 start.bat双击打开。我们在浏览器输入localhost:8080会进入监控中心。\n\n（注意：不要忘记开启zookeeper注册）\n\n\n\n4.配置监控中心\n\n- ​	dubbo文档里面有一个  ` schema配置参考手册` 里面有所有的dubbo:配置。\n\n- ​	我们使用 dubbo:monitor来配置监控中心  \n\n- ​	dubbo:monitor里有两个参数：\n  - protocol=\'registry\'：自动连接注册中心\n  - address=\"注册中心端口号\" 手册配置注册中心		\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1601900461433.png\" alt=\"1601900461433\" style=\"zoom: 67%;\" />\n\n​			例如：\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1601900783975.png\" alt=\"1601900783975\" style=\"zoom:50%;\" />\n\n\n\n## SpringBoot整合Dubbo\n\n1. 创建SpringBoot 项目提供者和消费者\n\n   <img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1601964905458.png\" alt=\"1601964905458\" style=\"zoom: 50%;\" />\n\n2. 配置SpringBoot提供者\n\n   1. 导入Dubbo依赖  dubbo-starter  建议使用2.7.7\n\n      ```xml\n      		<dependency>\n      			<groupId>org.apache.dubbo</groupId>\n      			<artifactId>dubbo-spring-boot-starter</artifactId>\n      			<version>2.7.7</version>\n      		</dependency>\n      		<dependency>\n      			<groupId>org.apache.curator</groupId>\n      			<artifactId>curator-recipes</artifactId>\n      			<version>2.8.0</version>\n      		</dependency>\n      		<dependency>\n      			<groupId>org.apache.curator</groupId>\n      			<artifactId>curator-framework</artifactId>\n      			<version>2.12.0</version>\n      		</dependency>\n      ```\n\n      注意：SpringBoot2.0以上使用 2.65以上的依赖\n\n      ![1601965257900](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1601965257900.png)\n\n   2. 配置：Spring在xml里面配置dubbo相关的配置，SpringBoot在application.yml里面配置\n\n      ```xml\n      dubbo:\n        application:\n          name: boot-user-service-provider\n          #注册中心\n        registry:\n          address: zookeeper://127.0.0.1:2181\n          #指定通信规则\n        protocol:\n          name: dubbo\n          port: 2080\n        monitor:\n          protocol: registry\n      ```\n\n      \n\n   3. 由于我们暴露的类很多，我们需要暴露那个类就在类上面加一个Service .\n\n      (注意Service是Dubbo包下的Service不是Spring下的)\n\n      ```java\n      @Service//暴露服务\n      @org.springframework.stereotype.Service\n      ```\n\n   4. 启动SpringBoot,启动的时候要在启动类上加@EnableDubbo注解\n\n      <img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1601966892546.png\" alt=\"1601966892546\" style=\"zoom:50%;\" />\n\n      ​	\n\n3. 配置springboot消费者\n\n   1. 和提供者一样我们需要导入依赖  建议使用2.7.6\n\n      ```xml\n      		<dependency>\n      			<groupId>org.apache.dubbo</groupId>\n      			<artifactId>dubbo-spring-boot-starter</artifactId>\n      			<version>2.7.7</version>\n      		</dependency>\n      		<dependency>\n      			<groupId>org.apache.curator</groupId>\n      			<artifactId>curator-recipes</artifactId>\n      			<version>2.8.0</version>\n      		</dependency>\n      		<dependency>\n      			<groupId>org.apache.curator</groupId>\n      			<artifactId>curator-framework</artifactId>\n      			<version>2.12.0</version>\n      		</dependency>\n      ```\n\n   2. 配置YMl\n\n      ```yml\n      dubbo:\n        application:\n          name: boot-order-consumer\n        registry:\n          address: zookeeper://127.0.0.1:2181\n        monitor:\n          protocol: registry\n      \n      server:\n        port: 8081\n      \n      ```\n\n      \n\n   3. 远程调用接口，我们调用的接口也很多，Dubbo提供了@Reference注解来远程调用\n\n      <img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1601968657517.png\" alt=\"1601968657517\" style=\"zoom:50%;\" />\n\n4. 在启动类上添加@enableDubbo注解开启Dubbo功能\n\n   \n\n\n\n\n\n\n\n### 配置Properties文件优先级\n\n![1601973628243](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1601973628243.png)\n\n\n\n## spring 示例\n\n###  启动时检查 check=\"\"\n\n1. ​	当我们没有启动提供者时，启动了消费者，会自动检查报错\n\n​	\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1601974156386.png\" alt=\"1601974156386\" style=\"zoom: 50%;\" />\n\n2.我们不想检查报错时，可以在远程连接 中 添加`check=\"false\"` 关闭检查， \n\n```xml\n  <!-- 生成远程服务代理，可以和本地bean一样使用demoService -->\n    <dubbo:reference id=\"userService\"         interface=\"com.zhaoguoshun.service.UserService\" check=\"false\" />\n\n//全局配置\n<dubbo:consumer check=\"false\"></dubbo:consumer>\n```\n\n\n\n### 超时示例 timeout=\"\"\n\n```\n//超时，默认是超时1000ms\ntimeout=\"\"\n\n//全局配置\n<dubbo:consumer check=\"false\" timeout=\"3000\"></dubbo:consumer>\n\n```\n\n在消费者在远程调用里设置\n\n```xml\n<!--  check=\"false\" 关闭启动时报错 -->\n<!--    timeout=\"3000\"超时 ，默认超时1000-->\n    <dubbo:reference id=\"userService\" interface=\"com.zhaoguoshun.service.UserService\" timeout=\"5000\"/>\n```\n\n- 方法级优先，接口级次之，全局配置再次之。\n- 如果级别一样，则消费方优先，提供方次之。\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1602054177812.png\" alt=\"1602054177812\" style=\"zoom:50%;\" />\n\n```xml\n <dubbo:reference id=\"userService\" interface=\"com.zhaoguoshun.service.UserService\">\n\n        <dubbo:method name=\"getUserAddressList\" timeout=\"1000\">						</dubbo:method>\n</dubbo:reference>\n```\n\n- 优先级：\n\n  - dubbo:reference方法优先 ，\n  - 如果没有方法，reference优先\n  - 如果reference没有定义：dubbo:consumer优先\n\n  总结：\n\n  ​		1.精确优先\n\n  ​		2.消费者配置优先\n\n```xml\n//设置统一方的提供者全局配置\n<dubbo:provider timeout=\"1000\"></dubbo:provider>\n//设置统一方的消费者全局配置\n<dubbo:consumer check=\"false\" timeout=\"3000\"></dubbo:consumer>\n```\n\n\n\n### 重试次数 retries=\"\"\n\nretries=\"\" :重试次数 ，不包含第一次调用。0代表不重试\n\n- （幂等）（设置重试次数）【查询、删除、修改】\n\n- 非幂等（不能设置重试次数）【新增】\n\n\n\n### 多版本\n\n消费者可以使用提供者的多个版本 \n\n提供者：\n\n![1602058777959](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1602058777959.png)\n\n消费者：\n\n```xml\n//version： 使用提供者的版本号\n<dubbo:reference id=\"userService\" interface=\"com.zhaoguoshun.service.UserService\" version=\"2.0.0\">\n\n        <dubbo:method name=\"getUserAddressList\" timeout=\"1000\"></dubbo:method>\n    </dubbo:reference>\n```\n\n\n\n## 本地存根\n\n​	我们新建一个UserServiceStub类\n\n```java\nimport com.zhaoguoshun.bean.UserAddress;\nimport com.zhaoguoshun.service.UserService;\nimport org.springframework.util.StringUtils;\n\nimport java.util.List;\n\npublic class UserServiceStub implements UserService {\n\n    private final UserService userService;\n\n    public UserServiceStub(UserService userService) {\n        this.userService = userService;\n    }\n\n    public List<UserAddress> getUserAddressList(String userId) {\n\n        System.out.println(\"我是本地存根\");\n        if (!StringUtils.isEmpty(userId)){\n          return   userService.getUserAddressList(userId);\n        }\n        return null;\n    }\n}\n```\n\n在消费者 xml里面配置 dubbo:reference  的stub属性\n\n```xml\n    <dubbo:reference id=\"userService\" interface=\"com.zhaoguoshun.service.UserService\" version=\"2.0.0\" stub=\"com.zhaoguoshun.service.Impl.UserServiceStub\">\n\n<!--        <dubbo:method name=\"getUserAddressList\" timeout=\"1000\"></dubbo:method>-->\n    </dubbo:reference>\n\n```\n\n\n\n\n\n## SpringBoot示例\n\nSpringBoot与dubbo整合的三种方式：\n\n1. 导入dubbo-starter，在application.properties配置属性，使用@Service【暴露服务】使用@Reference【引用服务】\n\n2. 保留dubbo xml配置文件\n\n   1. 导入Dubbo-starter,使用@ImportResource导入xml文件\n\n3. 使用注解API方式\n\n   1. 将每一个组件手动创建到容器中，让Dubbo扫描其他的组件\n\n      ```java\n      import com.zhaoguoshun.service.UserService;\n      import org.apache.dubbo.config.*;\n      import org.springframework.context.annotation.Bean;\n      import org.springframework.context.annotation.Configuration;\n      \n      import java.util.ArrayList;\n      import java.util.List;\n      \n      @Configuration\n      public class MyDubboConfig {\n      \n          @Bean\n          //  <dubbo:application name=\"user-service-provider\"></dubbo:application>\n          public ApplicationConfig applicationConfig(){\n              ApplicationConfig applicationConfig = new ApplicationConfig();\n              applicationConfig.setName(\"boot-user-service-provider\");\n              return applicationConfig;\n          }\n      //     <!-- 2. 指定注册中心位置-->\n      //    <!--    <dubbo:registry address=\"zookeeper://127.0.0.1:2181\"></dubbo:registry>-->\n          @Bean\n          public RegistryConfig registryConfig(){\n              RegistryConfig registryConfig = new RegistryConfig();\n      \n              registryConfig.setProtocol(\"zookeeper\");\n              registryConfig.setAddress(\"127.0.0.1:2181\");\n              return registryConfig;\n          }\n      \n          //<dubbo:protocol name=\"dubbo\" port=\"20883\"></dubbo:protocol>\n          @Bean\n          public ProtocolConfig protocolConfig(){\n              ProtocolConfig protocolConfig = new ProtocolConfig();\n              protocolConfig.setName(\"dubbo\");\n              protocolConfig.setPort(200880);\n              return protocolConfig;\n          }\n      \n          //  <!--4.暴露服务 ref: 指向服务的真正实现对象 -->\n          //    <dubbo:service interface=\"com.zhaoguoshun.service.UserService\" ref=\"UserServiceImpl01\" version=\"1.0.0\"></dubbo:service>\n          @Bean\n          public ServiceConfig<UserService> userServiceServiceConfig(UserService userService){\n              ServiceConfig<UserService> serviceConfig = new ServiceConfig<>();\n              serviceConfig.setInterface(UserService.class);\n              serviceConfig.setRef(userService);\n              serviceConfig.setVersion(\"1.0.0\");\n      \n              //配置每一个method信息\n              MethodConfig methodConfig = new MethodConfig();\n      \n              methodConfig.setName(\"getUserAddressList\");\n              methodConfig.setTimeout(2000);\n      \n              List<MethodConfig> methodConfigs=new ArrayList<>();\n              methodConfigs.add(methodConfig);\n              //将method的设置关联到serviceConfig里面\n              serviceConfig.setMethods(methodConfigs);\n      \n      \n              return serviceConfig;\n          }\n      }\n      \n      ```\n\n\n\n\n## 高可用\n\n1. zookeeper宕机与**Dubbo直连**\n\n现象：zookeeper注册中心宕机，还可以消费Dubbo暴露的服务\n\n原因：\n\n- 监控中心宕掉不影响使用，只是丢失部分采样数据\n\n- 数据库宕掉后，注册中心扔能通过缓存提供服务列表查询，但不能注册新服务\n\n- 注册中心对等集群，任意一台宕掉后，将自动切换到另一台\n\n- **注册中心全部宕掉之后，服务提供者和服务消费者仍能通过本地缓存通讯**\n\n- 服务提供者无状态任意一台宕掉后，不影响使用\n\n- 服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复。\n\n  \n\n  高可用通过设计，减少系统不能提供服务的时间\n\nDubbo直连：\n\n@Reference(url = \"127.0.0.1:2080\")\n\n\n\n负载均衡：\n\n1. RandomLoadBalance \n\n   基于权重的随机分配\n\n   ![1602138917843](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1602138917843.png)\n\n2. RoundRobin LoadBalance\n\n   基于权重的轮询负债均衡机制\n\n   ![1602139174626](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1602139174626.png)\n\n3. LeastActive LoadBalance\n\n   最少活跃数 负债均衡机制\n\n   \n\n\n\n## 服务降级\n\n1. 什么是服务降级？\n\n   当服务器压力剧增的情况下根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作。\n\n**可通过服务降级功能临时屏蔽某个出错的非关键服务，并定义降级后的返回策略**\n\n其中：\n\n- ​	mock=force:return+null 表示消费方对该服务的方法的调用都返回null值，不发起远程调用。用来屏蔽不重要服务不可用时对调用方的影响\n- 还可以改为mock=fail:return+null表示消费方对该服务的方法调用在失败后，在返回null值，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。\n\n\n\n## 集群容错\n\n### 整合Hystrix\n\nHystrix旨在通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备拥有回退机制和断路器功能的线程和信号隔离，请求缓存和请求打包，以及监控和配置等功能\n\n\n\nerror与springboot版本不兼容\n\n1. 配置Spring-cloud-starter-netflix-hystrix\n\n   ```xml\n   <dependency>\n       <groupId>org.springframework.cloud</groupId>\n       <artifactId>spring-cloud-starter-hystrix</artifactId>\n       <version>1.4.7.RELEASE</version>\n   </dependency>\n   \n   ```\n\n2. 然后再Application类上加上@EnableHystrix\n\n\n\n\n\n## RPC原理\n\n没听懂~~~~\n\n\n\n\n\n## Dubbo原理\n\n\n\n1. Duboo原理  框架设计\n\n   ![1602308250843](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1602308250843.png)\n\n   - config 配置层：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类\n\n     proxy 服务代理层：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory\n\n      registry 注册中心层：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService\n\n     cluster 路由层：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance\n\n     monitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService\n\n     protocol 远程调用层：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter\n\n     exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer\n\n     ltransport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec\n\n     lserialize 数据序列化层：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool\n\n2. 标签解析\n\n   ![1602309315524](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1602309315524.png)\n\n\n\n\n\n', NULL, 0, 0, 0, NULL, '2021-01-01', 353, '2021-01-01', 4);
INSERT INTO `tb_article` VALUES (63, 25, 'SpringBoot入门', 'http://39.106.163.62:8081/cms/upload/fee0996d-e150-4a12-9ab5-39bdb71569c2.jpg', '微服务阶段    javase oop  mysql 持久化  html css js jQuery 框架 视图 框架运用不熟练 css不好  Javaweb 独立开发MVC三层架构的网站了 原始  ssm 框架 简化了我们的开发流程   ....', '', '#  **微服务阶段**\n\njavase：oop\n\nmysql:持久化\n\nhtml+css+js+jQuery+框架：视图 框架运用不熟练，css不好\n\nJavaweb：独立开发MVC三层架构的网站了：原始\n\nssm：框架：简化了我们的开发流程，配置也开始为复杂\n\n**war：tomcat运行**\n\nspring在简化：springboot-jar：内嵌tomcat，微服务架构！\n\n\n\n**高内聚，低耦合**\n\n\n\n# 第一个springboot\n\n​	到底多么简单\n\nspringboot：最新版\n\n\n\n官方提供了一个快速生成的网站！IDEA集成了这个网站\n\n\n\n\n\n更改端口号\n\n在application.properties中输入server.port=8081\n\n\n\n\n\n# 原理初探\n\n自动配置：\n\npom.xml\n\n- ```java\n  spring-boot-dependencies：核心依赖在父工程中\n  ```\n\n- 我们在写或者引入一些SpringBoot依赖的时候，不需要指定版本，就因为有这些版本仓库\n\n\n\n启动器\n\n- ```xml\n  <dependency>\n              <groupId>org.springframework.boot</groupId>\n              <artifactId>spring-boot-starter</artifactId>\n          </dependency>\n  ```\n\n- 启动器：说白了SpringBoot的启动场景；\n\n- 比如 spring-boot-starter-web，他就会自动帮我们导入web环境下的所有依赖！\n\n- Springboot会将所有的功能场景，都变成一个个启动器\n\n- 我们要使用什么功能，就需要找到对应的启动器就行了 `starter`\n\n\n\n**主程序：**\n\n```java\n//SpringBootApplication:标注这个类是一个SpringBoot应用\n@SpringBootApplication\npublic class Springboot01HellowordApplication {\n\n    public static void main(String[] args) {\n        //将SpringBoot应用启动\n        SpringApplication.run(Springboot01HellowordApplication.class, args);\n    }\n}\n```\n\n\n\n**注解**\n\n- ```java\n  @SpringBootConfiguration:SpringBootd的配置\n      	@Configuration：Spring配置类\n      	@Component：说明这也是一个Spring组件\n  \n  @EnableAutoConfiguration:自动配置\n      @AutoConfigurationPackage:自动配置包\n      @Import({AutoConfigurationImportSelector.class})\n  ```\n\n  - 获取候选的配置值\n\n    ```java\n     protected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {\n            List<String> configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());\n            Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.\");\n            return configurations;\n        }\n    ```\n\nMETA-INF/spring.factories:自动配置的核心文件\n\n![1581844280055](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1581844280055.png)\n\n思考：这么多配置为什么有的没有生效，需要导入对应的start才能有作用。\n\n核心注解：@ConditionalOnxxx：如果这里面的条件都满足，才会生效\n\n\n\n结论：SpringBoot所有的自动配置都在启动类中被扫描并加载 `spring.factories` 所有的自动配置类都在这里面，但是不一定生效，要判断条件是否成立，只要导入了对应的start,就有对应的启动器，有了启动器我们自动装配就会生效，然后就配置成功了\n\n\n\n1. ​	SpringBoot在启动的时候，从类路径下/META-INF/spring.factories获取指定的值；\n2. 将这些自动配置的导入容器，自动配置就会生效，帮我进行自动配置\n3. 以前我们需要配置的东西，现在Springboot帮我们做了！\n4. 整个JavaEE，解决方案和自动配置的东西都在spring-boot-autoconfigure-2.2.4.RELEASE.jar这个包下\n5. 它会把所有需要导入的组件，以类名的方式返回，这些组件就会被添加到容器；\n6. 容器中也会存在非常多的xxxxAutoConfiguration的文件，就是这些类给容器中导入了这个场景需要的 所有组件，并自动配置，@Configuration,JavaConfig\n7. 有了自动配置类，免去了我们手动编写配置文件的工作！\n\n\n\n\n\nJavaConfig		@Configuraion         	@Bean\n\n\n\nDocker:进程\n\n\n\n谈谈你对Springboot的理解\n\n- 自动装配\n- run（）\n\n\n\n全面接管SpringMVC的配置！实操\n\n\n\n# yaml\n\n==对空格的要求十分高==\n\n==可以注入到我们的配置类中==\n\nproperties只能存键值对\n\nyaml 可以存对象，数组\n\n​	**语法**：名称：空格名称\n\n![1582015722634](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1582015722634.png)\n\n\n\nyaml可以直接给我们的实体类赋值\n\n\n\n![1582020841540](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1582020841540.png)\n\n\n\n\n\n\n\n# JSR303验证\n\n需要在类上用上注解	**@Validated**\n\n ![img](https://upload-images.jianshu.io/upload_images/3145530-8ae74d19e6c65b4c?imageMogr2/auto-orient/strip|imageView2/2/format/webp) \n\n\n\n ![img](https://upload-images.jianshu.io/upload_images/3145530-10035c6af8e90a7c?imageMogr2/auto-orient/strip|imageView2/2/format/webp) \n\n\n\n# springboot配置原理\n\nyml配置文件到底能写什么？ 和spring.factories;\n\n在我们这样文件中存在的配置，都固有一个规律，xxxAutoConfiguration 默认值 xxxproperties 和配置文件绑定  我们就可以使用自定义配置。\n\n **@Conditional派生注解** \n\n​	作用： 必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效 \n\n![1584351424362](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1584351424362.png)\n\n\n\n**精髓**：\n\n1、SpringBoot启动会加载大量的自动配置类\n\n2、我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中；\n\n3、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件存在在其中，我们就不需要再手动配置了）\n\n4、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们只需要在配置文件中指定这些属性的值即可；\n\n**xxxxAutoConfigurartion：自动配置类；**给容器中添加组件\n\n**xxxxProperties:封装配置文件中相关属性。**\n\n\n\n**debug=true**：\n\n​		那么多的自动配置类，必须在一定的条件下才能生效；也就是说，我们加载这么多的配置类，但不是所有的都生效了。\n\n​	我们怎么知道那些自动配置类生效？\n\n我们可以通过启用 debug=true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道那些自动类生效了。\n\n​	\n\n\n\n# SpringBootWeb开发\n\n\n\njar：webapp\n\n自动装配\n\nspringboot到底帮我们配置了什么？我们能不能进行修改？能修改那些东西？能不能扩展？\n\n- xxxAutoConfiguraion...向容器中自动配置组件\n- xxxxProperties  :自动配置类，装配配置文件中自定义的一些内容\n\n\n\n要解决的问题：\n\n- 导入静态资源...\n- 首页\n- .jsp,模板引擎Thymeleaf\n- 装配springmvc\n- 增删改查\n- 拦截器\n- 国际化！\n\n\n\n## 静态资源\n\n\n\n什么是webjars？\n\n通过源码总结：\n\n1. 在springboot，我们可以使用以下方式处理静态资源\n\n   ​	。webjars	 `localhost:8080/webjars/`\n\n   ​	。public，static，/**，resource		`localhost：8080/`\n\n2. 优先级：resources--->static:--->public\n\n\n\n\n\n## 模板引擎\n\n结论：只要使用thymeleaf，只需要导入对应的依赖即可使用，添加了依赖我们只需要把我们的html放在templates目录即可\n\n```java\npublic static final String DEFAULT_PREFIX = \"classpath:/templates/\";\npublic static final String DEFAULT_SUFFIX = \".html\";\n```\n\nAPI官网: https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#using-texts \n\nThymeleaf依赖\n\n```xml\n  <dependency>\n            <groupId>org.thymeleaf</groupId>\n            <artifactId>thymeleaf-spring5</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.thymeleaf.extras</groupId>\n            <artifactId>thymeleaf-extras-java8time</artifactId>\n        </dependency>\n```\n\n**yml里面去掉缓存:**\n\n```\nspring.thymeleaf.cache=false\n```\n\n## Mvc配置原理\n\n如果你想diy一些定制化功能，只要写这个组件，然后将他交给springboot，springboot讲会自动帮我们配置。\n\n自定义视图可以实现ViewResolver接口来帮我们实现自定视图\n\n\n\n在springboot中，有非常多的xxx Configuration 帮助我们扩展配置，只要看见这个东西，我们就应该注意了。\n\n\n\n1.首页配置：注意点，所有页面的静态资源都需要Thymeleaf接管；@{}\n\nurl: @{}\n\n2.页面国际化：注意点：\n\n​		1.我们需要配置i18n文件，\n\n​		2.我们如果需要在项目中进行按钮自动切换，我们需要自定义一个组件`LocaleResolver`\n\n​		3.记得将自己写的组件配置到	spring容器`@Bean`\n\n​		4.#{}\n\n3.登录+拦截器\n\n4.员工列表展示\n\n1. 提取公共页面\n   1.  `th:fragment=\"sidrbar\"`\n   2.  `th:replace=\"~{commons/commons::topbar}`\n   3.  如果要传递参数，可以直接使用（）传参，接收判断即可！\n2. ​	列表循环展示\n\n5.添加员工\n\n1. 按钮提交\n2. 跳转到添加页面\n3. 添加成功\n4. 返回首页\n\n6.CRUD\n\n7.404\n\n1. 直接在thymeleaf下建立一个error文件夹，然后把404.html和500.html放进去，它会帮我们自动识别\n\n8.如何写一个网站？\n\n前端：\n\n- 模板\n- 框架\n\n1. 前端搞定：页面长什么样子：数据\n\n2. 数据库设计（数据库设计难点！）\n\n3. 前端让他能够自动运行，独立化工程\n\n4. 数据接口如何对接：json  对象  all in one\n\n5. 前后端联调测试！\n\n6. 有一套自己熟悉的后台模板：工作必要！x-admin\n\n7. 前端页面：至少能够通过前u端框架，组合出来一个网站页面\n\n   ​					— index\n\n   ​					—  about\n\n   ​					—  blog\n\n   ​					— post \n\n   ​					— user\n\n8. 让这个网站运行起来！\n\n9. 一个月！\n\n\n\n## 这周内容\n\n1. JDBC\n2. Mybatis:重点\n3. Druid：重点\n4. Shiro:安全：重点\n5. spring security ：安全：重点\n6. 异步任务 ~，邮件发送，定时任务\n7. Swagger\n8. Dubbo+Zookeeper\n\n\n\n### Data\n\n今天先练习一下昨天讲的Config   Druid\n\n\n\n\n\n\n\n# Mybatis\n\nmybatis-spring-boot-starter\n\n\n\nM：数据和业务\n\nV：交换\n\nC：HTML\n\n1. 导入包\n\n2. 配置文件\n\n3. mybatis配置\n\n4. 编写是sql\n\n5. 业务层调用dao层\n\n6. controller调用service层\n\n   \n\n**@Repository：将mapper整合到spring里面**\n\n\n\n# springSecurity(安全)\n\n在web开发中，安全第一位！过滤器，拦截器~\n\n功能需求：否\n\n做网站：安全应该在什么时候考虑？\n\n- 漏洞：隐私泄露\n- 架构一旦确定~\n\nshiro、springSecurity：很像~除了类不一样，名字不一样\n\n认证、授权(vip1,vip2,vip3)\n\n\n\n- 功能权限\n- 访问权限\n- 菜单权限\n- ....拦截器 ，过滤器：大量的原生代码~繁琐 \n\n\n\nAOP:横切~配置类\n\n\n\n**简介**\n\nSpring Security是针对Spring项目的安全框架，也是SpringBoot底层安全模块的技术选型，他可以实现强大的Web安全控制，对于安全控制，我们仅需要引入 spring-boot-starter-security 模块，进行少量的配置，即可实现强大的安全管理！\n\n记住这几个类：\n\n- WebSecurityConfigureAdapter：自定义Security策略\n- AuthenticationManagerBuilder：自定义认证策略\n- @EnableWebSecurity：开启WebSecurity模式，@Enablexxx开启某个功能\n\nSpring Security的两个主要目标是\"认证\"和\"授权\"(访问控制)。\n\n\"认证\":（Authentication）\n\n\"授权\"（Authorization）\n\n这个概念是通用的，而不是只在Spring Security中存在\n\n**config配置：**\n\n导入依赖：Security   ，thymeleaf-extras-springsecurity4\n\n```java\n@EnableWebSecurity\n//授权\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        super.configure(http);\n    }\n}\n```\n\n\n\n```java\n  //首页所有人都可以访问，功能页只有对应有权限的人可以访问\n        http.authorizeRequests()\n                .antMatchers(\"/\").permitAll()\n                .antMatchers(\"/level1/**\").hasAnyRole(\"vip1\")\n                .antMatchers(\"/level2/**\").hasAnyRole(\"vip2\")\n                .antMatchers(\"/level3/**\").hasAnyRole(\"vip2\");\n        //没有权限默认会到Login页面,需要开启到登录的页面\n        http.formLogin();\n```\n\n设置用户和密码：\n\n```java\n  	//认证  springboot2.1.x 可以直接使用\n	//密码编码：PasswordEncoder\n    //在spring security5.0新增加了很多的加密方法\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        //正常的话这些数据都应该从数据库中读\n        auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())//密码编码，如果不设置可以被反射取出\n                .withUser(\"zhaoguoshun\").password(\"985211\").roles(\"vip2\")\n                .and()\n                .withUser(\"root\").password(\"985211\").roles(\"vip1,vip2,vip3\")\n                .and()\n                .withUser(\"yige\").password(\"985211\").roles(\"vip1\");\n    }\n```\n\n用户注销：\n\n​		在security中设置  http.logout，在前端设置点击注销，路径为logout\n\n记住我功能：\n\n​		http.rememberMe();//开启记住功能\n\ncsrf:\n\n​		http.csrf().disable();//关闭csrf  登录失败可能存在的原因\n\nloginPage(\"\")：自定义去自己的登录页面\n\nloginProcessingUrl(\"\")：提交登录地址  默认name是username 密码是pwd ，如果name和默认的不一样，需要设置 .usernameParameter和 .passwordParameter\n\n\n\n# Shiro\n\n1. 导入依赖\n2. 配置文件\n3. HelloWord\n\n\n\nSpring Security都有~\n\n```\nSubject currentUser = SecurityUtils.getSubject();\nSession session = currentUser.getSession();\ncurrentUser.isAuthenticated()\ncurrentUser.getPrincipal()\ncurrentUser.hasRole(\"schwartz\")\ncurrentUser.isPermitted(\"lightsaber:wield\")\ncurrentUser.logout();\n```\n\n\n\n## SpringBoot中集成\n\n需要编写Config：\n\n- ​	ShiroFilterFactoryBean  3.\n\n- DefaultWebSecurityManager  2.\n\n- 创建 Realm对象   ，可以自定义一个  1.\n\n  ```JAVA\n  @Bean\n      //ShiroFilterFactoryBean\n      public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(\"getDefaultWebSecurityManager\") DefaultWebSecurityManager defaultWebSecurityManager){\n          ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean();\n          //设置安全管理\n  \n          bean.setSecurityManager(defaultWebSecurityManager);\n          return bean;\n      }\n  \n      //DefaultWebSecurityManager\n      @Bean\n      public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(\"userRealm\") UserRealm userRealm){\n          DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\n          //关联UserRealm\n          securityManager.setRealm(userRealm);\n          return securityManager;\n      }\n  \n      @Bean\n      //创建 Realm对象   需要自定义类\n      public UserRealm userRealm(){\n          return  new UserRealm();\n      }\n  ```\n\n  //添加Shirod的内置过滤器\n\n  /** \n\n  ​        *anon:无需认证就可以访问 \n\n  ​        *authc:必须认证了才能访问 \n\n  ​        *user：必须拥有 记住我 功能才能用\n\n  ​        *perms:拥有对某个资源的权限才能访问 \n\n  ​         *role:拥有某个角色权限才能访问 \n\n  */\n\n再config自定义一个Realm对象：\n\n1. 继承 AuthorizingRealm\n\n2. 认证:\n\n   1. 在Controller中写入配置  form中填入login\n\n      ```java\n          @RequestMapping(\"/login\")\n          public String login(String username,String password,Model model){\n              //获取当前用户\n              Subject subject = SecurityUtils.getSubject();\n              //封装用户的登录数据\n              UsernamePasswordToken token = new UsernamePasswordToken(username, password);\n               try{\n                   subject.login(token);//执行登录方法，如果没有异常就说明ok了\n                   return \"index\";\n               }catch (UnknownAccountException e){//用户名异常不存在\n                   model.addAttribute(\"msg\",\"用户名异常\");\n                   return \"login\";\n               }catch (IncorrectCredentialsException e){//密码异常\n                   model.addAttribute(\"msg\",\"密码异常\");\n                   return \"login\";\n              }\n          }\n      ```\n\n3. 配置密码需要再Realm认证中配置数据库密码\n\n   ```java\n   package com.zhaoguoshun.config;\n   \n   import org.apache.shiro.spring.web.ShiroFilterFactoryBean;\n   import org.apache.shiro.web.mgt.DefaultWebSecurityManager;\n   import org.springframework.beans.factory.annotation.Qualifier;\n   import org.springframework.context.annotation.Bean;\n   import org.springframework.context.annotation.Configuration;\n   \n   import java.util.LinkedHashMap;\n   import java.util.Map;\n   \n   @Configuration\n   public class ShiroConfig {\n       @Bean\n       //ShiroFilterFactoryBean\n       public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(\"getDefaultWebSecurityManager\") DefaultWebSecurityManager defaultWebSecurityManager){\n           ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean();\n           //设置安全管理\n           bean.setSecurityManager(defaultWebSecurityManager);\n   \n           //添加Shirod的内置过滤器\n           /**\n            * anon:无需认证就可以访问\n            * authc:必须认证了才能访问\n            * user：必须拥有 记住我 功能才能用\n            * perms:拥有对某个资源的权限才能访问\n            * role:拥有某个角色权限才能访问\n            */\n           //filterMap.put(\"/user/add\",\"authc\");\n           //filterMap.put(\"/user/update\",\"authc\");\n           Map<String, String> filterMap =new LinkedHashMap<>();\n           //授权 ,正常的情况未授权会跳到未授权页面\n           filterMap.put(\"/user/add\",\"perms[user:add]\");\n           filterMap.put(\"/user/update\",\"perms[user:update]\");\n   \n           filterMap.put(\"/user/*\",\"authc\");\n   \n           bean.setLoginUrl(\"/toLogin\");\n           //设置未授权页面\n           bean.setUnauthorizedUrl(\"/noauth\");\n           bean.setFilterChainDefinitionMap(filterMap);\n           return bean;\n       }\n   \n       //DefaultWebSecurityManager\n       @Bean\n       public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(\"userRealm\") UserRealm userRealm){\n           DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\n           //关联UserRealm\n           securityManager.setRealm(userRealm);\n           return securityManager;\n       }\n   \n       @Bean\n       //创建 Realm对象   需要自定义类\n       public UserRealm userRealm(){\n           return  new UserRealm();\n       }\n   }\n   ```\n\n   ## Shiro整合Thymeleaf\n\n   1.导入依赖包：\n\n   ```xml\n   <dependency>\n               <groupId>com.github.theborakompanioni</groupId>\n            <artifactId>thymeleaf-extras-shiro</artifactId>\n               <version>2.0.0</version>\n        </dependency>\n   ```\n\n   2.在Config里面配置ShiroDialect：\n\n   ```java\n   @Bean\n       //ShiroDialect 来整个Shiro 和 Thymeleaf\n       public ShiroDialect getShiroDialect(){\n           return new ShiroDialect();\n       }\n   ```\n\n   3.在html 中导入命名空间\n\n   ```xml\n   xmlns:th=\"http://www.thymeleaf.org\"\n   ```\n\n   \n\n   # 任务\n\n   异步任务~\n\n   使用@Async注解,然后在我们开启类中加上@EnableAsync\n\n   定时任务~\n\n   邮件发送~\n\n   ```\n   host: smtp.qq.com\n    #开启加密验证\n    properties.mail.smtp.ssl.enble: true\n   ```\n\n   简单测试：\n\n   ```java\n    @Test\n       void contextLoads() {\n           //一个简单的邮件\n           SimpleMailMessage mailMessage = new SimpleMailMessage();\n           mailMessage.setSubject(\"赵国顺你好呀\");\n           mailMessage.setText(\"谢谢赵国顺全栈工程师的努力学习\");\n           //1107448323@qq.com\n           mailMessage.setTo(\"2274529540@qq.com\");\n           mailMessage.setFrom(\"2274529540@qq.com\");\n           mailSender.send(mailMessage);\n       }\n   ```\n\n   复杂测试：\n\n   ```java\n   @Test\n       void contextLoads2() throws MessagingException {\n           //一个复杂的邮件\n           MimeMessage mimeMailMessage=mailSender.createMimeMessage();\n           //组装\n           MimeMessageHelper helper=new MimeMessageHelper(mimeMailMessage,true);\n           //附件\n           helper.setSubject(\"赵国顺你好呀\");\n           helper.setText(\"<p style=\'color:red\'>谢谢赵国顺全栈工程师的努力学习</p>\",true);\n           helper.addAttachment(\"1.jpg\",new File(\"D:\\\\a\\\\1.jpg\"));\n           helper.addAttachment(\"2.jpg\",new File(\"D:\\\\a\\\\1.jpg\"));\n           helper.setTo(\"2274529540@qq.com\");\n           helper.setFrom(\"2274529540@qq.com\");\n           mailSender.send(mimeMailMessage);\n       }\n   ```\n\n   \n\n   \n\n   yml配置信息\n\n   ```yml\n   spring:\n     mail:\n       username: 2274529540@qq.com\n       password: eduntyolanzadieb\n       host: smtp.qq.com\n       #开启加密验证\n       properties.mail.smtp.ssl.enble: true\n   \n   ```\n\n   \n\n   ​		\n\n   ```\n   TaskScheduler	任务调度者\n   TaskExecutor	任务执行者\n   \n   @EnableScheduling //开启定时功能的注解\n   @Scheduled //什么时候执行\n   \n   cron 表达式\n   ```\n\n   \n\n   \n\n   ## 小结知识点\n\n   \n\n   使用jpa可以在实体类（pojo）中快速生成数据库表结构。\n\n   1.导入依赖：\n\n   ```xml\n    <dependency>\n               <groupId>org.springframework.boot</groupId>\n               <artifactId>spring-boot-starter-data-jpa</artifactId>\n               <version>2.2.4.RELEASE</version>\n           </dependency>\n   \n   \n   可以在yml里这样配置：\n   jpa:\n       hibernate:\n         ddl-auto: update\n       show-sql: true\n   ```\n\n   \n\n   2.在实体类上加上 ：@Entity，和Table(\"表的名字\")。\n\n   3.需要指定id，在id上面加上:@Id，和@GeneratedValue注解。\n\n   \n\n   4.如果是Date，需要在变量上面加上：@Temporal(TemporalType.TIMESTAMP)\n\n   注意：实体类会报错，是因为idea没有检测出来，直接运行就会生成表，并不影响其他。\n\n   \n\n   \n\n   \n\n   \n\n   \n\n   \n\n   \n\n   \n\n   \n\n   \n\n   \n\n   \n\n   ​		', NULL, 0, 0, 0, NULL, '2021-01-01', 353, '2021-01-01', 7);
INSERT INTO `tb_article` VALUES (64, 41, 'Linux', 'http://39.106.163.62:8081/cms/upload/6f4e01d7-0922-46e8-9eaf-eb9debbc2c4f.jpg', '\\  Vue    HTML CSS JS  视图   给用户看 刷新后台的数据     网络通信 axios    页面跳转 vue-router    状态管理 vuex    MVVM model-view-view-model     HTML先加载js     \\   xml    \\                v-bind   \"\"        \\   v-if v-else  ', '', '\\# Vue\n\n\n\nHTML+CSS+JS :视图: `给用户看，刷新后台的数据`\n\n\n\n网络通信：axios\n\n\n\n页面跳转：vue-router\n\n\n\n状态管理：vuex\n\n\n\nMVVM(model-view-view-model)\n\n\n\nHTML先加载js：\n\n\n\n\\```xml\n\n<script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js\"></script>\n\n\\```\n\n\n\n{{}}\n\n\n\n v-bind: =\"\"\n\n\n\n\n\n\n\n\\## v-if v-else\n\n\n\n判断if  属性 v-if\n\n\n\n循环for v-for\n\n\n\n\\```html\n\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\n\n\n​    \"http://www.w3.org/TR/html4/loose.dtd\">\n\n<html>\n\n<head>\n\n\n  <title>Title</title>\n\n</head>\n\n<body>\n\n<div id=\"app\">\n\n\n\n\n  <h1 v-if=\"type===\'A\'\">A</h1>\n  <h1 v-else-if=\"type===\'B\'\">B</h1>\n  <h1 v-else-if=\"type===\'C\'\">C</h1>\n  <h1 v-else>No</h1>\n\n</div>\n\n\n\n<!--导入vue.js-->\n\n<script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js\"></script>\n<script>\n\n\n\n\n  var vue=new Vue({\n\n​    el: \"#app\",\n\n​    data : {\n\n​      type: \"A\"\n\n​    }\n\n  });\n\n</script>\n\n</body>\n\n</html>\n\n\\```\n\n\n\n\n\n\n\n\\# v-for\n\n\n\n\\```html\n\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\n\n\n​    \"http://www.w3.org/TR/html4/loose.dtd\">\n\n<html>\n\n<head>\n\n\n    <meta charset=\"UTF-8\">\n\n\n  <title>Title</title>\n\n</head>\n\n<body>\n\n\n\n<div id=\"app\">\n\n\n\n\n\n\n  <li v-for=\" item in items\">\n\n​    {{item.message}}\n\n  </li>\n\n</div>\n\n\n\n<!--导入vue.js-->\n\n<script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js\"></script>\n<script>\n\n\n\n\n  var vue=new Vue({\n\n​    el: \"#app\",\n\n​    data:{\n\n​      items: [\n\n​        {message : \'Java\'},\n\n​        {message : \'Vue\'},\n\n​        {message : \'运维\'},\n\n​        {message : \'赵国顺\'}\n\n​      ]\n\n​    }\n\n  });\n\n</script>\n\n</body>\n\n</html>\n\n\\```\n\n\n\n\n\n\n\n\n\n\n\n\\## 事件: on\n\n\n\n 可以用 `v-on` 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。 v\n\n\n\n\\```HTML\n\n<!DOCTYPE html>\n\n\n<html lang=\"en\" xmlns:v-on=\"http://www.w3.org/1999/xhtml\">\n\n<head>\n\n\n    <meta charset=\"UTF-8\">\n\n\n  <title>事件</title>\n\n</head>\n\n<body>\n\n\n\n<div id=\"app\">\n\n\n\n\n  <button v-on:click=\"sayHi\">click me</button>\n\n</div>\n\n\n\n<!--导入vue.js-->\n\n<script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js\"></script>\n<script>\n\n\n\n\n  var vue=new Vue({\n\n​    el: \"#app\",\n\n​    data: {\n\n​      message: \"顺总学Java\"\n\n​    },\n\n​    methods :{//方法必须定义在vue的method对象中\n\n​      sayHi: function () {\n\n​        alert(this.message);\n\n​      }\n\n​    }\n\n  });\n\n</script>\n\n</body>\n\n</html>\n\n\\```\n\n\n\n**网络通信**\n\n- JQuery.ajax\n\n## 什么是Axios?\n\nAxios是一个·开源的可以在浏览器端和`Nodejs`的异步通讯框架，它的主要作用就是实现AJAX异步通信,其功能特点如下：\n\n- 从浏览器创建XMLHttpRequests\n- 从 node.js 创建 [http](http://nodejs.org/api/http.html) 请求\n- 支持 [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) API\n- 拦截请求和响应\n- 转换请求数据和响应数据\n- 取消请求\n- 自动转换 JSON 数据\n- 客户端支持防御 [XSRF](http://en.wikipedia.org/wiki/Cross-site_request_forgery)\n\n\n\n## Vue生命周期\n\nVue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染->更新->渲染 卸载等一系列过程，我们称这是Vue的生命周期。\n\n\n\n\n\n\n\n## Vue计算属性、内容分发、自定义事件\n\n### 什么是计算属性？\n\n计算属性：计算出来的结果保存在属性中~，内存中运行：虚拟dom\n\n计算属性的特点突出在`属性`两个字上（属性是个名词），首先它必须是个`属性`其次这个属性有`计算`功能(计算是动词) 这里的计算是个函数；**简单点说它就是一个能将计算结果缓存存储起来的属性**（将行为转换为静态的属性）。仅此而已可以想象为缓存\n\n\n\n````html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>计算属性</title>\n</head>\n<body>\n<div id=\"app\">\n\n    <p>currentTime1:{{currentTime1()}}</p>\n    <p>currentTime2{{currentTime2}}</p>\n</div>\n\n<!--导入vue.js-->\n<script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js\"></script>\n\n<script>\n\n\n    var vue =new Vue({\n        el: \"#app\",\n      data: {\n            message : \"hello,Java\"\n      },\n      methods :{\n        currentTime1: function () {\n            return Date.now();//返回一个时间戳\n        }\n      },\n        computed:{//计算属性  methods和computed方法名不能重名，重名之后只会调用methods方法中的\n            currentTime2: function () {\n                this.message;\n                return Date.now();//返回一个时间戳\n            }\n        }\n    })\n</script>\n</body>\n</html>\n````\n\n**说明**：\n\n- methods:定义方法，调用方法使用currentTime1（）需要带括号\n\n- computed：定义计算属性，调用currentTime2,不需要带括号；this.message是为了能让currentTime2观察到数据变化而变化。\n- 如果在方法中的值发生了变化，则缓存就会刷新，可以在控制台使用`vue.message=\"hello,Java\"`，改变下数据的值。再次测试观察效果\n\n**结论**：\n\n​		调用方法时每次都需要进行进行计算，既然有计算过程必然产生系统开销，那如果这个结果是不经常变化的呢？此时我们可以考虑将这个结果存储起来，采用计算属性可以很方便的做到这一点，**计算属性的主要特征就是为了将不经常变化的计算结果进行缓存，以节约我们的系统开销。**\n\n\n\n### 内容分发（重要)\n\n在Vue.js中我们使用<slot>元素作为承载分发内容的出口作者其成为‘插槽’，可以应用在组合组件的场景中\n\n插槽\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>组件</title>\n</head>\n<body>\n<div id=\"app\">\n    <todo-title slot=\"todo-title\" :title=\"title\">{}</todo-title>\n    <todo-items slot=\"todo-items\" v-for=\"item in TodoItems\" :item=\"item\"></todo-items>\n</div>\n\n<!--导入vue.js-->\n<script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js\"></script>\n\n<script>\n\n    Vue.component(\"todo\",{\n        template: \'<div>\\\n        <slot name=\"todo-title\"></slot>\\\n            <ui>\\\n                <slot name=\"todo-items\"></slot>\\\n            </ui>\\\n        </div>\'\n    });\n\n    Vue.component(\"todo-title\",{\n        props: [\'title\'],\n        template: \'<div>{{title}}</div>\'\n    });\n    Vue.component(\"todo-items\",{\n        props: [\'item\'],\n        template: \'<li>{{item}}</li>\'\n    });\n\n\n\n    var vue =new Vue({\n        el: \"#app\",\n        data: {\n            title: \"赵国顺学习\",\n            TodoItems: [\"Java\",\"Vue\",\"前端\"]\n        }\n    })\n</script>\n</body>\n</html>·\n```\n\n### 自定义事件（*）\n\n组件内部绑定事件需要用到`this$emit(\'事件名\'，参数)`\n\n通过以上代码不难发现，数据项在Vu实例中，\n\n但删除操作要在组件中完成，那组件如何才能删除Vue实例中的数据呢？此时就设计到参数传递和事件分发了，Vue为我们提供了自定义的功能很好的帮助了我们解决了这个问题；使用this.$emit(\'自定义事件·名\'，参数)，操作过程如下：\n\n1-在Vue实例中，增加了methods对象并义了一个为removeItems的方法```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>自定义事件内容分发</title>\n</head>\n<body>\n<div id=\"app\">\n    <todo-title slot=\"todo-title\" :title=\"title\"></todo-title>\n    <todo-items slot=\"todo-items\" v-for=\"(item,index) in TodoItems\"\n                :item=\"item\" v-bind:index=\"index\" v-on:remove=\"removeItems(index)\"></todo-items>\n</div>\n\n<!--导入vue.js-->\n<script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js\"></script>\n\n<script>\n\n    Vue.component(\"todo\",{\n        template: \'<div>\\\n        <slot name=\"todo-title\"></slot>\\\n            <ui>\\\n                <slot name=\"todo-items\"></slot>\\\n            </ui>\\\n        </div>\'\n    });\n\n    Vue.component(\"todo-title\",{\n        props: [\'title\'],\n        template: \'<div>{{title}}</div>\'\n    });\n    Vue.component(\"todo-items\",{\n        props: [\'item\',\'index\'],\n        //只能绑定当组件的方法\n        template: \'<li>{{index}}----{{item}}<button @click=\"remove\">删除</button></li>\',\n\n        methods:{\n            remove: function (index) {\n                this.$emit(\'remove\',index)\n            }\n        }\n    });\n\n\n\n    var vue =new Vue({\n        el: \"#app\",\n        data: {\n            title: \"赵国顺学习\",\n            TodoItems: [\"Java\",\"Vue\",\"前端\"]\n        },\n\n        methods: {\n            removeItems: function (ins) {\n                console.log(\"删除了\"+this.TodoItems[ins]+\"ok\");\n                this.TodoItems.splice(ins,1);//一次删除一个元素\n            }\n        }\n    })\n</script>\n</body>\n</html>\n```\n\n\n\n### 说明\n\nVue的开发都是基NodeJs,实际开发始于vue-cli脚手架开发，vue-router路由，vuex做状态管；Vue-UI.界面我们一使用ElementUI(饿了么出品)，或者ICE(阿里巴巴)快速搭建前端项目\n\n\n\n## Vue：第一个Vue-cli项目\n\n\n\n### 什么是Vue-cli？\n\nvue-cli是官方官方提供的一个脚手架，用于快速生成一个vue的项目模板。\n\n预先定义好的目录结构及基础代码，就好比创建Maven项目时，可以选择创建一个骨架项目，这个骨架项目就是脚手架，使我们开发更加的迅速。\n\n\n\n**主要功能**\n\n- 统一的目录结构\n- 本地调试\n- 热部署\n- 单元测试\n- 集成打包上线\n\n### 需要环境\n\nnodejs: http://nodejs.cn/download/ \n\n**确认nodejs安装成功**\n\n- cmd下输入`node -v` 查看能否正确打印出版本号即可\n- cmd下输入`npm -v` 查看能否正确打印出版本号即可\n\n**安装node.js淘宝镜像加速器（cnpm）**\n\n这样的话，下载会快很多\n\n```\n# -g就是全局安装\nnpm install cnpm -g\n\n#使用如下语句解决，npm速度慢问题\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n\n```\n\n![1598694072561](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1598694072561.png)\n\n### 安装vue-cli\n\n```\ncnpm install vue-cli -g\n\n#测试是否安装成功\n#查看可以基于那些模板创建vue应用程序，通常我们选择webpack\nvue list\n```\n\n\n\n创建vue目录\n\nvue init webpack myvue\n\n![1598695123711](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1598695123711.png)\n\n### **初始化并运行**\n\n```\ncd myvue\n#导入所有依赖\nnpm install\n启动vue\n#npm run dev\n停止 Ctrl+c\n```\n\n\n\n## webPack\n\n### 什么是WebPack?\n\n本质上，webpack是一个现代JavaScript应用程序的静态模块打包器(module bundler)。当webpack处理应用程序时，他会\n\n递归地构建一个依赖关系图，其中包含应应程序需要的每个模块，然后讲所有这些模块打包成一个huo多个bundle.\n\n\n``` \nimport \"jquery\";导入\nexport  function doStuff(){}导出\nmodule \"localModule\"{} \n```\n\n\n\n\n\n### 安装Webpack\n\nwebPack是一款模块加载器兼打包工具，他能把各种资源，如JS、JSX、ES6、SASS、Less、图片等都作为模块来处理1和使用。\n\n\n\n**安装**：\n\n```nodejs\nnpm install webpack -g\nnpm install webpack-cli -g\n```\n\n测试安装成功：\n\n- webpack -v\n- webpack-cli -v\n- ![1599463449212](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1599463449212.png)\n\n### 配置\n\n创建`webpack.config.js`配置文件\n\n- ​	entry：入口文件，指定WebPack用那个文件作为项目的入口\n- output：输出，指定WebPack把处理完后的文件放置到指定路径\n- module：模块，用于处理各种类型的文件\n- plugins：插件，如：热更新、代码重用等\n- resolve：设置路径指向\n- watch：监听，用于设置文件改动后直接打包\n\n\n\n### 使用Webpack\n\n1. 创建项目\n2. 创建一个名为modules的目录，用于放置JS模块等资源文件\n3. 在modules下创建模块文件，如hello.js，用于编写JS模块相关代码\n\n\n\n\n\n## Vue vue-router路由\n\n### vue-router是什么?\n\n这里的路由并不是指我们平时所说的硬件路由器，**这里的路由就是SPA（单页应用）的路径管理器**。再通俗的说，vue-router就是WebApp的链接路径管理系统。\n vue-router是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。vue的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。传统的页面应用，是用一些超链接来实现页面切换和跳转的。在vue-router单页面应用中，则是路径之间的切换，也就是组件的切换。**路由模块的本质 就是建立起url和页面之间的映射关系**。\n\n\n\n### vue-router实现原理\n\nSPA(single page application):单一页面应用程序，只有一个完整的页面；它在加载页面时，不会加载整个页面，而是只更新某个指定的容器中内容。**单页面应用(SPA)的核心之一是: 更新视图而不重新请求页面**;vue-router在实现单页面前端路由时，提供了两种方式：Hash模式和History模式；根据mode参数来决定采用哪一种方式。\n\n\n\n### 1、Hash模式：\n\n**vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。** hash（#）是URL 的锚点，代表的是网页中的一个位置，单单改变#后的部分，浏览器只会滚动到相应位置，不会重新加载网页，也就是说**hash 出现在 URL 中，但不会被包含在 http 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面**；同时每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置；所以说**Hash模式通过锚点值的改变，根据不同的值，渲染指定DOM位置的不同数据。hash 模式的原理是 onhashchange 事件(监测hash值变化)，可以在 window 对象上监听这个事件**。\n\n\n\n\n\n### 2、History模式：\n\n\n\n由于hash模式会在url中自带#，如果不想要很丑的 hash，我们可以用路由的 history 模式，只需要在配置路由规则时，加入\"mode: \'history\'\",**这种模式充分利用了html5 history interface 中新增的 pushState() 和 replaceState() 方法。这两个方法应用于浏览器记录栈，在当前已有的 back、forward、go 基础之上，它们提供了对历史记录修改的功能。只是当它们执行修改时，虽然改变了当前的 URL ，但浏览器不会立即向后端发送请求**。\n\n  ![1599481868239](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1599481868239.png)\n\n\n\nVue-router是Vue.js官方的路由管理器。它和vue.js的核心深度集成，让构建单页面应用变得易如反掌。包括功能有：\n\n- 嵌套的路由/视图表\n- 模块化的、基于组件的路由配置\n- 路由参数、查询、通配符\n- 等\n\n\n\n\n\n\n\n\n\n### 安装\n\n基于第一个`vue-cli`进行测试学习；先查看node_modules中是否存在 vue-router\n\nvue-router是一个插件包，所以我们还需要npm/cnpm来进行安装的。打开命令行工具，进入到你都项目目录，输入以下命令\n\n```nodejs\nnpm install vue-router --save-dev\n```\n\n\n\n如果在一个模块化工程中使用它，必须要通过vue.use()明确地安装路由功能\n\n\n\n\n\n## Vue+ElementUI\n\n\n\n我们采用实战教学模式并结合`ElementUi`组件库，将所需要知识点应用到实际中，最快速度掌握Vue\n\n\n\n### 创建工程\n\n注意：命令行都要使用管理员模式\n\n\n\n1. 创建一个Hello-vue的工程`vue init webpack hello-vue`\n2. 安装依赖，我们需要安装vue-router 、element-ui、sass-loader喝node-sass四个插件\n\n```vue\n#进入目录工程\ncd hello-vue\n#安装vue-router\nnpm install vue-router --save-dev\n#安装elementUI\nnpm i element-ui -S\n#安装依赖\nnpm install\n#安装Sass加载器\ncnpm install sass-loader node-sass --save-dev\n#启动测试\nnpm run dev\n```\n\n\n\nmain.js引入element-ui\n\n```vue\nimport ElementUI from \'element-ui\';\nimport \'element-ui/lib/theme-chalk/index.css\';\n\n\nnew Vue({\n  el: \'#app\',\n  render: h => h(App)\n});\n```\n\n\n\n\n\n创建一个router文件,router下创建index.js\n\n```Vue\nimport  Vue from \'vue\'\nimport Router from \'vue-router\'\nimport Main from \'../views/Main\'\nimport login from \'../views/Login\'\n\nVue.use(Router);\n\n\nexport default new Router({\n  routes: [\n    {\n      path: \'/main\',\n      component: Main\n    },{\n        path: \'/login\',\n        component: login\n    }\n  ]\n})\n\n```\n\n\n\n定义的login页面\n\n```vue\n<template>\n\n  <el-form :model=\"ruleForm\" status-icon :rules=\"rules\" ref=\"ruleForm\" label-width=\"100px\" class=\"demo-ruleForm\">\n    <el-form-item label=\"密码\" prop=\"pass\">\n      <el-input type=\"password\" v-model=\"ruleForm.pass\" autocomplete=\"off\"></el-input>\n    </el-form-item>\n    <el-form-item label=\"确认密码\" prop=\"checkPass\">\n      <el-input type=\"password\" v-model=\"ruleForm.checkPass\" autocomplete=\"off\"></el-input>\n    </el-form-item>\n\n    <el-form-item>\n      <el-button type=\"primary\" @click=\"submitForm(\'ruleForm\')\">提交</el-button>\n      <el-button @click=\"resetForm(\'ruleForm\')\">重置</el-button>\n    </el-form-item>\n  </el-form>\n</template>\n<script>\n  export default {\n    data() {\n      var checkAge = (rule, value, callback) => {\n        if (!value) {\n          return callback(new Error(\'年龄不能为空\'));\n        }\n        setTimeout(() => {\n          if (!Number.isInteger(value)) {\n            callback(new Error(\'请输入数字值\'));\n          } else {\n            if (value < 18) {\n              callback(new Error(\'必须年满18岁\'));\n            } else {\n              callback();\n            }\n          }\n        }, 1000);\n      };\n      var validatePass = (rule, value, callback) => {\n        if (value === \'\') {\n          callback(new Error(\'请输入密码\'));\n        } else {\n          if (this.ruleForm.checkPass !== \'\') {\n            this.$refs.ruleForm.validateField(\'checkPass\');\n          }\n          callback();\n        }\n      };\n      var validatePass2 = (rule, value, callback) => {\n        if (value === \'\') {\n          callback(new Error(\'请再次输入密码\'));\n        } else if (value !== this.ruleForm.pass) {\n          callback(new Error(\'两次输入密码不一致!\'));\n        } else {\n          callback();\n        }\n      };\n      return {\n        ruleForm: {\n          pass: \'\',\n          checkPass: \'\',\n          age: \'\'\n        },\n        rules: {\n          pass: [\n            { validator: validatePass, trigger: \'blur\' }\n          ],\n          checkPass: [\n            { validator: validatePass2, trigger: \'blur\' }\n          ],\n          age: [\n            { validator: checkAge, trigger: \'blur\' }\n          ]\n        }\n      };\n    },\n    methods: {\n      submitForm(formName) {\n        this.$refs[formName].validate((valid) => {\n          if (valid) {\n            alert(\'submit!\');\n          } else {\n            console.log(\'error submit!!\');\n            return false;\n          }\n        });\n      },\n      resetForm(formName) {\n        this.$refs[formName].resetFields();\n      }\n    }\n  }\n</script>\n\n```\n\n\n\nmain.js下\n\n```Vue\nimport Vue from \'vue\'\nimport App from \'./App\'\nimport router from \'./router\'\nimport ElementUI from \'element-ui\';\nimport \'element-ui/lib/theme-chalk/index.css\';//不导入样式不会加载\n\nVue.use(ElementUI)\n\n/* eslint-disable no-new */\nnew Vue({\n  el: \'#app\',\n  router,\n  render: h => h(App)\n});\n\n```\n\n\n\n\n\napp.vue\n\n```vue\n<template>\n  <div id=\"app\">\n    <router-link to=\"/login\">login</router-link>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\n\nexport default {\n  name: \'App\',\n\n}\n</script>\n\n```\n\n\n\n嵌套路由：\n\n在router js 中的路径中用children\n\n```vue\nexport default new Router({\n  routes: [\n    {\n      path: \'/main\',\n\n      component: Main,\n\n      //嵌套路由\n      children: [\n        {path: \'/user/profile\',\n          name: UserProfile,\n          component: UserProfile, props: true},\n        {path: \'/user/list\',component: UserList}\n      ]\n    },{\n        path: \'/login\',\n        component: login\n    },\n    {\n      path: \'/goHome\',\n      redirect:\'/main\'\n    }\n  ]\n})\n```\n\n\n\n\n\n## 路由传递参数\n\n### 第一种:\n\n1. 路由传递参数方式，在路由中使用name传递，参数使用params方式\n\n```vue\n<template>\n\n  <ui>\n    <li><router-link :to=\"{name:\'UserProfile\',params:{id: 1}}\">个人信息</router-link></li>\n    <li><router-link :to=\"{name:\'UserList\',params:{id: 5}}\">所有用户</router-link></li>\n    <router-view></router-view>\n  </ui>\n\n</template>\n\n```\n\n\n\n2.而router js中的path路径就要改为加/：参数名称\n\n```vue\nchildren:[\n        {\n          path:\'/user/list/:id\',\n          name: \'UserList\',\n          component: UserList\n        },{\n        path: \'/user/profile/:id\',\n          name: \'UserProfile\',\n          component:  UserProfile\n        }\n      ]\n```\n\n3.去出参数可以使用{{$route.params.参数名}}\n\n```vue\n<template>\n  <div>\n    <h1>个人信息</h1>\n    {{this.$route.params.id}}\n  </div>\n</template>\n\n<script>\n    export default {\n        name: \"UserProfile\"\n    }\n</script>\n\n<style scoped>\n\n</style>\n\n```\n\n\n\n### 第二种：通过**props**解耦\n\n\n\n1. 直接在router js  routes种加入props：true\n\n```vue\nroutes:[\n      children:[\n        {\n          path:\'/user/list/:id\',\n          name: \'UserList\',\n          component: UserList,\n          props:true\n        },{\n       \n      ]\n```\n\n2.路由传递的参数不变\n\n```vue\n<template>\n\n  <ui>\n    <li><router-link :to=\"{name:\'UserProfile\',params:{id: 1}}\">个人信息</router-link></li>\n    <li><router-link :to=\"{name:\'UserList\',params:{id: 5}}\">所有用户</router-link></li>\n    <router-view></router-view>\n  </ui>\n\n</template>\n```\n\n\n\n3.接收的参数，用props组件接收，不需要在{{$route.params.参数名称}}了\n\nprops[]种一定要用\'\'\n\n```vue\n<template>\n  <div>\n    <h1>用户信息</h1>\n    {{id}}\n  </div>\n\n\n</template>\n\n<script>\n    export default {\n      props:[\'id\'],\n        name: \"UserList\"\n    }\n</script>\n\n<style scoped>\n\n</style>\n\n```\n\n\n\n\n\n路由模式有两种，上面说过了\n\nhash:路径带#符号，如 http://localhost:8080/#/login \n\nhistory：路径不带\n\n```vue\nexport default new Router({\n  mode:\'history\',\n    routes:[\n    ]\n```\n\n\n\n## 路由钩子与异步请求\n\nbeforeRouteEnter:在进入路由前执行\n\nbeforeRouteLeave:在离开路由前执行\n\n\n\n他们都有三个参数   to,from,next\n\nbeforeRouteEnter:(to,from,next)=>{\n\n}\n\n参数说明：\n\n- to:路由将要跳转的路径信息\n- from:路径跳转前的路径信息\n- next :路由的控制参数\n  - next()：跳入下一个页面\n  - next(\'/path\'):改变路由的跳转方向，使其跳转到另一个方向\n  - next（Flase）：返回到原来页面\n  - next((vm)=>{})：仅在BeforeRouteEnter中可以，vm是组件\n\n\n\n### 安装axios\n\n```\ncnpm install axios -s\n#cnpm 有可能安装失败，多安装几次\n```\n\n```\n<template>\n  <div>\n    <h1>个人信息</h1>\n   {{id}}\n  </div>\n</template>\n\n<script>\n    export default {\n      props:[\'id\'],\n        name: \"UserProfile\",\n      //过滤器一样\n      beforeRouteEnter: (to,from,next)=>{\n        console.log(\"进入路由之前\");\n        next(vm=>{\n          vm.getData();\n        });\n    },\n      beforeRouteLeave: (to,from,next)=>{\n        console.log(\"进入路由之后\");\n        next();\n      },\n      methods:{\n        getData: function () {\n          this.axios({\n            method: \'get\',\n            url: \'http://localhost:8080/static/mock/data.json\',\n\n          }).then(function (response) {\n            console.log(response)\n          })\n        }\n      }\n\n    }\n</script>\n\n<style scoped>\n\n</style>\n\n```\n\n\n\n\n\n', NULL, 0, 0, 0, NULL, '2021-01-01', 353, '2021-01-01', 10);
INSERT INTO `tb_article` VALUES (65, 35, 'SpringCloud', 'http://39.106.163.62:8081/cms/upload/c7eda07c-4d94-4735-90f7-8cf860f89f0a.png', '微服务4个核心问题  1  服务很多 客户端怎么访问 2  这么多服务 服务之间如何同信 3  这么多服务 如何治理 4  服务挂了怎么办    解决方案 SpringCloud 生态      1 springcloud netfilx 一站式解决 2 Dubbo zookeeper 半自动需要整合别人的 3 SpringCloud Alibaba   万变不离其宗 	1 API 	2 HTTP', '', '\n\n\n\n微服务4个核心问题\n\n1. 服务很多，客户端怎么访问\n2. 这么多服务，服务之间如何同信\n3. 这么多服务，如何治理\n4. 服务挂了怎么办\n\n\n\n解决方案：SpringCloud 生态\n\n```\n1.springcloud netfilx 一站式解决\n2.Dubbo zookeeper 半自动需要整合别人的\n3.SpringCloud Alibaba \n\n万变不离其宗\n	1.API\n	2.HTTP\n	3.注册和发现\n	4.熔断机制\n\n\n```\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1602315959217.png\" alt=\"1602315959217\" style=\"zoom: 50%;\" />\n\n\n\n## 微服务概述\n\n- 就目前而言，对于微服务，业界并没有一个统一的标准的定义\n- 但通常而言微服务架构是一种架构模式，或一种架构风格，**它提倡将单一的应用程序划分成一组小的服务**。\n- **微服务的核心就是将传统的一站式应用，根据业务拆分成一个个的服务，彻底的去耦合。**\n\n\n\n### 微服务与微服务架构\n\n\n\n**微服务**\n\n​	强调的是服务的大小，他关注的是某一个点，是具体解决某一个问题/提供落地对应服务的一个服务应用。\n\n\n\n**微服务架构**\n\n​	一种新的架构形式，Martin Flower 2014年提出\n\n\n\n\n\n### 微服务优点和缺点\n\n**优点**\n\n- 单一职责原则\n\n- 每个服务足够内聚足够小，代码容易理解，这样能聚焦一个指定的业务功能或业务需求\n- 开发简单，开发效率提高，一个服务可以就转一的干一件事\n- 微服务能被小团队单独开发，这个小团队可以是2~5人的开发人员组成\n- 微服务是松耦合的，是有功能意义的服务，无论是在开发阶段还是部署阶段都是独立的\n- 微服务能使用不同的语言开发\n- 易与和第三方集成，微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如：jenkins、Hudson、bamboo\n- 微服务易与被一个开哈人员理解，维修和维护，这样小团队能够更关注自己的工作成果。\n- **微服务只是业务逻辑代码，不会和HTML、CSS或其它界面混合**\n- **每个微服务都有自己的存储能力，可以有自己的数据库，也可以有统一的数据库**\n\n**缺点**\n\n- 开发人员要处理分布式系统的复杂性\n\n- 多服务运维难度，随着服务的增加，运维的压力也在增大\n\n- 系统部署依赖\n\n- 服务器间通信成本\n\n- 数据一致性\n\n- 系统集成测试\n\n- 性能监控...\n\n  \n\n  ## 微服务技术栈有哪些\n\n  ​	\n\n  | 微服务条目                               |                                                             |\n  | :--------------------------------------- | :---------------------------------------------------------- |\n  | 服务开发                                 | springboot，spring，springMvc                               |\n  | 服务配置与管理                           | NetFix公司的 Archaius、阿里的Diamond等                      |\n  | 服务注册与发现                           | Eureke 、Consul、zeekeeper                                  |\n  | 服务调用                                 | Rest、RPC、gRPC                                             |\n  | 服务熔断器                               | Hystrix、Envoy等                                            |\n  | 负载均衡                                 | Ribbon、Nginx等                                             |\n  | 服务接口调用（客户端调用服务的简化工具） | Feign等                                                     |\n  | 消息队列                                 | kafka、RabbitMQ、ActiveMQ等                                 |\n  | 服务配置中心管理                         | SpringCloudConfig、Chef等                                   |\n  | 服务路由（API网关）                      | zuul等                                                      |\n  | 服务监控                                 | Zabbix、Nagios、Metrics、Specatator                         |\n  | 全链路追踪                               | Zipkin、Brave、Dapper等                                     |\n  | 服务部署                                 | Docker、OpenStack、Kubernetes等                             |\n  | 数据流操作开发包                         | SpringCloud Stream(封装与Redis,Rabbit、Kafka等发送接收信息) |\n  | 事件消息总线                             | springCloud Bus                                             |\n\n\n\n### 什么是SpringCloud\n\nSpringCloud ，基于SpringBoot提供了一套微服务解决方案，包括服务注册与发现，配置中心，全链路监控，服务网页，负载均衡熔断器等组件。\n\n\n\n\n\n### SpringCloud和SpringBoot关系\n\n1. SpringBoot专注于快速方便的开发单个个体微服务\n2. SpringCloud是关注与全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来。\n3. SpringBoot可以离开SpringCloud单独使用，但是SpringCloud离不开SpringBoot\n4. **SpringBoot专注于快速、方便的开发单个个体微服务，SpringCloud关注与全局的服务治理框架**\n\n\n\nDubbo和SpringCloud技术选型\n\n1. .分布式+服务治理Dubbo**\n\n   1. 目前成熟的互联网架构：应用服务化拆分+消息中间件\n\n![Description](https://static01.imgkr.com/temp/6838d5d02d434100b93f6a267514a4b8.png)\n\n   \n\n   \n\n2. Dubbo和SpringCloud对比\n\n  ![Description](https://static01.imgkr.com/temp/104692f0e8154d2cbf4c90596b4798fe.png)\n   最大区别：SpringCloud抛弃了Dubbo的RPC通信，采用基于HTTP的REST风格‘\n\n   严格来说，这两种方式各有优劣。虽然后者牺牲了服务调用的性能，但也避免上面提到了的原生RPC带来的问题。而却REST相比RPC更加灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这在调用快速演化的微服务下，更加适合。\n\n   \n\n   中文文档https://www.springcloud.cc/\n\n   中国社区http://www.springcloud.cn/\n\n\n\n\n链式写法：\n\n```java\n@Accessors(chain = true)//开启链式写法\n\n /*\n    链式写法：\n       Dept dept= new Dept();\n       dept.setDname().setDsource();\n     */\n```\n\n\n\n\n\n## 服务提供者和消费者\n\n目录：\n\n![Description](https://static01.imgkr.com/temp/859cca5148c04ea3ac8450e4dd67ee9e.png)\n\n1. 先创建一个父maven项目，再父工程引入一些依赖。再properties中写好版本号\n\n   1. \n\n   ```xml\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n       <modelVersion>4.0.0</modelVersion>\n   \n       <groupId>com.zhaoguoshun</groupId>\n       <artifactId>springcloud</artifactId>\n       <version>1.0-SNAPSHOT</version>\n       <modules>\n           <module>springclou-api</module>\n           <module>springcloud-provider-dept-8001</module>\n           <module>springcloud-consumer-dept-80</module>\n       </modules>\n   \n       <!--    打包方式-->\n       <packaging>pom</packaging>\n   \n       <properties>\n           <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n           <maven.compiler.source>1.8</maven.compiler.source>\n           <maven.compiler.target>1.8</maven.compiler.target>\n           <juit.version>4.12</juit.version>\n           <lombok.version>1.18.10</lombok.version>\n           <log4j.version>1.2.17</log4j.version>\n   \n       </properties>\n   \n   \n       <dependencyManagement>\n           <dependencies>\n               <dependency>\n                   <groupId>org.springframework.cloud</groupId>\n                   <artifactId>spring-cloud-dependencies</artifactId>\n                   <version>Hoxton.SR8</version>\n                   <type>pom</type>\n                   <scope>import</scope>\n               </dependency>\n               <!--SpringBoot -->\n               <dependency>\n                   <groupId>org.springframework.boot</groupId>\n                   <artifactId>spring-boot-dependencies</artifactId>\n                   <version>2.3.4.RELEASE</version>\n                   <type>pom</type>\n                   <scope>import</scope>\n               </dependency>\n               <!--数据库-->\n               <dependency>\n                   <groupId>mysql</groupId>\n                   <artifactId>mysql-connector-java</artifactId>\n                   <version>8.0.13</version>\n               </dependency>\n               <dependency>\n                   <groupId>com.alibaba</groupId>\n                   <artifactId>druid</artifactId>\n                   <version>1.1.24</version>\n               </dependency>\n               <!--SpringBoot启动器-->\n               <dependency>\n                   <groupId>org.mybatis.spring.boot</groupId>\n                   <artifactId>mybatis-spring-boot-starter</artifactId>\n                   <version>2.1.3</version>\n               </dependency>\n   \n               <!--junit-->\n               <dependency>\n                   <groupId>junit</groupId>\n                   <artifactId>junit</artifactId>\n                   <version>${juit.version}</version>\n               </dependency>\n               <!--lombok-->\n               <dependency>\n                   <groupId>org.projectlombok</groupId>\n                   <artifactId>lombok</artifactId>\n                   <version>${lombok.version}</version>\n               </dependency>\n               <!--log4j-->\n               <dependency>\n                   <groupId>log4j</groupId>\n                   <artifactId>log4j</artifactId>\n                   <version>${log4j.version}</version>\n               </dependency>\n               <dependency>\n                   <groupId>ch.qos.logback</groupId>\n                   <artifactId>logback-core</artifactId>\n                   <version>1.2.3</version>\n               </dependency>\n           </dependencies>\n       </dependencyManagement>\n   \n   \n   </project>\n   ```\n\n   \n\n2. 再创建一个子项目 springcloud_api 。用来存放实体类\n\n   pom文件中直接引用不需要再导入版本号，因为父工程已经些好了。\n\n   ```xml\n      <dependencies>\n           <dependency>\n               <groupId>org.projectlombok</groupId>\n               <artifactId>lombok</artifactId>\n           </dependency>\n       </dependencies>\n   ```\n\n3. 现在再创建子项目提供者服务。名称为springcloud-provider-8001\n\n   就写我们的mapper 、service、controller服务以及配置yml\n\n   \n\n4. 创建一个子项目springcloud-consu mer-dept-80 服务消费者。消费者不应该有service服务。\n\n   首先我们得写一个Configbean类把RestTemplate用Bean托管起来\n\n   ```java\n   import org.springframework.context.annotation.Bean;\n   import org.springframework.context.annotation.Configuration;\n   import org.springframework.web.client.RestTemplate;\n   \n   @Configuration\n   public class ConfigBean {\n       @Bean\n       public RestTemplate getRestTemplate(){\n           return new RestTemplate();\n       }\n   }\n   \n   ```\n\n   \n\n   controller直接REST调用8001\n\n   ```java\n   import com.zhaoguoshun.springcloud.pojo.Dept;\n   import org.springframework.beans.factory.annotation.Autowired;\n   import org.springframework.web.bind.annotation.PathVariable;\n   import org.springframework.web.bind.annotation.RequestMapping;\n   import org.springframework.web.bind.annotation.RestController;\n   import org.springframework.web.client.RestTemplate;\n   \n   import java.util.List;\n   \n   @RestController\n   public class DeptConsumerController {\n   \n       //消费者不应该有service层\n       //RestTemplate...供我们直接调用就可以了。注册到Spring中\n       @Autowired\n       private RestTemplate restTemplate;//通过多种便捷访问远程http服务的办法，简单的RestFul服务模板\n   \n       private static final String REST_URL_PREFIX=\"http://localhost:8001\";\n   \n       @RequestMapping(\"/consumer/dept/add\")\n       public Boolean add(Dept dept){\n           return restTemplate.postForObject(REST_URL_PREFIX+\"/dept/add\",dept,Boolean.class);\n       }\n       ///dept/queryDeptById?id=1\n       @RequestMapping(\"/consumer/dept/getByid/{id}\")\n       public Dept get(@PathVariable(\"id\") Long id){\n   \n           return restTemplate.getForObject(REST_URL_PREFIX+\"/dept/get/\"+id,Dept.class);\n       }\n   \n       @RequestMapping(\"/consumer/dept/list\")\n       public List<Dept> list(){\n           return restTemplate.getForObject(REST_URL_PREFIX+\"/dept/all\",List.class);\n       }\n   }\n   \n   ```\n\n\n\n# Eureka服务注册与发现\n\n### 什么是Eureka？\n\n- NetFix在设计Eureka时，就是遵循的AP原则\n- Eureka是NetFix的一个子模块，也是最核心模块之一。Eureka是一个基于REST的服务，用于定位服务，以实现云端中间层服务发现和故障转移，服务注册与发现对于微服务来说是非常重要的，有了服务发现与注册，只需要使用服务的标识符，就可以访问的服务，而不需要修改服务调用的配置文件了功能类似于Dubbo的注册中心，比如Zookeeper\n\n \n\n### 原理讲解\n\n- Eureka的基本架构\n  - SpringCloud封装了NetFix公司开发的Eureka模块来实现服务注册和发现(Zookeeper)\n  - Eureka采用C-S架构设计，Eureka作为服务注册功能的服务器，它是服务注册中心\n  - 而系统中的其他微服务。使用Eureka的客户端连接到EurekaServer并维持心跳连接。这样系统的维护人员就可以通过EurekaServer来监控系统中\n\n各个微服务是否正常运行。\n\n- 三大角色\n  - Eureka Server：提供服务的注册与发现\n  - Service Provider：将自身服务注册到Eureka中，从而使消费方能够找到。\n  - Service Consumer:服务消费方从Eureka中获取服务注册列表，从而找到消费服务。\n\n\n\n### 配置Eureka\n\n1. 创建子项目 springcloud-eureka-7001\n\n2. 导入依赖包\n\n   ```xml\n    <dependencies>\n        <!--Eureka-->\n           <dependency>\n               <groupId>org.springframework.cloud</groupId>\n               <artifactId>spring-cloud-starter-eureka-server</artifactId>\n               <version>1.4.6.RELEASE</version>\n           </dependency>\n           <!--热部署-->\n           <dependency>\n               <groupId>org.springframework.boot</groupId>\n               <artifactId>spring-boot-devtools</artifactId>\n           </dependency>\n       </dependencies>\n   ```\n\n3. 配置application.yml\n\n   ```yaml\n   server:\n     port: 7001\n   \n   #eureka\n   eureka:\n     instance:\n       hostname: localhost #服务端的实列名称\n     client:\n       register-with-eureka: false   #是否向eureka注册中心注册自己\n       fetch-registry: false #如果为false，则表示自己为注册中心\n       service-url: #监控页面\n         defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\n   ```\n\n   \n\n4. 在启动类上开启注解\n\n   ```java\n   @EnableEurekaServer //@EnableEurekaServer 服务端的启动类可以接收别人注册进来\n   ```\n\n\n\n### 注册与发现\n\n1. 在我们提供者项目里添加依赖\n\n   ```xml\n      <dependency>\n               <groupId>org.springframework.cloud</groupId>\n               <artifactId>spring-cloud-starter-eureka</artifactId>\n               <version>1.4.7.RELEASE</version>\n           </dependency>\n   \n           <!--actuator完善监控信息-->\n           <dependency>\n               <groupId>org.springframework.boot</groupId>\n               <artifactId>spring-boot-starter-actuator</artifactId>\n           </dependency>\n   \n   ```\n\n   \n\n2. 配置application.yml\n\n   ```yaml\n   #Eureka的配置服务注册到哪里\n   eureka:\n     client:\n       service-url:\n         defaultZone: http://localhost:7001/eureka/\n     instance:\n       instance-id: springcloud-provider-dept8001\n   \n   info:\n     app.name: zhaoguoshun-cloud\n     company.name: zhaoguoshun.cn\n   ```\n\n3. 现在启动类，在注册中心中发现 @EnableEurekaClient //自动向服务端注册\n\n   ![Description](https://static01.imgkr.com/temp/b8545a8a7b374302ba2e697535045db3.png)\n\n4. 发现。在pom中加入依赖\n\n   ```xml\n    <!--actuator完善监控信息-->\n           <dependency>\n               <groupId>org.springframework.boot</groupId>\n               <artifactId>spring-boot-starter-actuator</artifactId>\n           </dependency>\n   ```\n\n   \n\n5. 在Controller中注入DiscoveryClient然后编写方法\n\n   ```java\n       //注册进来的微服务获取一些信息\n       @RequestMapping(\"/dept/discovery\")\n       public Object discovery(){\n           List<String> services = client.getServices();\n           System.out.println(\"discovery==>service\"+services);\n   \n           //得到一个具体的微服务信息，通过具体的微服务id ,applicationName\n           List<ServiceInstance> instances = client.getInstances(\"SPRINGCLOUD-PROVIDER-DEPT\");\n   \n           for (ServiceInstance instance : instances) {\n               System.out.println(\n                       instance.getHost()+\"\\t\"+\n                       instance.getPort()+\"\\t\"+\n                       instance.getUri()+\"\\t\"+\n                       instance.getServiceId()\n               );\n           }\n           return this.client;\n       }\n   ```\n\n   \n\n6. 在启动类上开启服务与发现\n\n   ```java\n   @EnableDiscoveryClient //服务与发现\n   ```\n\n7. 启动访问 localhost:8001/dept/discovery\n\n  ![Description](https://static01.imgkr.com/temp/c61369c28f6743c9b99c9d613224ccde.png)\n\n   控制台打印：\n\n   \n\n  ![Description](https://static01.imgkr.com/temp/5879c29141ec48d6896a6b2d543cee17.png) \n\n8. \n\n### 自我保护机制\n\n在SpringCloud中可以使用`cureka.server.enable-self-preservation=false`禁用自我保护模式【不推荐关闭自我保护模式】\n\n\n\n\n\n\n\n### Eureka和Zookeeper\n\n\n\n\n\n回顾CAP原则\n\nRDBMS(mysql、oracle、sqlServer) ==>ACID\n\nACID是什么？\n\n​	-A (Atomicity)原子性\n\n​	-C（Consisitency）一致性\n\n​	-I（IsoLation）隔离性\n\n​	-D （Durability）持久性\n\n\n\nCAP是什么？\n\n-C (Consisitency)强一致性\n\n-A (Availability)可用性\n\n-P(Partition tolerance) 分区容错性\n\n==CAP理论的核心==\n\n​	一个分布式不可能同时很好的满足一致性，可用性，和分区容错性。\n\n**Eureka保证的是AP**\n\n​	Eureka看明白了这一点，因此在设计时就优先保证可用性。**Eureka各个节点是平等的**，几个节点挂掉不会影响正常节点的工作，剩下的节点依然可以提供注册和查询服务。而Eureka客户端在像某个Eureka注册时，如果发现连接失败，则会自动切换其他节点。只要有一台Eureka还在，就能保证注册服务的可用性，只不过查到的信息可能不是最新的，除此之外Eureka还有一种自我保护机制，如果在15分钟内超过80%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况：\n\n1. Eureka不在从注册列表中移除因为长时间没有收到心跳而应该过期的服务\n2. Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其他节点上（即保证当前节点依然可用）\n3. 当网络稳定时，当前实例新的注册信息会被同步到其他节点中。\n\n  \n\n==因此，Eureka可以很好的应对因网络故障导致部分节点失去练习的情况，而不会像Zookeeper哪样使整个服务瘫痪==\n\n\n\n\n\n### Ribbon是干什么的？\n\n- SpringCloud Ribbon 是基于NetFlix Ribbon实现的一套==客户端负载均衡的工具==\n- 简单的来说，Ruboo是NetFlix的开源项目，其主要功能就是提供客户端的软件负载均衡算法，将NetFlix的中间层服务连接在一起。Ribbon的客户端组件提供一系列完整的配置项如：连接超时、重试等等。简单来说就是在配置文件中列出LoadBalance(简称 LB :负载均衡)后面所有的机器，Ribbon会自动的帮你基于某种规则（比如单轮询，随机连接等等）去连接这些机器。我们也很容易用Ribbon实现自定义的负载均衡算法。\n\n**Ribbon能干嘛？**\n\n- ​	LB,即负载均衡，在微服务或者分布式集群中经常用的一种应用。\n- **负载均衡简单的来说就是将用户的请求平摊的分配到多个服务器上，从而达到系统的HA(高可用)**\n- 常见的负债均衡软件有 ：Nginx、Lvs等\n\n\n\n\n\n### 配置Ribbon\n\n\n\n1. 在消费者项目里导入Ribbon 和客户端Eureka依赖\n\n   ```xml\n     <dependency>\n               <groupId>org.springframework.cloud</groupId>\n               <artifactId>spring-cloud-starter-ribbon</artifactId>\n               <version>1.4.6.RELEASE</version>\n           </dependency>\n   \n           <dependency>\n               <groupId>org.springframework.cloud</groupId>\n               <artifactId>spring-cloud-starter-eureka</artifactId>\n               <version>1.4.7.RELEASE</version>\n           </dependency>\n   \n   ```\n\n   \n\n2. 编写application.yml配置\n\n   ```yaml\n   #Eureka配置\n   eureka:\n     client:\n       register-with-eureka: false #不像注册中心注册自己\n       service-url: #去三个注册中心获取了\n         defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/\n   \n   ```\n\n   \n\n3. 在config类上的RestTemplate 方法上加上@loadBalanced\n\n   ```java\n   @Configuration\n   public class ConfigBean {\n       @Bean\n       @LoadBalanced//Ribbon\n       public RestTemplate getRestTemplate(){\n           return new RestTemplate();\n       }\n   }\n   ```\n\n4. 启动我们的三个提供者服务、8001、8002、8003、和一个注册中心\n\n   发现Ribbon默认是轮询的机制\n\n### 自定义算法\n\n我们自定义算法\n\n1. IRule这个接口，该接口的实现类有\n\n   - RoundRobinRule：轮询（默认）\n   - RandomRule：随机\n   - RetryRule：重试（先按照轮询规则获取服务，如果获取服务失败则在指定时间内进行重试）\n   - 等\n\n   ```java\n       //配置负载均衡实现RestTemplate\n       //IRule\n       //RoundRobinRule :轮询\n       //RandomRule:随机\n       //AvailabilityFilteringRule 会先过滤掉，跳闸，访问故障的服务。对剩下的轮询\n       //RetryRule ：会先按照轮询获取服务，如果服务获取失败，则会在指定时间内重试\n   ```\n\n2. 如果不想用我么默认的机制需要在Config类中定义IRule接口，返回我们想用的机制\n\n   ```java\n    @Bean//随机\n       public IRule iRule(){\n           return new RandomRule();//返回随机机制\n       }\n   ```\n\n   \n\n3. 接下来我们自定义负载均衡算法\n\n   我们定义个包不要和启动类在同一个包下。官方也有说:\n\n   | 警告 | `FooConfiguration`必须是`@Configuration`，但请注意，主应用程序上下文不属于`@ComponentScan`，否则将由`@RibbonClients`共享。如果您使用`@ComponentScan`（或`@SpringBootApplication`），则需要采取措施避免包含（例如将其放在一个单独的，不重叠的包中，或者指定要在`@ComponentScan`）。 |\n   | ---- | ------------------------------------------------------------ |\n   |      |                                                              |\n\n   1. 定义一个myrule包，把randomRule类中的内容拿过来\n\n      ```java\n      //\n      // Source code recreated from a .class file by IntelliJ IDEA\n      // (powered by Fernflower decompiler)\n      //\n      \n      package com.zhaoguoshun.myRule;\n      \n      import com.netflix.client.config.IClientConfig;\n      import com.netflix.loadbalancer.AbstractLoadBalancerRule;\n      import com.netflix.loadbalancer.ILoadBalancer;\n      import com.netflix.loadbalancer.Server;\n      \n      import java.util.List;\n      import java.util.concurrent.ThreadLocalRandom;\n      \n      public class MyRandomRule extends AbstractLoadBalancerRule {\n      /*\n          每个服务访问5次换下一个服务（3个）\n       */\n      //total: 默认等于0,如果等于5我们指向下一个节点。\n          //index .默认等于0；如果total等于5index+1\n      \n          private int total=0;\n      \n          private int currentIndex=0;//当前是谁在提供服务\n      \n      \n          @SuppressWarnings({\"RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE\"})\n          public Server choose(ILoadBalancer lb, Object key) {\n              if (lb == null) {\n                  return null;\n              } else {\n                  Server server = null;\n      \n                  while(server == null) {\n                      if (Thread.interrupted()) {\n                          return null;\n                      }\n      \n                      List<Server> upList = lb.getReachableServers(); //获得活着的服务\n                      List<Server> allList = lb.getAllServers();  //获得全部的服务\n                      int serverCount = allList.size();\n                      if (serverCount == 0) {\n                          return null;\n                      }\n      //\n      //                int index = this.chooseRandomInt(serverCount);//生成区间随机数\n      //                server = (Server)upList.get(index); //从活着的服务随机获取一个\n      \n                      //===========================================================\n      \n                      if (total<5){\n                          server = upList.get(currentIndex);\n                          total++;\n                      }else {\n                          total=0;\n                          currentIndex++;\n      \n                          if (currentIndex>upList.size()){\n                              currentIndex=0;\n                          }\n                          server = upList.get(currentIndex);\n      \n                      }\n      \n      \n                      //===========================================================\n      \n      \n                      if (server == null) {\n                          Thread.yield();\n                      } else {\n                          if (server.isAlive()) {\n                              return server;\n                          }\n      \n                          server = null;\n                          Thread.yield();\n                      }\n                  }\n      \n                  return server;\n              }\n          }\n      \n          protected int chooseRandomInt(int serverCount) {\n              return ThreadLocalRandom.current().nextInt(serverCount);\n          }\n      \n          public Server choose(Object key) {\n              return this.choose(this.getLoadBalancer(), key);\n          }\n      \n          public void initWithNiwsConfig(IClientConfig clientConfig) {\n          }\n      }\n      \n      ```\n\n      \n\n   2. 写一个我们自己的类，比如GuoshunRule，注入一个@Bean，返回我们自己定义算法的类\n\n      ```java\n      import com.netflix.loadbalancer.IRule;\n      import org.springframework.context.annotation.Bean;\n      import org.springframework.context.annotation.Configuration;\n      \n      @Configuration\n      public class GuoshunRule {\n      \n          @Bean\n          public IRule iRule(){\n              return new MyRandomRule();//我们自定义的类\n          }\n      }\n      ```\n\n      \n\n   3. 在我们启动类上面添加Ribbon注解\n\n      ```java\n      //Ribbon 和Eureka整合以后，客户端可以直接调用，不用关心ip地址和端口号\n      @SpringBootApplication\n      @EnableEurekaClient\n      @RibbonClient(name = \"SPRINGCLOUD-PROVIDER-DEPT\",configuration = GuoshunRule.class)//Ribbon注解，configuration=指定我们的类\n      public class DeptConsumerApplication_80 {\n      \n          public static void main(String[] args) {\n              SpringApplication.run(DeptConsumerApplication_80.class,args);\n          }\n      ```\n\n   4. 启动我们的类项目，发现默认是以我们写的算法要求进行负载均衡的。\n\n\n\n### Feign负载均衡\n\n1. 简介：\n\n   Feign是声明式的web service客户端，它让微服务之间的调用变得更简单了，类似Controller调用Service. springCloud继承了Ribbon和Eureka，可在使用Feign时提供负载均衡的http客户端。\n\n   只需要创建一个接口，添加注解即可！\n\n   feign主要是社区，大家都习惯用面向接口编程。这个是很多开发人员的规范。调用微服务访问两种方法。\n\n   1. 微服务名字【Ribbon】\n   2. 接口和注解【Feign】\n\n2. 导入feign的依赖\n\n   ```xml\n     <!--feign-->\n           <dependency>\n               <groupId>org.springframework.cloud</groupId>\n               <artifactId>spring-cloud-starter-feign</artifactId>\n               <version>1.4.6.RELEASE</version>\n           </dependency>\n   ```\n\n   \n\n3. 写一个接口\n\n   ```java\n   import com.zhaoguoshun.springcloud.pojo.Dept;\n   import org.springframework.cloud.openfeign.FeignClient;\n   import org.springframework.stereotype.Component;\n   import org.springframework.stereotype.Service;\n   import org.springframework.web.bind.annotation.GetMapping;\n   import org.springframework.web.bind.annotation.PathVariable;\n   import org.springframework.web.bind.annotation.PostMapping;\n   \n   import java.util.List;\n   \n   @Component\n   @FeignClient(value = \"SPRINGCLOUD-PROVIDER-DEPT\")\n   public interface FeignService {\n   \n       @GetMapping(\"/dept/get/{id}\")\n       public Dept queryById(@PathVariable Long id);\n   \n       @GetMapping(\"/dept/list\")\n       public List<Dept> queryAll();\n   \n       @PostMapping(\"/dept/add\")\n       public boolean addDept(Dept dept);\n   \n   }\n   ```\n\n   \n\n4. controller层在调用接\n\n   1. \n\n      ```java\n      import com.zhaoguoshun.springcloud.pojo.Dept;\n      import com.zhaoguoshun.springcloud.service.FeignService;\n      import org.springframework.beans.factory.annotation.Autowired;\n      import org.springframework.beans.factory.annotation.Qualifier;\n      import org.springframework.web.bind.annotation.PathVariable;\n      import org.springframework.web.bind.annotation.RequestMapping;\n      import org.springframework.web.bind.annotation.RestController;\n      import org.springframework.web.client.RestTemplate;\n      \n      import java.util.List;\n      \n      @RestController\n      public class DeptConsumerController {\n      \n      \n          @Autowired\n          private FeignService service=null;\n      \n          @RequestMapping(\"/consumer/dept/add\")\n          public Boolean add(Dept dept){\n              return service.addDept(dept);\n          }\n          @RequestMapping(\"/consumer/dept/getByid/{id}\")\n          public Dept get(@PathVariable(\"id\") Long id){\n      \n              return service.queryById(id);\n          }\n      \n          @RequestMapping(\"/consumer/dept/list\")\n          public List<Dept> list(){\n             return service.queryAll();\n          }\n      }\n      ```\n\n5. 在启动类上加上feign开启\n\n   ```java\n   @EnableFeignClients(basePackages = \"com.zhaoguoshun.springcloud\")\n   ```\n\n\n\n\n\n## 服务熔断\n\n**分布式系统面临的问题**\n\n​	复杂分布式体系中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免的失败。\n\n\n\n**服务雪崩**\n\n​	在微服务架构中，一个请求需要调用多个服务是非常常见的。如客户端访问 A 服务，而 A 服务需要调用 B 服务，B 服务需要调用 C 服务，由于网络原因或者自身的原因，如果 B 服务或者 C 服务不能及时响应，A 服务将处于阻塞状态，直到 B 服务 C 服务响应。此时若有大量的请求涌入，容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，造成连锁反应，会对整个微服务系统造成灾难性的严重后果，\n\n这就是服务故障的“雪崩”效应\n\n**什么是Hystrix?**\n\n​	Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖会不可避免的调用失败，比如超时，异常等等。Hystrix能够保证在一个依赖出问题的情况下，不会导致服务整体失败，避免级连故障，以提高分布式的弹性。\n\n\n\n**服务熔断**\n\n​	熔断机制是对应雪崩效应的一种微服务链路保护机制。\n\n​	当扇出链路的某个微服务不可以或者响应时间太长时，会进行服务的降级，==进而熔断该节点微服务的调用，快速返回错误响应的信息==。当检测到该节点微服务调用响应正常后恢复调用链路。在SpringCloud框架里熔断机制通过Hystrix实现，Hystix会监视微服务间调用的状况，当失败的调用到一定的阈值，缺省是5秒内20次调用失败就会启动熔断机制。\n\n​	熔断机制的注解是@HystrixCommand\n\n\n\n1. 使用Hystrix，导入依赖\n\n   ```xml\n   <!--        hystrix-->\n           <dependency>\n               <groupId>org.springframework.cloud</groupId>\n               <artifactId>spring-cloud-starter-hystrix</artifactId>\n               <version>1.4.7.RELEASE</version>\n           </dependency>\n   ```\n\n   \n\n2. 看controller代码\n\n   ```java\n   import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;\n   import com.zhaoguoshun.service.DeptService;\n   import com.zhaoguoshun.springcloud.pojo.Dept;\n   import org.springframework.beans.factory.annotation.Autowired;\n   import org.springframework.web.bind.annotation.GetMapping;\n   import org.springframework.web.bind.annotation.PathVariable;\n   import org.springframework.web.bind.annotation.RestController;\n   \n   import java.util.List;\n   \n   @RestController\n   public class DeptController {\n   \n   \n       @Autowired\n      private DeptService deptService;\n   \n       @GetMapping(\"/dept/get/{id}\")\n       @HystrixCommand(fallbackMethod = \"Hystrixget\")\n       public Dept queryDeptById(@PathVariable Long id){\n           Dept dept = deptService.queryDeptById(id);\n   \n           if (dept==null){\n               throw new RuntimeException(\"id==>\"+id+\"不存在该用户\");\n           }\n           return dept;\n       }\n   \n       //备选方法\n       public Dept Hystrixget(@PathVariable Long id){\n         return new Dept()\n                 .setDeptno(id)\n                 .setDname(\"id=>\"+id+\"没有对应的信息\")\n                 .setDb_source(\"没有对应的数据库\");\n       }\n   \n   \n   }\n   ```\n\n   \n\n3. 在启动类上 添加对熔断的支持 @EnableCircuitBreaker\n\n   ```java\n   @EnableCircuitBreaker//添加对熔断的支持\n   ```\n\n4. 启动我们发现，当我们要找的id不存在时就会使用我们的备份方法\n\n5. 我们发现Eureka中，点击服务的连接时，下面显示的ip看不董\n\n   ![Description](https://static01.imgkr.com/temp/2eb73c9262a2487cb7415d4206c7c250.png)\n\n   这时候我们可用通过配置配置地址。\n\n   ```yaml\n   #Eureka的配置服务注册到哪里\n   eureka:\n     client:\n       service-url:\n         defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/\n     instance:\n       instance-id: springcloud-provider-hystrix-dept8001\n       prefer-ip-address: true #可以显示服务的ip\n   \n   info:\n     app.name: zhaoguoshun-cloud\n     company.name: zhaoguoshun.cn\n   ```\n\n   prefer-ip-address: true :默认等于false.\n\n   \n\n   \n\n   服务熔断：\n\n   - 服务端，某个服务超时或者异常，引入熔断\n\n   服务降级\n\n   - 客户端，从整体网络负载考虑，当某个服务降级或者关闭后，服务将不在被调用\n\n     此时在客户端，此时在客户端我们可以准备一个fallbackFactory,返回一个默认的值（缺省值），服务整体下降了，但是好歹能用。\n\n\n\n\n\n### Dashboard流监控\n\n\n![Description](https://static01.imgkr.com/temp/eb475be2956442fdbe6e33d7bb61704f.png)\n\n\n\n\n### Zuul路由网关\n\n概述：\n\n**什么是zuul网关？**\n\n​	 Zuul 包含了对请求的路由和过滤两个最主要的功能:其中 责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础而过滤器功能则负 请求的处理过程进行干预，是实现请求校验、服务聚合等功能的基础、 \n\n Zuul和Eureka进行整合，将Zuul自身注册为Eureka服务治理下的应用，同时从Eureka中获得其他微服务的消息，也即以后的访问微服务都是通过Zuul跳转后获得。\n\n\n\n注意：Zuul最终还是会注册进Eureka\n\n提供：代理+路由+过滤三大功能 \n\n\n\n配置zuul网关\n\n1. 创建一个springcloud-zuul-9527的一个项目，并导入依赖\n\n   ```xml\n    <dependency>\n               <groupId>org.springframework.cloud</groupId>\n               <artifactId>spring-cloud-starter-zuul</artifactId>\n               <version>1.4.7.RELEASE</version>\n   </dependency>\n   ```\n\n   \n\n2. 配置application.yml文件\n\n   ```yaml\n   server:\n     port: 9527\n   \n   spring:\n     application:\n       name: springcloud-zull\n   \n   eureka:\n     client:\n       service-url:\n         defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/\n     instance:\n       instance-id: zuul9527.com\n       prefer-ip-address: true\n   info:\n     app.name: zhaoguoshun-cloud\n     company.name: zhaoguoshun.com\n     \n    #配置Zuul\n   zuul:\n     routes:\n       mydept.serviceId: springcloud-provider-dept\n       mydept.path: /mydept/**\n     ignored-services: \"*\"  #不能再使用这个连接 隐藏所有的*\n     prefix: /zhao #设置公共的前缀\n   \n   ```\n\n   \n\n3. 创建启动类，并加上Zuul的代理\n\n   ```java\n   @SpringBootApplication\n   @EnableZuulProxy //代理\n   public class ZuulApplication_9527 {\n   \n       public static void main(String[] args) {\n           SpringApplication.run(ZuulApplication_9527.class,args);\n       }\n   }\n   \n   ```\n\n\n\n\n\n## SprinfCloud Config 配置\n\n**概述：**\n\n1. 微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务，由于每个服务都需要必要的配置信息才能运行，所以一套集中式的，动态的配置管理设施是必不可少的。\n2. springcloud提供configServer来解决这个问题，我们每一个application.yml，那上百的配置文件修改起来那不是要发疯。\n3. SpringCloudConfig 为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为**各个不同微服务应用**的所有环节提供了一个**中心化外部配置**\n4. springcloudConfig分为**服务端**和**客户端**两部分；\n\n\n\n**Spring cloud能干嘛？**\n\n- 集中管理配置文件\n- 不同环境，不同配置，动态化的配置更新，分环境部署，比如/dev/test/ prod/ beta/release\n- 运行期间动态调整配置，不在需要再每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息\n- 当配置变化时，服务不需要重启，即可感知配置的变化并应用新的配置\n- 将配置信息以REST的形式暴露\n\n\n\nSpringCloudConfig 与Git整合\n\n\n\n\n\n**将修改过的文件夹提交到github上**\n\n- ```\n  输入git add .\n  ```\n\n ![Description](https://static01.imgkr.com/temp/3e0e808dbcee4de692876078b9a83505.png)\n\n- ```\n  进入文件夹 cd springconfig \n  ```\n\n- ```\n  然后在 Git add .\n  ```\n\n  ![Description](https://static01.imgkr.com/temp/ae4139c594b448f28ff87df63036bd3e.png)\n  \n\n  - 看看状态\n\n  ![Description](https://static01.imgkr.com/temp/ae4139c594b448f28ff87df63036bd3e.png)\n\n- ```\n  提交上去	git commit -m \"first commit\"\n  ```\n\n  ![Description](https://static01.imgkr.com/temp/80eeeeb2946e418c8c8b3cc66604b3ae.png)\n\n- ```\n  最后我们在提交到远程 git push origin master\n  ```\n\n\n\n\n\n\n### 服务端连接Git，并且能获取到git文件中的数据。\n\n1. 创建springcloud-config-3344项目，并导入springcloud-config的依赖\n\n   ```xml\n      <!-- SpringConfig-server-->\n   	<!--服务端依赖-->\n           <dependency>\n               <groupId>org.springframework.cloud</groupId>\n               <artifactId>spring-cloud-config-server</artifactId>\n               <version>2.1.3.RELEASE</version>\n           </dependency>\n   \n           <dependency>\n               <groupId>org.springframework.boot</groupId>\n               <artifactId>spring-boot-starter-web</artifactId>\n           </dependency>\n   \n   <!--        <dependency>-->\n   <!--            <groupId>org.springframework.cloud</groupId>-->\n   <!--            <artifactId>spring-cloud-starter-eureka</artifactId>-->\n   <!--            <version>1.4.7.RELEASE</version>-->\n   <!--        </dependency>-->\n           <!--actuator完善监控信息-->\n           <dependency>\n               <groupId>org.springframework.boot</groupId>\n               <artifactId>spring-boot-starter-actuator</artifactId>\n           </dependency>\n   \n   ```\n\n   \n\n2. 配置application.yml文件\n\n   ```yaml\n   server:\n     port: 3344\n   \n   spring:\n     application:\n       name: springcloud-server-config\n   \n     cloud:\n       config:\n         server:\n           git:\n             uri: https://gitee.com/zhao_guo_shun/springcloud-config.git	#这里是你的远程git地址\n   ```\n\n3. 在启动类山添加注解 @EnableConfigServer\n\n   ```java\n   @EnableConfigServer //开启Config支持\n   ```\n\n   \n\n4. 启动项目，直接访问我们git上传好的文件名字。\n\n   ![Description](https://static01.imgkr.com/temp/e4d190ce224a47488a4e03b2b2ffced5.png)\n\n   ![Description](https://static01.imgkr.com/temp/e4d190ce224a47488a4e03b2b2ffced5.png)\n\n   或者用我们官网说的地址样式：\n\n   - HTTP服务具有以下格式的资源： \n\n   - ```\n     /{application}/{profile}[/{label}]\n     /{application}-{profile}.yml\n     /{label}/{application}-{profile}.yml\n     /{application}-{profile}.properties\n     /{label}/{application}-{profile}.properties\n     ```\n\n\n\n### 客户端连接服务端访问远程\n\n1. 往git上面写入一个配置文件，SpringCloud-client.yml。注意yml文件写错我们运行也会出错误\n\n   ```yaml\n   spring:\n       profiles:\n           active: dev\n   ---\n   server:\n       port: 8201\n   spring:\n     profiles: dev\n     application:\n       name: springcloud-provider-dept\n   \n   #Eureka的配置服务注册到哪里\n   eureka:\n     client:\n       service-url:\n         defaultZone: http://eureka7001.com:7001/eureka/\n         \n   ---\n   server:\n       port: 8202\n   spring:\n     profiles: test\n     application:\n       name: springcloud-provider-dept\n   \n   #Eureka的配置服务注册到哪里\n   eureka:\n     client:\n       service-url:\n         defaultZone: http://eureka7001.com:7001/eureka/\n   ```\n\n   \n\n2. 创建我们的Springcloud-client-3355项目，然后导入依赖。\n\n   ```xml\n   	  <!--客户端依赖-->\n   		<dependency>\n               <groupId>org.springframework.cloud</groupId>\n               <artifactId>spring-cloud-starter-config</artifactId>\n               <version>2.1.1.RELEASE</version>\n           </dependency>\n   \n           <dependency>\n               <groupId>org.springframework.boot</groupId>\n               <artifactId>spring-boot-starter-web</artifactId>\n           </dependency>\n   \n           <!--actuator完善监控信息-->\n           <dependency>\n               <groupId>org.springframework.boot</groupId>\n               <artifactId>spring-boot-starter-actuator</artifactId>\n           </dependency>\n   ```\n\n   \n\n3. 这里有一个bootstrap.yml 发现和application.yml差不多一样，但是bootstrap.yml是系统级别的配置，而application.yml是用户级别的配置。系统级别比用户级别优先级要高。下面配置配置文件\n\n   bootstrap.yml：\n\n   ```yaml\n   # 系统级别的配置\n   \n   spring:\n     cloud:\n       config:\n         name: config-client #需从git上读取的资源名称，不要后缀\n         profile: test\n         label: master\n         uri: http://localhost:3344\n   \n   \n   ```\n\n   application.yml\n\n   ```yaml\n   spring:\n     application:\n       name: springcloud-config-client-3355\n   ```\n\n   \n\n4. 写入一个Controller看看是否能拿到我们git的配置文件信息\n\n   ```java\n   import org.springframework.beans.factory.annotation.Value;\n   import org.springframework.web.bind.annotation.RequestMapping;\n   import org.springframework.web.bind.annotation.RestController;\n   \n   @RestController\n   public class ConfigClientController {\n   \n       @Value(\"${spring.application.name}\")\n       private String applicationName;\n       @Value(\"${eureka.client.service-url.defaultZone}\")\n       private String EurekaServer;\n       @Value(\"${server.port}\")\n       private String port;\n   \n       @RequestMapping(\"/config\")\n       public String config(){\n           return \"applicationName:\"+applicationName+\n                   \"Eureka:\"+EurekaServer+\n                   \"port:\" +port;\n       }\n   }\n   \n   ```\n\n   \n\n5. 启动时发现我们的端口号变成了我们git上配置的yml端口号\n\n\n\n\n\n', NULL, 0, 0, 0, NULL, '2021-01-01', 353, '2021-01-01', 15);
INSERT INTO `tb_article` VALUES (66, 43, 'MySQL索引背后的数据结构及算法原理', 'http://39.106.163.62:8081/cms/upload/8e16cda3-749a-4fe6-b048-f18f29eeda05.jpg', '本文以MySQL数据库为研究对象，讨论与数据库索引相关的一些话题。特别需要说明的是，MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等。为了避免混乱，本文将只关注于BTree索引，因为这是平常使用MySQL时主要打交道的索引，至于哈希索引和全文索引本文暂不讨论。', '', 'MySQL索引背后的数据结构及算法原理\n作者 张洋 | 发布于 2011-10-18\nMySQL 索引 B树 优化\n摘要\n本文以MySQL数据库为研究对象，讨论与数据库索引相关的一些话题。特别需要说明的是，MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等。为了避免混乱，本文将只关注于BTree索引，因为这是平常使用MySQL时主要打交道的索引，至于哈希索引和全文索引本文暂不讨论。\n\n文章主要内容分为三个部分。\n\n第一部分主要从数据结构及算法理论层面讨论MySQL数据库索引的数理基础。\n\n第二部分结合MySQL数据库中MyISAM和InnoDB数据存储引擎中索引的架构实现讨论聚集索引、非聚集索引及覆盖索引等话题。\n\n第三部分根据上面的理论基础，讨论MySQL中高性能使用索引的策略。\n数据结构及算法基础\n索引的本质\nMySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。\n\n我们知道，数据库查询是数据库的最主要功能之一。我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。最基本的查询算法当然是顺序查找（linear search），这种复杂度为O(n)的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如二分查找（binary search）、二叉树查找（binary tree search）等。如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。\n\n看一个例子：\n\n\n\n图1\n\n图1展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在\\(O(log_2n)\\)的复杂度内获取到相应数据。\n\n虽然这是一个货真价实的索引，但是实际的数据库系统几乎没有使用二叉查找树或其进化品种红黑树（red-black tree）实现的，原因会在下文介绍。\n\nB-Tree和B+Tree\n目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构，在本文的下一节会结合存储器原理及计算机存取原理讨论为什么B-Tree和B+Tree在被如此广泛用于索引，这一节先单纯从数据结构角度描述它们。\n\nB-Tree\n为了描述B-Tree，首先定义一条数据记录为一个二元组[key, data]，key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录除key外的数据。那么B-Tree是满足下列条件的数据结构：\n\nd为大于1的一个正整数，称为B-Tree的度。\n\nh为一个正整数，称为B-Tree的高度。\n\n每个非叶子节点由n-1个key和n个指针组成，其中d<=n<=2d。\n\n每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null 。\n\n所有叶节点具有相同的深度，等于树高h。\n\nkey和指针互相间隔，节点两端是指针。\n\n一个节点中的key从左到右非递减排列。\n\n所有节点组成树结构。\n\n每个指针要么为null，要么指向另外一个节点。\n\n如果某个指针在节点node最左边且不为null，则其指向节点的所有key小于\\(v(key_1)\\)，其中\\(v(key_1)\\)为node的第一个key的值。\n\n如果某个指针在节点node最右边且不为null，则其指向节点的所有key大于\\(v(key_m)\\)，其中\\(v(key_m)\\)为node的最后一个key的值。\n\n如果某个指针在节点node的左右相邻key分别是\\(key_i\\)和\\(key_{i+1}\\)且不为null，则其指向节点的所有key小于\\(v(key_{i+1})\\)且大于\\(v(key_i)\\)。\n\n图2是一个d=2的B-Tree示意图。\n\n\n\n图2\n\n由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。B-Tree上查找算法的伪代码如下：\n\nBTree_Search(node, key) {\n    if(node == null) return null;\n    foreach(node.key)\n    {\n        if(node.key[i] == key) return node.data[i];\n            if(node.key[i] > key) return BTree_Search(point[i]->node);\n    }\n    return BTree_Search(point[i+1]->node);\n}\ndata = BTree_Search(root, my_key);\n关于B-Tree有一系列有趣的性质，例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为\\(log_d((N+1)/2)\\)，检索一个key，其查找节点个数的渐进复杂度为\\(O(log_dN)\\)。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。\n另外，由于插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质，本文不打算完整讨论B-Tree这些内容，因为已经有许多资料详细说明了B-Tree的数学性质及插入删除算法，有兴趣的朋友可以在本文末的参考文献一栏找到相应的资料进行阅读。\n\nB+Tree\nB-Tree有许多变种，其中最常见的是B+Tree，例如MySQL就普遍使用B+Tree实现其索引结构。\n\n与B-Tree相比，B+Tree有以下不同点：\n\n每个节点的指针上限为2d而不是2d+1。\n\n内节点不存储data，只存储key；叶子节点不存储指针。\n\n图3是一个简单的B+Tree示意。\n\n\n\n图3\n\n由于并不是所有节点都具有相同的域，因此B+Tree中叶节点和内节点一般大小不同。这点与B-Tree不同，虽然B-Tree中不同节点存放的key和指针可能数量不一致，但是每个节点的域和上限是一致的，所以在实现中B-Tree往往对每个节点申请同等大小的空间。\n\n一般来说，B+Tree比B-Tree更适合实现外存储索引结构，具体原因与外存储器原理及计算机存取原理有关，将在下面讨论。\n\n带有顺序访问指针的B+Tree\n一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。\n\n\n\n图4\n\n如图4所示，在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。\n\n这一节对B-Tree和B+Tree进行了一个简单的介绍，下一节结合存储器存取原理介绍为什么目前B+Tree是数据库系统实现索引的首选数据结构。\n\n为什么使用B-Tree（B+Tree）\n上文说过，红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构，这一节将结合计算机组成原理相关知识讨论B-/+Tree作为索引的理论基础。\n\n一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。下面先介绍内存和磁盘存取原理，然后再结合这些原理分析B-/+Tree作为索引的效率。\n\n主存存取原理\n目前计算机使用的主存基本都是随机读写存储器（RAM），现代RAM的结构和存取原理比较复杂，这里本文抛却具体差别，抽象出一个十分简单的存取模型来说明RAM的工作原理。\n\n\n\n图5\n\n从抽象角度看，主存是一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据。每个存储单元有唯一的地址，现代主存的编址规则比较复杂，这里将其简化成一个二维地址：通过一个行地址和一个列地址可以唯一定位到一个存储单元。图5展示了一个4 x 4的主存模型。\n\n主存的存取过程如下：\n\n当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。\n\n写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。\n\n这里可以看出，主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取A0再取A1和先取A0再取D3的时间消耗是一样的。\n\n磁盘存取原理\n上文说过，索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。\n\n图6是磁盘的整体结构示意图。\n\n\n\n图6\n\n一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）。\n\n图7是磁盘结构的示意图。\n\n\n\n图7\n\n盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。\n\n当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。\n\n局部性原理与磁盘预读\n由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：\n\n当一个数据被用到时，其附近的数据也通常会马上被使用。\n\n程序运行期间所需要的数据通常比较集中。\n\n由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。\n\n预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。\n\nB-/+Tree索引的性能分析\n到这里终于可以分析B-/+Tree索引的性能了。\n\n上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：\n\n每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。\n\nB-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为\\(O(h)=O(log_dN)\\)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。\n\n综上所述，用B-Tree作为索引结构效率是非常高的。\n\n而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。\n\n上文还说过，B+Tree更适合外存索引，原因和内节点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于节点内key和data的大小：\n\n\\(d_{max}=floor(pagesize / (keysize + datasize + pointsize))\\)\n\nfloor表示向下取整。由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。\n\n这一章从理论角度讨论了与索引相关的数据结构与算法问题，下一章将讨论B+Tree是如何具体实现为MySQL中索引，同时将结合MyISAM和InnDB存储引擎介绍非聚集索引和聚集索引两种不同的索引实现形式。\n\nMySQL索引实现\n在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文主要讨论MyISAM和InnoDB两个存储引擎的索引实现方式。\n\nMyISAM索引实现\nMyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：\n\n\n\n图8\n\n这里设表一共有三列，假设我们以Col1为主键，则图8是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：\n\n\n\n图9\n\n同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。\n\nMyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。\n\nInnoDB索引实现\n虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。\n\n第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。\n\n\n\n图10\n\n图10是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。\n\n第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，图11为定义在Col3上的一个辅助索引：\n\n\n\n图11\n\n这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。\n\n了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。\n\n下一章将具体讨论这些与索引有关的优化策略。\n\n索引使用策略及优化\nMySQL的优化主要分为结构优化（Scheme optimization）和查询优化（Query optimization）。本章讨论的高性能索引策略主要属于结构优化范畴。本章的内容完全基于上文的理论基础，实际上一旦理解了索引背后的机制，那么选择高性能的策略就变成了纯粹的推理，并且可以理解这些策略背后的逻辑。\n\n示例数据库\n为了讨论索引策略，需要一个数据量不算小的数据库作为示例。本文选用MySQL官方文档中提供的示例数据库之一：employees。这个数据库关系复杂度适中，且数据量较大。下图是这个数据库的E-R关系图（引用自MySQL官方手册）：\n\n\n\n图12\n\nMySQL官方文档中关于此数据库的页面为http://dev.mysql.com/doc/employee/en/employee.html。里面详细介绍了此数据库，并提供了下载地址和导入方法，如果有兴趣导入此数据库到自己的MySQL可以参考文中内容。\n\n最左前缀原理与相关优化\n高效使用索引的首要条件是知道什么样的查询会使用到索引，这个问题和B+Tree中的“最左前缀原理”有关，下面通过例子说明最左前缀原理。\n\n这里先说一下联合索引的概念。在上文中，我们都是假设索引只引用了单个的列，实际上，MySQL中的索引可以以一定顺序引用多个列，这种索引叫做联合索引，一般的，一个联合索引是一个有序元组<a1, a2, …, an>，其中各个元素均为数据表的一列，实际上要严格定义索引需要用到关系代数，但是这里我不想讨论太多关系代数的话题，因为那样会显得很枯燥，所以这里就不再做严格定义。另外，单列索引可以看成联合索引元素数为1的特例。\n\n以employees.titles表为例，下面先查看其上都有哪些索引：\n\nSHOW INDEX FROM employees.titles;\n+--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+\n| Table  | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Null | Index_type |\n+--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+\n| titles |          0 | PRIMARY  |            1 | emp_no      | A         |        NULL |      | BTREE      |\n| titles |          0 | PRIMARY  |            2 | title       | A         |        NULL |      | BTREE      |\n| titles |          0 | PRIMARY  |            3 | from_date   | A         |      443308 |      | BTREE      |\n| titles |          1 | emp_no   |            1 | emp_no      | A         |      443308 |      | BTREE      |\n+--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+\n从结果中可以到titles表的主索引为<emp_no, title, from_date>，还有一个辅助索引<emp_no>。为了避免多个索引使事情变复杂（MySQL的SQL优化器在多索引时行为比较复杂），这里我们将辅助索引drop掉：\n\nALTER TABLE employees.titles DROP INDEX emp_no;\n这样就可以专心分析索引PRIMARY的行为了。\n\n情况一：全列匹配。\nEXPLAIN SELECT * FROM employees.titles WHERE emp_no=\'10001\' AND title=\'Senior Engineer\' AND from_date=\'1986-06-26\';\n+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+\n| id | select_type | table  | type  | possible_keys | key     | key_len | ref               | rows | Extra |\n+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+\n|  1 | SIMPLE      | titles | const | PRIMARY       | PRIMARY | 59      | const,const,const |    1 |       |\n+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+\n很明显，当按照索引中所有列进行精确匹配（这里精确匹配指“=”或“IN”匹配）时，索引可以被用到。这里有一点需要注意，理论上索引对顺序是敏感的，但是由于MySQL的查询优化器会自动调整where子句的条件顺序以使用适合的索引，例如我们将where中的条件顺序颠倒：\n\nEXPLAIN SELECT * FROM employees.titles WHERE from_date=\'1986-06-26\' AND emp_no=\'10001\' AND title=\'Senior Engineer\';\n+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+\n| id | select_type | table  | type  | possible_keys | key     | key_len | ref               | rows | Extra |\n+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+\n|  1 | SIMPLE      | titles | const | PRIMARY       | PRIMARY | 59      | const,const,const |    1 |       |\n+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+\n效果是一样的。\n\n情况二：最左前缀匹配。\nEXPLAIN SELECT * FROM employees.titles WHERE emp_no=\'10001\';\n+----+-------------+--------+------+---------------+---------+---------+-------+------+-------+\n| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra |\n+----+-------------+--------+------+---------------+---------+---------+-------+------+-------+\n|  1 | SIMPLE      | titles | ref  | PRIMARY       | PRIMARY | 4       | const |    1 |       |\n+----+-------------+--------+------+---------------+---------+---------+-------+------+-------+\n当查询条件精确匹配索引的左边连续一个或几个列时，如<emp_no>或<emp_no, title>，所以可以被用到，但是只能用到一部分，即条件所组成的最左前缀。上面的查询从分析结果看用到了PRIMARY索引，但是key_len为4，说明只用到了索引的第一列前缀。\n\n情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。\nEXPLAIN SELECT * FROM employees.titles WHERE emp_no=\'10001\' AND from_date=\'1986-06-26\';\n+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+\n| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra       |\n+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+\n|  1 | SIMPLE      | titles | ref  | PRIMARY       | PRIMARY | 4       | const |    1 | Using where |\n+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+\n此时索引使用情况和情况二相同，因为title未提供，所以查询只用到了索引的第一列，而后面的from_date虽然也在索引中，但是由于title不存在而无法和左前缀连接，因此需要对结果进行扫描过滤from_date（这里由于emp_no唯一，所以不存在扫描）。如果想让from_date也使用索引而不是where过滤，可以增加一个辅助索引<emp_no, from_date>，此时上面的查询会使用这个索引。除此之外，还可以使用一种称之为“隔离列”的优化方法，将emp_no与from_date之间的“坑”填上。\n\n首先我们看下title一共有几种不同的值：\n\nSELECT DISTINCT(title) FROM employees.titles;\n+--------------------+\n| title              |\n+--------------------+\n| Senior Engineer    |\n| Staff              |\n| Engineer           |\n| Senior Staff       |\n| Assistant Engineer |\n| Technique Leader   |\n| Manager            |\n+--------------------+\n只有7种。在这种成为“坑”的列值比较少的情况下，可以考虑用“IN”来填补这个“坑”从而形成最左前缀：\n\nEXPLAIN SELECT * FROM employees.titles\nWHERE emp_no=\'10001\'\nAND title IN (\'Senior Engineer\', \'Staff\', \'Engineer\', \'Senior Staff\', \'Assistant Engineer\', \'Technique Leader\', \'Manager\')\nAND from_date=\'1986-06-26\';\n+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+\n| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |\n+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+\n|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 59      | NULL |    7 | Using where |\n+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+\n这次key_len为59，说明索引被用全了，但是从type和rows看出IN实际上执行了一个range查询，这里检查了7个key。看下两种查询的性能比较：\n\nSHOW PROFILES;\n+----------+------------+-------------------------------------------------------------------------------+\n| Query_ID | Duration   | Query                                                                         |\n+----------+------------+-------------------------------------------------------------------------------+\n|       10 | 0.00058000 | SELECT * FROM employees.titles WHERE emp_no=\'10001\' AND from_date=\'1986-06-26\'|\n|       11 | 0.00052500 | SELECT * FROM employees.titles WHERE emp_no=\'10001\' AND title IN ...          |\n+----------+------------+-------------------------------------------------------------------------------+\n“填坑”后性能提升了一点。如果经过emp_no筛选后余下很多数据，则后者性能优势会更加明显。当然，如果title的值很多，用填坑就不合适了，必须建立辅助索引。\n\n情况四：查询条件没有指定索引第一列。\nEXPLAIN SELECT * FROM employees.titles WHERE from_date=\'1986-06-26\';\n+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+\n| id | select_type | table  | type | possible_keys | key  | key_len | ref  | rows   | Extra       |\n+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+\n|  1 | SIMPLE      | titles | ALL  | NULL          | NULL | NULL    | NULL | 443308 | Using where |\n+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+\n由于不是最左前缀，索引这样的查询显然用不到索引。\n\n情况五：匹配某列的前缀字符串。\nEXPLAIN SELECT * FROM employees.titles WHERE emp_no=\'10001\' AND title LIKE \'Senior%\';\n+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+\n| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |\n+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+\n|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 56      | NULL |    1 | Using where |\n+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+\n此时可以用到索引，但是如果通配符不是只出现在末尾，则无法使用索引。（原文表述有误，如果通配符%不出现在开头，则可以用到索引，但根据具体情况不同可能只会用其中一个前缀）\n\n情况六：范围查询。\nEXPLAIN SELECT * FROM employees.titles WHERE emp_no < \'10010\' and title=\'Senior Engineer\';\n+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+\n| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |\n+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+\n|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 4       | NULL |   16 | Using where |\n+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+\n范围列可以用到索引（必须是最左前缀），但是范围列后面的列无法用到索引。同时，索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引。\n\nEXPLAIN SELECT * FROM employees.titles\nWHERE emp_no < \'10010\'\nAND title=\'Senior Engineer\'\nAND from_date BETWEEN \'1986-01-01\' AND \'1986-12-31\';\n+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+\n| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |\n+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+\n|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 4       | NULL |   16 | Using where |\n+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+\n可以看到索引对第二个范围索引无能为力。这里特别要说明MySQL一个有意思的地方，那就是仅用explain可能无法区分范围索引和多值匹配，因为在type中这两者都显示为range。同时，用了“between”并不意味着就是范围查询，例如下面的查询：\n\nEXPLAIN SELECT * FROM employees.titles\nWHERE emp_no BETWEEN \'10001\' AND \'10010\'\nAND title=\'Senior Engineer\'\nAND from_date BETWEEN \'1986-01-01\' AND \'1986-12-31\';\n+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+\n| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |\n+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+\n|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 59      | NULL |   16 | Using where |\n+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+\n看起来是用了两个范围查询，但作用于emp_no上的“BETWEEN”实际上相当于“IN”，也就是说emp_no实际是多值精确匹配。可以看到这个查询用到了索引全部三个列。因此在MySQL中要谨慎地区分多值匹配和范围匹配，否则会对MySQL的行为产生困惑。\n\n情况七：查询条件中含有函数或表达式。\n很不幸，如果查询条件中含有函数或表达式，则MySQL不会为这列使用索引（虽然某些在数学意义上可以使用）。例如：\n\nEXPLAIN SELECT * FROM employees.titles WHERE emp_no=\'10001\' AND left(title, 6)=\'Senior\';\n+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+\n| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra       |\n+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+\n|  1 | SIMPLE      | titles | ref  | PRIMARY       | PRIMARY | 4       | const |    1 | Using where |\n+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+\n虽然这个查询和情况五中功能相同，但是由于使用了函数left，则无法为title列应用索引，而情况五中用LIKE则可以。再如：\n\nEXPLAIN SELECT * FROM employees.titles WHERE emp_no - 1=\'10000\';\n+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+\n| id | select_type | table  | type | possible_keys | key  | key_len | ref  | rows   | Extra       |\n+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+\n|  1 | SIMPLE      | titles | ALL  | NULL          | NULL | NULL    | NULL | 443308 | Using where |\n+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+\n显然这个查询等价于查询emp_no为10001的函数，但是由于查询条件是一个表达式，MySQL无法为其使用索引。看来MySQL还没有智能到自动优化常量表达式的程度，因此在写查询语句时尽量避免表达式出现在查询中，而是先手工私下代数运算，转换为无表达式的查询语句。\n\n索引选择性与前缀索引\n既然索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。\n\n第一种情况是表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，让查询做全表扫描就好了。至于多少条记录才算多，这个个人有个人的看法，我个人的经验是以2000作为分界线，记录数不超过 2000可以考虑不建索引，超过2000条可以酌情考虑索引。\n\n另一种不建议建索引的情况是索引的选择性较低。所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值：\n\nIndex Selectivity = Cardinality / #T\n\n显然选择性的取值范围为(0, 1]，选择性越高的索引价值越大，这是由B+Tree的性质决定的。例如，上文用到的employees.titles表，如果title字段经常被单独查询，是否需要建索引，我们看一下它的选择性：\n\nSELECT count(DISTINCT(title))/count(*) AS Selectivity FROM employees.titles;\n+-------------+\n| Selectivity |\n+-------------+\n|      0.0000 |\n+-------------+\ntitle的选择性不足0.0001（精确值为0.00001579），所以实在没有什么必要为其单独建索引。\n\n有一种与索引选择性有关的索引优化策略叫做前缀索引，就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。下面以employees.employees表为例介绍前缀索引的选择和使用。\n\n从图12可以看到employees表只有一个索引<emp_no>，那么如果我们想按名字搜索一个人，就只能全表扫描了：\n\nEXPLAIN SELECT * FROM employees.employees WHERE first_name=\'Eric\' AND last_name=\'Anido\';\n+----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+\n| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows   | Extra       |\n+----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+\n|  1 | SIMPLE      | employees | ALL  | NULL          | NULL | NULL    | NULL | 300024 | Using where |\n+----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+\n如果频繁按名字搜索员工，这样显然效率很低，因此我们可以考虑建索引。有两种选择，建<first_name>或<first_name, last_name>，看下两个索引的选择性：\n\nSELECT count(DISTINCT(first_name))/count(*) AS Selectivity FROM employees.employees;\n+-------------+\n| Selectivity |\n+-------------+\n|      0.0042 |\n+-------------+\nSELECT count(DISTINCT(concat(first_name, last_name)))/count(*) AS Selectivity FROM employees.employees;\n+-------------+\n| Selectivity |\n+-------------+\n|      0.9313 |\n+-------------+\n<first_name>显然选择性太低，<first_name, last_name>选择性很好，但是first_name和last_name加起来长度为30，有没有兼顾长度和选择性的办法？可以考虑用first_name和last_name的前几个字符建立索引，例如<first_name, left(last_name, 3)>，看看其选择性：\n\nSELECT count(DISTINCT(concat(first_name, left(last_name, 3))))/count(*) AS Selectivity FROM employees.employees;\n+-------------+\n| Selectivity |\n+-------------+\n|      0.7879 |\n+-------------+\n选择性还不错，但离0.9313还是有点距离，那么把last_name前缀加到4：\n\nSELECT count(DISTINCT(concat(first_name, left(last_name, 4))))/count(*) AS Selectivity FROM employees.employees;\n+-------------+\n| Selectivity |\n+-------------+\n|      0.9007 |\n+-------------+\n这时选择性已经很理想了，而这个索引的长度只有18，比<first_name, last_name>短了接近一半，我们把这个前缀索引 建上：\n\nALTER TABLE employees.employees\nADD INDEX `first_name_last_name4` (first_name, last_name(4));\n此时再执行一遍按名字查询，比较分析一下与建索引前的结果：\n\nSHOW PROFILES;\n+----------+------------+---------------------------------------------------------------------------------+\n| Query_ID | Duration   | Query                                                                           |\n+----------+------------+---------------------------------------------------------------------------------+\n|       87 | 0.11941700 | SELECT * FROM employees.employees WHERE first_name=\'Eric\' AND last_name=\'Anido\' |\n|       90 | 0.00092400 | SELECT * FROM employees.employees WHERE first_name=\'Eric\' AND last_name=\'Anido\' |\n+----------+------------+---------------------------------------------------------------------------------+\n性能的提升是显著的，查询速度提高了120多倍。\n\n前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于ORDER BY和GROUP BY操作，也不能用于Covering index（即当索引本身包含查询所需全部数据时，不再访问数据文件本身）。\n\nInnoDB的主键选择与插入优化\n在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。\n\n经常看到有帖子或博客讨论主键选择问题，有人建议使用业务无关的自增主键，有人觉得没有必要，完全可以使用如学号或身份证号这种唯一字段作为主键。不论支持哪种论点，大多数论据都是业务层面的。如果从数据库索引优化角度看，使用InnoDB引擎而不使用自增主键绝对是一个糟糕的主意。\n\n上文讨论过InnoDB的索引实现，InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。\n\n如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如下图所示：\n\n\n\n图13\n\n这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。\n\n如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置：\n\n\n\n图14\n\n此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。\n\n因此，只要可以，请尽量在InnoDB上采用自增字段做主键。\n\n后记\n这篇文章断断续续写了半个月，主要内容就是上面这些了。不可否认，这篇文章在一定程度上有纸上谈兵之嫌，因为我本人对MySQL的使用属于菜鸟级别，更没有太多数据库调优的经验，在这里大谈数据库索引调优有点大言不惭。就当是我个人的一篇学习笔记了。\n\n其实数据库索引调优是一项技术活，不能仅仅靠理论，因为实际情况千变万化，而且MySQL本身存在很复杂的机制，如查询优化策略和各种引擎的实现差异等都会使情况变得更加复杂。但同时这些理论是索引调优的基础，只有在明白理论的基础上，才能对调优策略进行合理推断并了解其背后的机制，然后结合实践中不断的实验和摸索，从而真正达到高效使用MySQL索引的目的。\n\n另外，MySQL索引及其优化涵盖范围非常广，本文只是涉及到其中一部分。如与排序（ORDER BY）相关的索引优化及覆盖索引（Covering index）的话题本文并未涉及，同时除B-Tree索引外MySQL还根据不同引擎支持的哈希索引、全文索引等等本文也并未涉及。如果有机会，希望再对本文未涉及的部分进行补充吧。\n\n参考文献\n[1] Baron Scbwartz等 著，王小东等 译；高性能MySQL（High Performance MySQL）；电子工业出版社，2010\n\n[2] Michael Kofler 著，杨晓云等 译；MySQL5权威指南（The Definitive Guide to MySQL5）；人民邮电出版社，2006\n\n[3] 姜承尧 著；MySQL技术内幕-InnoDB存储引擎；机械工业出版社，2011\n\n[4] D Comer, Ubiquitous B-tree; ACM Computing Surveys (CSUR), 1979\n\n[5] Codd, E. F. (1970). \"A relational model of data for large shared data banks\". Communications of the ACM, , Vol. 13, No. 6, pp. 377-387\n\n[6] MySQL5.1参考手册 - http://dev.mysql.com/doc/refman/5.1/zh/index.html', NULL, 0, 0, 1, NULL, '2021-01-04', 354, '2021-01-04', 7);
INSERT INTO `tb_article` VALUES (67, 43, 'Mysql', 'http://39.106.163.62:8081/cms/upload/2f6f2a33-eb3b-426b-9ece-5232b1aea57f.jpg', '聚合函数    Count   计数       -----   ------     SUM     总和       AVG     平均       MAX     最大值     MIN     最小                                              select count studentname  from student        sql ', '', '### 聚合函数\n\n| Count | 计数   |\n| ----- | ------ |\n| SUM   | 总和   |\n| AVG   | 平均   |\n| MAX   | 最大值 |\n| MIN   | 最小   |\n|       |        |\n|       |        |\n\n\n\nselect count（studentname） from student ; \n\n```sql\n-- 聚合函数\nselect COUNT(title) form article ; --  会查询所有的为null的值\nselect COUNT(*) form article ; --  不会忽略null\nselect COUNT(1) form article ; --  不会忽略null\n```\n\nMD5加密\n\n```sql\n-- MD5加密\nUpdata testMd5 set pwd=MD5(pwd) where id =1\n-- 插入的时候就加密 \nInsert INTo testMd5 value (4,\"国顺\",MD5(\'985211\'))\n\n--如何校验： 将用户传过来的密码，进行md5加密，然后 比对加密后的值\nselect * from where `name`=\'xiaoshun\' and pwd=MD5(\'123456\')\n```\n\n\n\n### 事务\n\nhttps://blog.csdn.net/dengjili/article/details/82468576\n\n什么是事务：\n\n==要么都成功，要么都失败==\n\n\n\n> 事务原则：ACID原则\n\nACID:原子性，一致性，隔离性，持久性\n\n\n\n原子性： 要么都成功要么都失败\n\n一致性:  事务前后的数据完整要保证一致\n\n持久性： 事务一旦提交则不可逆，被持久化到数据库中\n\n隔离性： 事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他的操作数据干扰之间要相互隔离\n\n> 隔离所导致的问题\n\n脏读，不可重复度，虚读\n\n\n\n> 执行事务\n\n```sql\n-- 事务\n-- mysql 默认是开启事务自动提交的\n\nset autocommit =0 /* 关闭*/\nset autocommit =1 /* 开启*/\n\n-- \n\n-- 事务开启\nstart TRANSACTION -- 标记一个事务的开始，从这个之后的sql都在同一个事务内\n\ncommit\n-- 提交： 持久化\n\nROLLBACK\n-- 回滚 ： 回到原来的样子（失败！）\n\n-- 了解\n\nSAVEPOINT 保存点名 -- 设置一个事务的保存点\n\nROLLBACK To SAVEPOINT -- 回滚到保存点\n\nRELEASE SAVEPOINT 保存点名 -- 撤销保存点\n\n```\n\n> 模拟场景\n\n```sql\n-- 模拟转账 \n\nset Autocommit =0; -- 关闭自动提交\n\nSTART TRANSACTION -- 开启一个事务\n\nUPDATE account set money=money-500 WHERE `name` =\'A\' -- A减500\nUPDATE account set money=money+500 WHERE `name` =\'B\' -- B加500\n\n\nCOMMIT;-- 提交事务,就被持久化了\n\nROLLBACK; -- 回滚\n\nSet Autocommit=1;\n```\n\n\n\n### 索引\n\n> Mysql 官方对索引的定义为： 索引（Index） 是帮助Mysql高效查询数据的\n\n#### 索引的分类\n\n> 在一个表中，主键索引只能有一个，唯一索引可以有多个\n\n1. 主键索引\n   1. 唯一的标识，主键不可重复，只能有一个列作为主键\n2. 唯一索引 （UNIQUE KEY）\n   1. 避免重复的列出现，唯一索引可以重复，多个列都可以标识为 唯一索引\n3. 常规索引 （KEY）\n   1. 默认的，index。key关键字来设置\n4. 全文索引\n   1. 在特定的数据库引擎下才有，MyLSAM\n   2. 快速定位数据\n\n\n\n基本使用\n\n```sql\n-- 索引的使用\n-- 1. 在创建表的时候给字段增加索引\n-- 2. 创建完毕后，增加索引\n-- 增加一个全文索引\nALTER TABLE ssmblog.article ADD FULLTEXT INDEX `article_content`(`article_content`);\n\n-- 显示所有的索引信息\nshow Index FROM article\n\n-- EXPLAIN 分析sql执行的状况\n\nEXPLAIN SELECT * FROM article  -- 非全文索引\n\nEXPLAIN SELECT * FROM article WHERE MATCH (article_content) AGAINST(\'场景\')\n \n```\n\n测试一百万条数据的速度\n\n```sql\nSELECT * FROM app_user WHERE `name`=\'用户99999\'; -- 0.743s\n\n-- 添加索引\n-- CREATE INDEX 索引名 ON 表 （	`字段`）\nCREATE INDEX id_app_user_name ON app_user(`name`);\n\nEXPLAIN SELECT * FROM app_user WHERE `name`=\'用户560957\' -- 0.001s\n\n```\n\n==索引在小数据量的时候，用处不大，但是在大数据的时候，区别十分明显==\n\n\n\n### 索引原则\n\n- 索引不是越多越好\n- 不要对进程变动数据加索引\n- 小数据量的表不需要加索引\n- 索引一般加在常用来查询的字段上！\n\n> 索引的数据结构\n\nHash类型的索引\n\nBtree :InnoDB的默认数据结构\n\n\n\n阅读：\n\n\n\n', NULL, 0, 0, 0, NULL, '2021-01-04', 353, '2021-01-04', 3);
INSERT INTO `tb_article` VALUES (69, 42, '简单排序', 'http://39.106.163.62:8081/cms/upload/13721385-54b5-4421-b88a-0870d598d424.jpg', '冒泡排序  选择排序 和插入排序     ', '', '### 冒泡排序\n\n```java\n//冒泡排序\n    public static void aa(){\n        int arr[] ={5,4,3,5,1};\n        for (int i=arr.length-1;i>0;i--){\n            for (int j=0;j<i;j++){\n                if (arr[j]>arr[j+1]){\n                    int temp;\n                    temp=arr[j];\n                    arr[j]=arr[j+1];\n                    arr[j+1]=temp;\n                }\n            }\n        }\n        System.out.println(Arrays.toString(arr));\n    }\n```\n\n冒泡排序使用了双层for循环，其中内层循环的的循环体是真正完成排序的代码。\n\n\n\n元素比较的次数为：\n\n​	（N-1）+(N-2)+(N-3)+...2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2;\n\n元素交换的次数为：\n\n​	（N-1）+(N-2)+(N-3)+...2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2;\n\n总执行次数为：\n\n​	（N^2/2-N/2）+(N^2/2-N/2)=N^2-N;\n\n冒泡排序适合数据少的时候排序，如果有一百万个数需要排序不推荐使用这种。\n\n### 选择排序\n\n**排序原理**：\n\n1. 每一次遍历的过程中，都假定第一个索引处的元素是最小值，和其索引的值依次进行比较，如果当前索引的值大于其他某个索引的值，则假定其他某个索引出的值为最小值，最后可能找到最小值所在的索引\n2. 交换第一个索引处和最小值所在的索引处的值\n\n```java\n   public static void  aa(){\n        Integer arr[]={5,3,6,7,9,4};\n       //减2的意思是最后一个数就不需要排了\n        for (int i=0; i<=arr.length-2;i++){\n            int minIndex=i;\n            for (int j=i+1;j<arr.length;j++){\n                if (arr[minIndex]>arr[j]){//\n                   minIndex=j; //1\n                }\n            }\n            int temp;\n            temp=arr[i];\n            arr[i]=arr[minIndex];\n            arr[minIndex]=temp;\n        }\n        System.out.println(Arrays.toString(arr));\n    }\n```\n\n\n\n或者\n\n```java\n  /**\n     * 对数组a中的元素进行排序\n     */\n    public static void sort(Comparable[] a){\n        //减2的意思是最后一个数就不需要排了\n        for (int i=0;i<=a.length-2;i++){\n            // 定义一个变量，记录最小元素所在的索引，默认参与选择排序的第一个元素所在的位置\n            int minIndex=i;\n            for (int j=i+1;j<a.length;j++){\n                //需要比较最小的索引minIndex处的值和j索引处的值；\n                if (greater(a[minIndex],a[j])){\n                    minIndex=j;\n                }\n            }\n            //交换最小元素所在索引minIndex处的值和索引i处的值\n            exch(a,i,minIndex);\n        }\n    }\n\n    /**\n     * 比较元素时候大于w元素\n     */\n    public static  boolean greater(Comparable v,Comparable w){\n        return v.compareTo(w)>0;\n    }\n\n    /**\n     * 数组元素i和j交换位置\n     */\n    private static void  exch(Comparable[]a ,int i ,int j){\n        Comparable temp;\n\n        temp=a[i];\n        a[i]=a[j];\n        a[j]=temp;\n    }\n\n// 测试 \n   public static void main(String[] args) {\n        Integer arr[]={5,3,6,7,9,4};\n\n        Selection.sort(arr);\n        System.out.println(Arrays.toString(arr));\n//        aa();\n    }\n```\n\n\n\n**选择排序的时间复杂度分析**\n\n​	选择排序使用了双层for循环，其中外层循环完成了数据的交换，内层完成了数据的比较，所以我们分别统计数据交换次数和数据比较次数。\n\n\n\n数据比较次数：\n\n​	（N-1)+(N-2)+(N-3)+....+2+1=（(N-1)/2）=N^2/2-N/2;\n\n\n\n数据交换次数\n\n​	N-1\n\n时间复杂度： N^2/2-N/2+(N-1)=N^2/2+N/2-1\n\n根据大O推导法则，保留最高阶项，去除常数因子，时间复杂度为O(N^2);\n\n\n\n选择排序同样适合于少量数据排序，当我们的数据特别多的时候这种就不太适合了。\n\n### 插入排序\n\n插入排序是一种简单直观且end的排序算法\n\n排序原理：\n\n1. 把所有的元素分为两组，已知排序和未排序的；\n2. 找到未排序组中的第一个元素，向已排序的组中进行插入\n3. 倒叙遍历已经排序的元素，依次和待插入的元素进行比较，直到找到一个元素小于等于待插入的元素，那么就 把待插入的元素放到这个位置，其他的元素向后移动一位\n\n**插入排序的时间复杂度分析**\n\n​	插入排序使用了双层for循环，其中内层循环的循环体是真正完成排序的代码，所以，我们分析插入排序的时间复杂度，主要分析一下内层循环体的执行次数即可。\n\n\n\n```java\npublic static void aa(){\n        Integer arr[]={6,2,4,8,10,3,5};\n        for (int i=1;i<arr.length;i++){\n            for (int j=i;j>0;j--){\n                if (arr[j-1]>arr[j]) {\n                    int temp = arr[j - 1];\n                    arr[j - 1] = arr[j];\n                    arr[j]=temp;\n                }else {\n                    break;\n                }\n            }\n        }\n        System.out.println(Arrays.toString(arr));\n}\n```\n\n\n\n\n\n最坏情况，也就是待排序的数组元素为{12,10,6,5,4,3,2,1} 那么：\n\n​	比较的次数为：\n\n​		（N-1）+(N+2)+(N-3)...+2+1=((N-1)+1)*(N-1)/2-N/2；\n\n\n\n​	交换的次数为：\n\n​		（N-1）+(N+2)+(N-3)...+2+1=((N-1)+1)*(N-1)/2-N/2；\n\n​	总执行次数为：\n\n​	（N^2/2-N/2）+（N^2/2-N/2）=N^2-N\n\n\n\n按照大O推导法则，保留函数中的最高阶项那么最终插入排序的时间复杂度为O(N^2)', NULL, 0, 0, 0, NULL, '2021-01-05', 353, '2021-01-05', 11);

-- ----------------------------
-- Table structure for tb_article_attachment
-- ----------------------------
DROP TABLE IF EXISTS `tb_article_attachment`;
CREATE TABLE `tb_article_attachment`  (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `article_id` int(11) NULL DEFAULT NULL COMMENT '文章ID',
  `url` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '路径',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 13 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '文章附件' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tb_article_attachment
-- ----------------------------
INSERT INTO `tb_article_attachment` VALUES (1, 5, 'http://localhost:8081/cms/upload/fc9891d1-5496-41c5-a218-c7fa70826950.jpg');
INSERT INTO `tb_article_attachment` VALUES (2, 5, 'http://localhost:8081/cms/upload/65d115df-309c-41ea-a84c-7b3cf5e80095.jpg');
INSERT INTO `tb_article_attachment` VALUES (3, 6, 'http://localhost:8081/cms/upload/6c337640-cc50-4d6a-bfb2-46452cbeda9f.jpg');

-- ----------------------------
-- Table structure for tb_article_tag
-- ----------------------------
DROP TABLE IF EXISTS `tb_article_tag`;
CREATE TABLE `tb_article_tag`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `article_id` int(11) NULL DEFAULT NULL,
  `tag_id` int(11) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 97 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '文章标签' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tb_article_tag
-- ----------------------------
INSERT INTO `tb_article_tag` VALUES (48, 44, 4);
INSERT INTO `tb_article_tag` VALUES (56, 60, 5);
INSERT INTO `tb_article_tag` VALUES (59, 62, 9);
INSERT INTO `tb_article_tag` VALUES (60, 62, 10);
INSERT INTO `tb_article_tag` VALUES (61, 62, 12);
INSERT INTO `tb_article_tag` VALUES (62, 61, 6);
INSERT INTO `tb_article_tag` VALUES (67, 63, 9);
INSERT INTO `tb_article_tag` VALUES (68, 63, 5);
INSERT INTO `tb_article_tag` VALUES (71, 65, 11);
INSERT INTO `tb_article_tag` VALUES (72, 65, 12);
INSERT INTO `tb_article_tag` VALUES (73, 65, 9);
INSERT INTO `tb_article_tag` VALUES (77, 67, 15);
INSERT INTO `tb_article_tag` VALUES (79, 64, 13);
INSERT INTO `tb_article_tag` VALUES (83, 69, 17);
INSERT INTO `tb_article_tag` VALUES (86, 66, 15);

-- ----------------------------
-- Table structure for tb_channel
-- ----------------------------
DROP TABLE IF EXISTS `tb_channel`;
CREATE TABLE `tb_channel`  (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '名称',
  `parent_id` int(11) NULL DEFAULT NULL COMMENT '上级栏目',
  `channel_img` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '栏目图片',
  `summary` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '摘要',
  `single` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '是否单页 .Y为单页，Null为不单页',
  `url` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '外链URL',
  `seo_title` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'SEO标题',
  `seo_keyword` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'SEO关键字',
  `seo_description` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'SEO描述',
  `content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL COMMENT '正文',
  `create_user` int(11) NULL DEFAULT NULL COMMENT '创建人',
  `create_date` date NULL DEFAULT NULL COMMENT '创建时间',
  `pos` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '位置',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 44 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '栏目' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tb_channel
-- ----------------------------
INSERT INTO `tb_channel` VALUES (19, 'Java', 0, '', '', 'Y', '', '', '', '', '# SpringSecurity\n\n\n\n## 第一章、Spring security基础篇\n\n### SpringSecurity 的核心功能\n\n​	\n\n- Authentication :身份认证，用户登录的验证（你是谁？）\n- Authorization：访问授权，授权资源的访问权限（你能干什么？）\n- 安全防护，防止跨站的请求，session攻击等\n\n\n\nshiro和springsecurity对比：\n\n- shiro入门容易\n\n- spring security 相对门槛高，但已经有所改善\n- shiro属于apache社区\n- spring secutity 是Spring社区的亲儿子\n\n\n\n\n\n### HttpBasic认证\n\nHttpBasic认证模式是Spring Security实现登录认证最简单的一种方式\n\n\n\n防君子不妨小人\n\n\n\n### PasswordEncoder\n\nHash算法\n\n- 单向算法\n- hash（密码）不可逆\n\n\n\n加密后 $2a 表示 BCrypt 算法版本\n\n$10 //表示算法强度\n\n$0v7A2TRdj1dw7kWOJJD/k.lA4QwPhMg1Ky1XbrgFyt1Wu/7ZFQkhy //随机生成的盐值\n\n\n\n### FormLogin\n\n- formLogin 登录认证不写Controller方法\n- 传统登录认证 ，UsernamePasswordAuthenticationFilter\n- UsernamePassAuthentionFilter过滤器是默认集成的，我们只需要针对它进行配置。\n\n#### 配置三要素\n\n- 登录认证逻辑-登录URL、如何接受登录参数、登录成功后逻辑（静态）\n- 资源访问控制-决定什么用户、什么角色可以访问什么资源（动态-数据库）\n- 用户角色权限-配置某个用户拥有什么角色、拥有什么权限（动态-数据库）\n\n\n\n配置\n\n```java\nprotected void configure(HttpSecurity http) throws Exception {\n//        http.httpBasic()//开启httpBasic认证\n//                .and()\n//                .authorizeRequests()\n//                .anyRequest()\n//                .authenticated();//所有请求都需要登录认证才能访问\n        http.csrf().disable().formLogin()\n                .loginPage(\"/login.html\")//一旦用户的请求没有权限就会跳转到这个页面\n                .loginProcessingUrl(\"login\")//登录表单form中的action的地址\n                .usernameParameter(\"username\")//在登录表单form中用户名输入框input中的username\n                .passwordParameter(\"password\")\n                .defaultSuccessUrl(\"/\")//登录认证成功后默认要跳转的路径\n                .and()\n                .authorizeRequests()\n                .antMatchers(\"login.html\",\"login\").permitAll()//不需要通过登录验证就可以被访问的资源网站\n                .antMatchers(\"/\",\"biz1\",\"biz2\")//资源路径匹配\n                    .hasAnyAuthority(\"ROLE_user\",\"ROLE_admin\")  //user和admin角色都可以访问\n                .antMatchers(\"/syslog\",\"/sysuer\")//资源路径匹配\n                .hasRole(\"admin\");//admin角色可以访问\n```\n\n角色是一种特殊的权限\n\n- HasAnyAuthority(\"ROLE_admin\"，\"ROLE_admin\") 等价于  hasAnyRole(\"user\",\"admin\")\n\n\n\n\n\n### 登录验证流程\n\n![image-20201207144642634](C:\\Users\\guosz\\OneDrive\\桌面\\image-20201207144642634.png)\n\n\n\n### 自定义登录验证结果处理\n\n- 不同的人登录之后，看到不同的首页（即向不同页面跳转）\n- 前后端分离的应用，期望响应结果是json，而不是html页面\n\n\n\n登录成功的自定义结果处理接口：AuthentionSuccessHandler\n\n1. ```JAVA\n   import com.fasterxml.jackson.databind.ObjectMapper;\n   import com.zimug.commons.exception.AjaxResponse;\n   import org.springframework.beans.factory.annotation.Value;\n   import org.springframework.security.core.Authentication;\n   import org.springframework.security.web.authentication.SavedRequestAwareAuthenticationSuccessHandler;\n   import org.springframework.stereotype.Component;\n   \n   import javax.servlet.ServletException;\n   import javax.servlet.http.HttpServletRequest;\n   import javax.servlet.http.HttpServletResponse;\n   import javax.validation.Valid;\n   import java.io.IOException;\n   \n   /**\n    * 配置登录成功后的自定义结果处理接口\n    */\n   @Component\n   public class MyAuthenticationSuccessHandler\n           extends SavedRequestAwareAuthenticationSuccessHandler {\n       //SavedRequestAwareAuthenticationSuccessHandler  它有自动记住上一次请求路径地址的功能\n   \n       @Value(\"${spring.security.logintype}\")\n       private String loginType;\n   \n       private static ObjectMapper objectMapper=new ObjectMapper();\n   \n       @Override\n       public void onAuthenticationSuccess(HttpServletRequest request,\n                                           HttpServletResponse response,\n                                           Authentication authentication)\n               throws ServletException, IOException {\n           if (loginType.equalsIgnoreCase(\"JSON\")){\n               response.setContentType(\"application/json;charset=UTF-8\");\n               response.getWriter().write(objectMapper.writeValueAsString(AjaxResponse.success()));\n           }else {\n               //会帮我们跳转到上一次请求的页面上\n               super.onAuthenticationSuccess(request,response,authentication);\n           }\n       }\n   }\n   ```\n\n2. ```java\n   .successHandler(myAuthenticationSuccessHandler)//登录成功使用自定义路径\n   .failureHandler(myAuthenticationFailureHandler)//登录失败跳转自定义路径\n   ```\n\n3. 请求数据\n\n   ```html\n     $.ajax({\n               type: \"POST\",\n               url: \"/login\",\n               data:{\n                   \"username\":username, //这里的参数名称要和Spring Security配置一致\n                   \"password\":password\n               },\n               success: function (json) {\n                   console.log(json);\n                   if (json.isok){\n                       location.href=\'/\' //index.html\n                   }else {\n                       console.log(json.message)\n                       alert(json.message);\n                       location.href=\'/login.html\'\n                   }\n               },\n               error:function (e) {\n   \n               }\n           })\n       }\n   ```\n\n   \n\n登录失败的自定义结果处理接口：AuthenticationfailureHandler\n\n1. \n\n2. ```\n   import com.fasterxml.jackson.databind.ObjectMapper;\n   import com.zimug.commons.exception.AjaxResponse;\n   import com.zimug.commons.exception.CustomException;\n   import com.zimug.commons.exception.CustomExceptionType;\n   import org.springframework.beans.factory.annotation.Value;\n   import org.springframework.security.core.AuthenticationException;\n   import org.springframework.security.web.authentication.SimpleUrlAuthenticationFailureHandler;\n   import org.springframework.stereotype.Component;\n   \n   import javax.servlet.ServletException;\n   import javax.servlet.http.HttpServletRequest;\n   import javax.servlet.http.HttpServletResponse;\n   import java.io.IOException;\n   \n   /**\n    * 登录错误后的处理\n    */\n   @Component\n   public class MyAuthenticationFailureHandler extends SimpleUrlAuthenticationFailureHandler {\n   \n       @Value(\"spring.security.logintype\")\n       private String logintype;\n   \n       private static ObjectMapper objectMapper=new ObjectMapper();\n       @Override\n       public void onAuthenticationFailure(HttpServletRequest request,\n                                           HttpServletResponse response,\n                                           AuthenticationException exception)\n               throws IOException, ServletException {\n   \n           if (logintype.equalsIgnoreCase(\"JSON\")){\n               response.setContentType(\"application/json;charset=UTF-8\");\n               response.getWriter().write(objectMapper.writeValueAsString(AjaxResponse.userInputError(\"您检查您的用户名和密码输入是否正确\")));\n           }else {\n               response.setContentType(\"text/html;charset=UTF-8\");\n               super.onAuthenticationFailure(request,response,exception);\n           }\n   \n       }\n   }\n   ```\n\n3. ```java\n   import com.fasterxml.jackson.databind.ObjectMapper;\n   import com.zimug.commons.exception.AjaxResponse;\n   import com.zimug.commons.exception.CustomException;\n   import com.zimug.commons.exception.CustomExceptionType;\n   import org.springframework.beans.factory.annotation.Value;\n   import org.springframework.security.core.AuthenticationException;\n   import org.springframework.security.web.authentication.SimpleUrlAuthenticationFailureHandler;\n   import org.springframework.stereotype.Component;\n   \n   import javax.servlet.ServletException;\n   import javax.servlet.http.HttpServletRequest;\n   import javax.servlet.http.HttpServletResponse;\n   import java.io.IOException;\n   \n   /**\n    * 登录错误后的处理\n    */\n   @Component\n   public class MyAuthenticationFailureHandler extends SimpleUrlAuthenticationFailureHandler {\n   \n       @Value(\"spring.security.logintype\")\n       private String logintype;\n   \n       private static ObjectMapper objectMapper=new ObjectMapper();\n       @Override\n       public void onAuthenticationFailure(HttpServletRequest request,\n                                           HttpServletResponse response,\n                                           AuthenticationException exception)\n               throws IOException, ServletException {\n   \n           if (logintype.equalsIgnoreCase(\"JSON\")){\n               response.setContentType(\"application/json;charset=UTF-8\");\n               response.getWriter().write(objectMapper.writeValueAsString(AjaxResponse.userInputError(\"您检查您的用户名和密码输入是否正确\")));\n           }else {\n               response.setContentType(\"text/html;charset=UTF-8\");\n               super.onAuthenticationFailure(request,response,exception);\n           }\n   \n       }\n   }\n   \n   ```\n\n4. ```java\n   .successHandler(myAuthenticationSuccessHandler)//登录成功使用自定义路径\n   .failureHandler(myAuthenticationFailureHandler)//登录失败跳转自定义路径\n   ```\n\n\n\n\n\n### SpringSecutity session创建策略\n\n\n\n- always :如果当前请求没有对应的session存在，创建一个session\n- ifRequired（默认）：在需要使用到session时才创建session\n- never：SpringSecurity 将永远不会主动创建session，但是如果session在当前应用中已经存在，它将使用该session\n- stateless：Spring Security 不会创建或使用任何session。适合于接口型的无状态应用（前后端分离），该方式节省内存资源。\n\n\n\n一般不需要修改，如果非要修改的话，就在Secutity下的Config http参数的配置。\n\n```java\n.and()\n                .sessionManagement()\n                .sessionCreationPolicy(SessionCreationPolicy.ALWAYS); //可以设置多个\n```\n\n![image-20201207183925758](C:\\Users\\guosz\\OneDrive\\桌面\\image-20201207183925758.png)\n\n\n\n#### 会话超时配置\n\n- server.servlet.timout=15m\n- spring.session.timout=15m\n\n\n\n##### 会话超时跳转地址\n\n```java\n.and().sessionManagement()\n                .invalidSessionUrl(\"/invalidSession.html\");\n```\n\n\n\n#### session保护\n\n- migrationSession保护方式（默认）。即对于同一个SESSION用户，每次登陆验证将创建一个新的HTTP session，旧的session将无效，将旧的session属性复制到新的session上面。\n\n  \n\n- 设置为 \"none\"时，原始会话不会无效\n\n  \n\n- 设置  \"newSession\"后，将创建一个干净的会话，而不会复制旧会话中的任何属性\n\n```java\n.and().sessionManagement()\n                .invalidSessionUrl(\"/invalidSession.html\")\n                .sessionFixation().migrateSession();//session保护配置\n```\n\n\n\n#### Cookie的安全\n\n- httpOnly:如果为true，则浏览器脚本将无法访问cookie\n- secure :如果为true，则仅通过HTTPS连接发送cookie，HTTP无法携带cookie。\n\n\n\n### 同账号多段登录被迫下线\n\n\n\nsession安全管理\n\n- spring Security session 创建策略\n- 会话超时配置及自定义处理\n- session 固定保护\n- Cookie的安全配置\n\n#### 限制最大登录用户数量\n\n```java\n.sessionManagement()\n    .maximumSesions(1)\n    .maxSessionPreventLogin(false)\n    .expiredSessionStrategy(new CustomExpiredSessionStrategy())\n```\n\ntrue 表示 已经登录就不允许再次登录\n\nfalse 表示允许再次登录，但是之前的登录账号不会被踢下线\n\n\n\n演示\n\n```java\n.and().sessionManagement()\n                .invalidSessionUrl(\"/invalidSession.html\")\n                .sessionFixation().migrateSession()\n                .maximumSessions(1)\n                .maxSessionsPreventsLogin(false)\n                .expiredSessionStrategy(new CustomExpiredSessionStrategy()); //自定义了跳转的路径\n```\n\n```java\nimport org.springframework.security.web.DefaultRedirectStrategy;\nimport org.springframework.security.web.RedirectStrategy;\nimport org.springframework.security.web.session.SessionInformationExpiredEvent;\nimport org.springframework.security.web.session.SessionInformationExpiredStrategy;\n\nimport javax.servlet.ServletException;\nimport java.io.IOException;\n\npublic class CustomExpiredSessionStrategy implements SessionInformationExpiredStrategy {\n\n    //页面跳转的处理逻辑\n    private RedirectStrategy redirectStrategy =new DefaultRedirectStrategy();\n\n    @Override\n    public void onExpiredSessionDetected(SessionInformationExpiredEvent event)\n            throws IOException, ServletException {\n\n        redirectStrategy.sendRedirect(event.getRequest(),event.getResponse(),\"/logout\");\n\n    }\n}\n\n```\n\n![image-20201207195143670](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201207195143670.png)\n\n\n\n登录之后一开始登录的就会被踢掉。\n\n\n\n前后端分离，需要返回json数据\n\n```java\n    private ObjectMapper objectMapper=new ObjectMapper();\n\n    @Override\n    public void onExpiredSessionDetected(SessionInformationExpiredEvent event)\n            throws IOException, ServletException {\n//        redirectStrategy.sendRedirect(event.getRequest(),event.getResponse(),\"/logout\");\n\n        HashMap<String, Object> map = new HashMap<>();\n        map.put(\"code\",403);\n        map.put(\"msg\",\"您的登录已经超时或者在应一台机器登录，您被迫下线\"\n                +event.getSessionInformation().getLastRequest());\n        String json=objectMapper.writeValueAsString(map);\n        event.getResponse().setContentType(\"application/json;charset=UTF-8\");\n        event.getResponse().getWriter().write(json);\n    }\n```\n\n测试完成\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201207200241534.png\" alt=\"image-20201207200241534\" style=\"zoom: 50%;\" />\n\n\n\n## 第二章、认证授权鉴权功能深入\n\n\n\nRole-Based Access Control\n\n- 用户：系统接口及能访问的操作者\n- 权限：能够访问某接口或者做某操作的授权资格\n- 角色：具有一类相同操作权限的用户的总称  \n\n\n\n### 动态加载用户角色权限\n\n动态加载\n\n- UserDetails 接口表达你是谁？你有什么角色权限？\n- UserDetailsService接口 表达的是如何动态加载UserDetails数据\n\n\n\nUserdetails接口\n\n<img src=\"C:\\Users\\guosz\\OneDrive\\桌面\\image-20201208103348752.png\" alt=\"image-20201208103348752\" style=\"zoom:50%;\" />\n\n\n\n\n\nUserDetailsService接口\n\n\n\n<img src=\"C:\\Users\\guosz\\OneDrive\\桌面\\image-20201208123425844.png\" alt=\"image-20201208123425844\" style=\"zoom:50%;\" />\n\nservice类\n\n```java\n    @Autowired\n    private MyUserDetailsServiceMapper myUserDetailsServiceMapper;\n\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n\n        //用户基础加载\n        MyUserDetails myUserDetails = myUserDetailsServiceMapper.findByUserName(username);\n\n        if (myUserDetails==null){\n            throw new UsernameNotFoundException(\"用户名不存在\");\n        }\n        System.out.println(\"打印一下查询的账号和密码\"+myUserDetails.toString());\n        //用户的角色列表加载\n        List<String> roleCodes = myUserDetailsServiceMapper.findRoleByUserName(username);\n\n\n        //根据角色列表加载当前具有的权限\n        List<String> authorityByRoleCodes = myUserDetailsServiceMapper.findAuthorityByRoleCodes(roleCodes);\n        System.out.println(\"ROleCode==》\"+authorityByRoleCodes);\n       roleCodes= roleCodes.stream()\n                .map(rc-> \"ROLE_\"+rc)\n                .collect(Collectors.toList());\n\n       authorityByRoleCodes.addAll(roleCodes);\n       myUserDetails.setAuthorities(AuthorityUtils.commaSeparatedStringToAuthorityList(\n               String.join(\",\",authorityByRoleCodes)\n       ));\n\n       myUserDetails.setEnable(true);\n       return myUserDetails;\n    }\n```\n\nmapper接口\n\n```java\npublic interface MyUserDetailsServiceMapper {\n\n    //根据userId查询用户信息\n    @Select(\"SELECT username,password,enabled\\n\"+\n            \"FROM sys_user u\\n\"+\n            \"WHERE u.username =#{userId}\"\n    )\n    MyUserDetails findByUserName(@Param(\"userId\") String userId);\n\n\n    @Select(\"SELECT role_code\\n\"+\n        \"FROM sys_role r\\n\"+\n            \"LEFT JOIN sys_user_role ur ON r.id=ur.role_id\\n\"+\n            \"LEFT JOIN sys_user u ON u.id=ur.user_id\\n\"+\n            \"WHERE u.username =#{userId}\"\n    )\n    List<String> findRoleByUserName(@Param(\"userId\") String userId);\n\n\n    //根据用户角色查询用户权限\n    //根据用户角色查询用户权限\n    @Select({\n            \"<script>\",\n            \"SELECT url \" ,\n            \"FROM sys_menu m \" ,\n            \"LEFT JOIN sys_role_menu rm ON m.id = rm.menu_id \" ,\n            \"LEFT JOIN sys_role r ON r.id = rm.role_id \",\n            \"WHERE r.role_code IN \",\n            \"<foreach collection=\'roleCodes\' item=\'roleCode\' open=\'(\' separator=\',\' close=\')\'>\",\n            \"#{roleCode}\",\n            \"</foreach>\",\n            \"</script>\"\n    })\n    List<String> findAuthorityByRoleCodes(@Param(\"roleCodes\") List<String> roleCodes);\n}\n\n```\n\n\n\n### 动态加载资源鉴权规则\n\n配置一个Service类\n\n```java\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.stereotype.Component;\nimport org.springframework.stereotype.Service;\n\nimport javax.servlet.http.HttpServletRequest;\n\n@Component(\"rbacService\")\npublic class MyRBACService {\n\n    public boolean hasPermission(HttpServletRequest request, Authentication authentication){\n        Object principal = authentication.getPrincipal();\n\n        if (principal instanceof UserDetails){//判断下是不是UserDetails类型\n            UserDetails userDetails=((UserDetails)principal);\n\n            //\"/syslog\"\n            //本次要访问的资源\n            SimpleGrantedAuthority simpleGrantedAuthority =\n                    new SimpleGrantedAuthority(request.getRequestURI());\n\n            return userDetails.getAuthorities().contains(simpleGrantedAuthority);\n        }\n\n        return false;\n    }\n}\n```\n\n在security配置中写入\n\n```java\n.anyRequest().access(\"@rbacService.hasPermission(request,authentication)\")\n```\n\n<img src=\"C:\\Users\\guosz\\OneDrive\\桌面\\image-20201208165838257.png\" alt=\"image-20201208165838257\" style=\"zoom:50%;\" />\n\n\n\n### SPEL权限表达式\n\n\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201208191906265.png\" alt=\"image-20201208191906265\" style=\"zoom:67%;\" />\n\n\n\n### RememberMe记住密码\n\n最简单实现\n\n​	后端配置\n\n```java\nhttp.rememberMe(); //实现记住我自动登录配置，核心的代码只有这一行\n```\n\n前端实现\n\n```java\n<label><input type=\"checkbox\" name=\"remember-me\"/>记住密码</label>\n```\n\n\n\n还有一些基本的配置\n\n```java\nhttp.rememberMe()\n                .rememberMeParameter(\"rememberMe-me-new\")//传参的名称\n                .rememberMeCookieName(\"remember-me-cookie\")//cookie名称\n                .tokenValiditySeconds(2*24*60*60)//令牌生成到过期的时间\n```\n\nRemenmberMeToken =username, expiryTime,signatureValue 的Base64加密\n\nsignatureValue = username、exiprationTime和password和一个预定义的key，并将和他们经过MD5进行签名。\n\n\n\n\n\n### 用户退出\n\n```java\nhttp..logout()//退出登录\n```\n\n\n\nlogout的默认行为\n\n1. 当前session失效，即logout的核心需求。session失效就是访问权限的回收\n2. 删除当前用户的remember-me 记住我功能信息\n3. clear 清除当前的securityContext\n4. 重定向到登录页面，loginPage配置项指定的页面\n\n\n\n\n\n配置信息：\n\n```java\n.logout()//退出登录\n                    .logoutUrl(\"sigout\")//默认退出的路径\n                    .logoutSuccessUrl(\"/afcdj.html\")//退出后重定向指定的页面\n                    .deleteCookies(\"JSESSIONID\")//删除cookie 的名字 。可以写多个\n```\n\n\n\nLoginSuccessHandler\n\n- 编辑实现个性化退出功能\n- `注意logoutSuccessUrl不要与logoutSuccessHandler 一起使用，否则logoutSuccessHandler将失效。`\n\n注入我们写好的配置类\n\n```java\nlogout().logoutSuccessHandler(myLogoutSuccessHandler)\n```\n\n```java\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n@Component\npublic class MyLogoutSuccessHandler implements LogoutSuccessHandler {\n    @Override\n    public void onLogoutSuccess(HttpServletRequest httpServletRequest,\n                                HttpServletResponse httpServletResponse,\n                                Authentication authentication)\n            throws IOException, ServletException {\n        //写一些业务逻辑，比如登录时间的统计。\n\n        httpServletResponse.sendRedirect(\"/login.html\");\n\n    }\n}\n```\n\n### 基于Session图片验证码实现\n\n\n\n验证码工具类库\n\n- 生成验证码文字或其他用于校验的数据形式（即谜底）\n- 生成验证码前端实现图片或拼图等（即谜面）\n- 用于校验用户输入与谜底的校验方法（如果是纯文字，就自己比对以下就可以。如果是基于物理图形拖拽，旋转等方式，需要专用的校验方法）\n\n\n\n#### 集成实现\n\n1. 新建一个properties\n\n   ```properties\n   kaptcha.border=no\n   kaptcha.border.color=105,179,90\n   kaptcha.image.width=100\n   kaptcha.image.height=45\n   kaptcha.session.key=code\n   kaptcha.textproducer.font.color=blue\n   kaptcha.textproducer.font.size=35\n   kaptcha.textproducer.char.length=4\n   kaptcha.textproducer.font.name=宋体,楷体,微软雅黑\n   \n   ```\n\n2. 配置文件集成到配置类中\n\n   ```java\n   import com.google.code.kaptcha.impl.DefaultKaptcha;\n   import com.google.code.kaptcha.util.Config;\n   import org.springframework.beans.factory.annotation.Value;\n   import org.springframework.context.annotation.Bean;\n   import org.springframework.context.annotation.PropertySource;\n   import org.springframework.stereotype.Component;\n   \n   import java.util.Properties;\n   @Component\n   @PropertySource(value = {\"classpath:kaptcha.properties\"})\n   public class CaptchaConfig {\n       @Value(\"${kaptcha.border}\")\n       private String border;\n       @Value(\"${kaptcha.border.color}\")\n       private String borderColor;\n       @Value(\"${kaptcha.textproducer.font.color}\")\n       private String fontColor;\n       @Value(\"${kaptcha.image.width}\")\n       private String imageWidth;\n       @Value(\"${kaptcha.image.height}\")\n       private String imageHeight;\n       @Value(\"${kaptcha.session.key}\")\n       private String sessionKey;\n       @Value(\"${kaptcha.textproducer.char.length}\")\n       private String charLength;\n       @Value(\"${kaptcha.textproducer.font.name}\")\n       private String fontNames;\n       @Value(\"${kaptcha.textproducer.font.size}\")\n       private String fontSize;\n   \n       @Bean(name = \"captchaProducer\")\n       public DefaultKaptcha getKaptchaBean(){\n           DefaultKaptcha defaultKaptcha = new DefaultKaptcha();\n   \n           Properties properties=new Properties();\n           properties.setProperty(\"kaptcha.border\",border);\n           properties.setProperty(\"kaptcha.border.color\",borderColor);\n           properties.setProperty(\"kaptcha.textproducer.font.color\",fontColor);\n           properties.setProperty(\"kaptcha.image.width\",imageWidth);\n           properties.setProperty(\"kaptcha.image.height\",imageHeight);\n           properties.setProperty(\"kaptcha.session.key\",sessionKey);\n           properties.setProperty(\"kaptcha.textproducer.char.length\",charLength);\n           properties.setProperty(\"kaptcha.textproducer.font.name\",fontNames);\n           properties.setProperty(\"kaptcha.textproducer.font.size\",fontSize);\n   \n           defaultKaptcha.setConfig(new Config(properties));\n           return defaultKaptcha;\n       }\n   }\n   ```\n\n   \n\n3. 封装一个实体类\n\n   ```java\n   import java.time.LocalDateTime;\n   \n   public class CaptchaImageVO {\n   \n       private String code;\n       private LocalDateTime expireTime;\n   \n       public CaptchaImageVO(String code, int expireAfterSeconds) {\n           this.code = code;\n           this.expireTime = LocalDateTime.now().plusSeconds(expireAfterSeconds);\n       }\n   \n       //判断验证码有没有过期\n       public boolean isExpired(){\n           return LocalDateTime.now().isAfter(expireTime);\n       }\n   }\n   \n   ```\n\n   \n\n4. 验证码生成Controller\n\n   ```java\n   import com.google.code.kaptcha.impl.DefaultKaptcha;\n   import com.zimug.courses.security.basic.auth.imagecode.CaptchaImageVO;\n   import org.springframework.web.bind.annotation.RequestMapping;\n   import org.springframework.web.bind.annotation.RequestMethod;\n   import org.springframework.web.bind.annotation.RestController;\n   \n   import javax.annotation.Resource;\n   import javax.imageio.ImageIO;\n   import javax.servlet.ServletOutputStream;\n   import javax.servlet.http.HttpServletResponse;\n   import javax.servlet.http.HttpSession;\n   import java.awt.image.BufferedImage;\n   import java.io.IOException;\n   \n   @RestController\n   public class CaptchaController {\n   \n       @Resource\n       private DefaultKaptcha captchaProducer;\n   \n       @RequestMapping(value = \"/kaptcha\",method = RequestMethod.GET)\n       public void kaptcha(HttpSession session, HttpServletResponse response) throws IOException {\n           response.setDateHeader(\"Expires\",0);\n           response.setHeader(\"Cache-Control\",\"no-store, no-cache, must-revalidate\");\n           response.addHeader(\"Cache-Control\",\"post-check=0,pre-check=0\");\n           response.setHeader(\"Pragma\",\"no-cache\");\n           response.setContentType(\"image/jpeg\");\n   \n   \n           String text = captchaProducer.createText();\n           session.setAttribute(\"captcha_key\",\n                   new CaptchaImageVO(text,2*60));//两分钟\n   \n         try (ServletOutputStream out= response.getOutputStream()){\n             BufferedImage bufferedImage= captchaProducer.createImage(text);\n             ImageIO.write(bufferedImage,\"jpg\",out);\n             out.flush();\n         }\n   \n   \n       }\n   }\n   ```\n\n   \n\n5. 前端配置 img\n\n   ```html\n   <!DOCTYPE html >\n   <html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n   <head>\n       <meta charset=\"UTF-8\">\n       <title>首页</title>\n   \n       <script src=\"js/jquery-3.5.1.min.js\"></script>\n   </head>\n   <body>\n   <h1>字母哥业务系统登录</h1>\n   <form action=\"/login\" method=\"post\">\n       <span>用户名称</span><input type=\"text\" id=\"username\" name=\"username\" /> <br>\n       <span>用户密码</span><input type=\"password\" id=\"password\" name=\"password\" /> <br>\n       <span>验证码</span><input type=\"text\" id=\"captchaCode\" name=\"captchaCode\" />\n       <img src=\"/kaptcha\" id=\"kaptcha\" width=\"110px\" height=\"40px\"/><br>\n       <input type=\"button\" onclick=\"login()\" value=\"登陆\">\n       <label><input type=\"checkbox\" name=\"remember-me\" id=\"remember-me\">记住密码</label>\n   </form>\n   \n   \n   <script type=\"text/javascript\">\n   \n       window.onload=function (ev) {\n           var kaptchaImg = document.getElementById(\"kaptcha\");\n   \n           kaptchaImg.onclick=function (evl) {\n               kaptchaImg.src=\"/kaptcha?\"+Math.floor(Math.random()*100)\n           }\n       };\n       function login() {\n           var username=$(\"#username\").val();\n           var password=$(\"#password\").val();\n           var rememberMe=$(\"#remember-me\").is(\":checked\");\n   \n           if (username=== \"\"||password===\"\"){\n               alert(\'用户名或密码不能为空\');\n               return ;\n           }\n   \n           $.ajax({\n               type: \"POST\",\n               url: \"/login\",\n               data:{\n                   \"username\":username, //这里的参数名称要和Spring Security配置一致\n                   \"password\":password,\n                   \"remember-me\":rememberMe\n               },\n               success: function (json) {\n                   console.log(json);\n                   if (json.isok){\n                       location.href=\'/\' //index.html\n                   }else {\n                       console.log(json.message)\n                       alert(json.message);\n                       location.href=\'/login.html\'\n                   }\n               },\n               error:function (e) {\n   \n               }\n           })\n       }\n   </script>\n   </body>\n   </html>\n   ```\n\n   \n\n6. 访问页面查看\n\n   <img src=\"C:\\Users\\guosz\\OneDrive\\桌面\\image-20201209110052138.png\" alt=\"image-20201209110052138\" style=\"zoom: 50%;\" />\n\n\n\n#### 验证码校验\n\n\n\n图片验证码校验过滤器\n\n1. 编写自定义图片验证码过滤器CaptchaCodeFilter,过滤中拦截登录请求\n2. 过滤器中从session获取验证码文字与用户输入比对，比对通过执行其他过滤器链\n3. 比对不通过，抛出SessionAuthenticationException异常交给AuthenticationFailureHandler处理器\n4. 最后将CaptchaCodeFilter放在UsernamePasswordAuthenticationFilter 过滤器前执行。\n\n写一个CaptchaCodeFilter类进行验证\n\n```java\nimport com.zimug.courses.security.basic.config.MyAuthenticationFailureHandler;\nimport com.zimug.courses.security.basic.utils.MyContants;\nimport org.springframework.security.core.AuthenticationException;\nimport org.springframework.security.web.authentication.session.SessionAuthenticationException;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.bind.ServletRequestBindingException;\nimport org.springframework.web.bind.ServletRequestUtils;\nimport org.springframework.web.context.request.ServletWebRequest;\nimport org.springframework.web.filter.OncePerRequestFilter;\n\nimport javax.annotation.Resource;\n\nimport javax.servlet.FilterChain;\nimport org.apache.commons.lang3.StringUtils;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\nimport java.io.IOException;\nimport java.util.Objects;\n@Component\npublic class CaptchaCodeFilter extends OncePerRequestFilter {\n\n    @Resource\n    MyAuthenticationFailureHandler myAuthenticationFailureHandler;\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request,\n                                    HttpServletResponse response,\n                                    FilterChain filterChain)\n            throws ServletException, IOException {\n        // 只有在登录请求时才有验证码校验\n        if(StringUtils.equals(\"/login\",request.getRequestURI())\n                && StringUtils.equalsIgnoreCase(request.getMethod(),\"post\")){\n            try{\n                //验证谜底与用户输入是否匹配\n                this.validate(new ServletWebRequest(request));\n            }catch(AuthenticationException e){\n                myAuthenticationFailureHandler.onAuthenticationFailure(\n                        request,response,e\n                );\n                //catch异常后,之后的过滤器就不再执行了\n                return;\n            }\n\n        }\n        filterChain.doFilter(request,response);\n    }\n\n    /**\n     * 验证码 校验\n     * @param request\n     * @throws ServletRequestBindingException\n     */\n    private void validate(ServletWebRequest request) throws ServletRequestBindingException {\n\n        HttpSession session = request.getRequest().getSession();\n\n        String codeInRequest = ServletRequestUtils.getStringParameter(\n                request.getRequest(),\"captchaCode\");\n        if(StringUtils.isEmpty(codeInRequest)){\n            throw new SessionAuthenticationException(\"验证码不能为空\");\n        }\n\n        // 3. 获取session池中的验证码谜底\n        CaptchaImageVO codeInSession = (CaptchaImageVO)\n                session.getAttribute(MyContants.CAPTCHA_SESSION_KEY);\n        if(Objects.isNull(codeInSession)) {\n            throw new SessionAuthenticationException(\"验证码不存在\");\n        }\n\n        // 4. 校验服务器session池中的验证码是否过期\n        if(codeInSession.isExpired()) {\n            session.removeAttribute(MyContants.CAPTCHA_SESSION_KEY);\n            throw new SessionAuthenticationException(\"验证码已经过期\");\n        }\n\n        // 5. 请求验证码校验\n        if(!StringUtils.equals(codeInSession.getCode(), codeInRequest)) {\n            throw new SessionAuthenticationException(\"验证码不匹配\");\n        }\n\n    }\n}\n```\n\n配置中加入\n\n```java\nhttp.addFilterBefore(captchaCodeFilter, UsernamePasswordAuthenticationFilter.class)\n```\n\n\n\n\n\n### 短信验证码登录功能\n\n\n\n\n\n\n\n## 第三章、JWT\n\n### JWT使用场景及架构安全\n\n\n\n<img src=\"C:\\Users\\guosz\\OneDrive\\桌面\\image-20201209190002470.png\" alt=\"image-20201209190002470\" style=\"zoom:50%;\" />\n\n\n\nSession不使用场景\n\n- 比如：非浏览器的客户端，手机移动端等等，因为他们没有浏览器自动维护cookie的功能\n- 比如：集群应用，同一个应用部署甲、乙、丙三个主机上，实现负载均衡应用，其中一个挂掉了其他还能负债工作。要知道session是保存在服务器内存里面的，三个主机一定是不同的内存。那么你登录的时候访问甲，而获取接口数据的时候访问的是乙，就无法保证session的唯一性共享性\n\n\n\nJWT令牌的使用方式\n\n<img src=\"C:\\Users\\guosz\\OneDrive\\桌面\\image-20201209191218819.png\" alt=\"image-20201209191218819\" style=\"zoom:50%;\" />\n\n\n\n##### JWT安全加强\n\n- 避免网络劫持，因为使用HTTPd的head传递JWT，所以要使用Https传输跟安全。这样在网络层面避免了JWT的泄露。\n- secret 是存放在服务器端的，所以只要应用服务器不被攻破，理论上JWT是安全的。因此要保证服务器的安全\n\n\n\n##### 实现原理\n\n<img src=\"C:\\Users\\guosz\\OneDrive\\桌面\\image-20201209203816547.png\" alt=\"image-20201209203816547\" style=\"zoom:50%;\" />\n\n\n\n\n\n\n\n##### JWT集成\n\n1. \n\n   ```xml\n     <dependency>\n               <groupId>io.jsonwebtoken</groupId>\n               <artifactId>jjwt</artifactId>\n               <version>0.9.0</version>\n     </dependency>\n   ```\n\n   \n\n2. 写一个JwtUtils配置类\n\n   ```java\n   import io.jsonwebtoken.Claims;\n   import io.jsonwebtoken.Jwts;\n   import io.jsonwebtoken.SignatureAlgorithm;\n   import lombok.Data;\n   import org.springframework.boot.context.properties.ConfigurationProperties;\n   import org.springframework.security.core.userdetails.UserDetails;\n   import org.springframework.stereotype.Component;\n   \n   import java.util.Date;\n   import java.util.HashMap;\n   import java.util.Map;\n   @Data\n   @ConfigurationProperties(prefix = \"jwt\")\n   @Component\n   public class JWTTokenUtils {\n   \n       private String secret;\n       private Long expiration;\n       private String header;\n   \n       /**\n        * 生成token令牌\n        *\n        * @param userDetails 用户\n        * @return 令token牌\n        */\n       public String generateToken(UserDetails userDetails) {\n           Map<String, Object> claims = new HashMap<>(2);\n           claims.put(\"sub\", userDetails.getUsername());\n           claims.put(\"created\", new Date());\n   \n           return generateToken(claims);\n       }\n   \n       /**\n        * 从令牌中获取用户名\n        * @param token 令牌\n        * @return  用户名\n        */\n       public String getUsernameFromToken(String token){\n           String username;\n           try {\n               Claims claims=getClaimsFromToken(token);\n               username=claims.getSubject();\n           }catch (Exception e){\n               username=null;\n           }\n           return username;\n       }\n   \n       /**\n        * 判断令牌是否过期\n        * @param token 令牌\n        * @return  是否过期\n        */\n       public Boolean isTokenExpired(String token){\n           try {\n               Claims claims=getClaimsFromToken(token);\n               Date expiration=claims.getExpiration();\n               return expiration.before(new Date());\n           }catch (Exception e){\n               return false;\n           }\n       }\n   \n       /**\n        * 刷新令牌\n        * @param token 原令牌\n        * @return  旧令牌\n        */\n       public String refreshToken(String token){\n           String refreshedToken;\n           try {\n               Claims claims=getClaimsFromToken(token);\n               claims.put(\"created\",new Date());\n               refreshedToken=generateToken(claims);\n           }catch (Exception e){\n               refreshedToken=null;\n           }\n           return refreshedToken;\n       }\n   \n       /**\n        * 验证令牌\n        * @param token 令牌\n        * @param userDetails   用户\n        * @return     是否有效\n        */\n   \n       public Boolean validateToken(String token,UserDetails userDetails){\n           String username=getUsernameFromToken(token);\n           return (username.equals(userDetails.getUsername())) && !isTokenExpired(token);\n       }\n   \n   \n       /**\n        * 从claims生成令牌，如果看不董就看谁调用它\n        * @param claims 数据声明\n        * @return 令牌\n        */\n       private String generateToken (Map<String,Object> claims){\n           Date expirationDate=new Date(System.currentTimeMillis()+expiration);\n           return Jwts.builder().setClaims(claims)\n                   .setExpiration(expirationDate)\n                   .signWith(SignatureAlgorithm.HS512,secret)\n                   .compact();\n       }\n   \n   \n       private Claims getClaimsFromToken(String token){\n   \n           Claims claims;\n           try {\n               claims=Jwts.parser().setSigningKey(secret).parseClaimsJws(token).getBody();\n           }catch (Exception e){\n               claims=null;\n           }\n           return claims;\n       }\n   }\n   \n   ```\n\n   \n\n3. 可以配置到yml文件里面\n\n   ```yml\n   jwt:\n     secret: xjwiodcjcjwdoicijd\n     expiration: 3600000\n     header: JWTHeaderName\n   ```\n\n4. Controller\n\n   ```java\n   import com.zhaoguoshun.jwtserver.exception.AjaxResponse;\n   import com.zhaoguoshun.jwtserver.exception.CustomException;\n   import com.zhaoguoshun.jwtserver.exception.CustomExceptionType;\n   import org.apache.commons.lang3.StringUtils;\n   import org.springframework.beans.factory.annotation.Autowired;\n   import org.springframework.web.bind.annotation.*;\n   \n   import java.util.Map;\n   \n   @RestController\n   public class JwtAuthController {\n   \n       @Autowired\n       private JwtAuthService jwtAuthService;\n   \n   \n       @RequestMapping(\"/authentication\")\n       public AjaxResponse login(@RequestBody Map<String,String> map){\n           String username =map.get(\"username\");\n           String password=map.get(\"password\");\n   \n           if (StringUtils.isEmpty(username) || StringUtils.isEmpty(password)){\n               return  AjaxResponse.error(\n                       new CustomException(CustomExceptionType.USER_INPUT_ERROR ,\"用户名或者密码不能为空\")\n               );\n           }\n           try {\n               return AjaxResponse.success(jwtAuthService.login(username,password));\n           }catch (CustomException e){\n               return  AjaxResponse.error(e);\n           }\n       }\n   \n      @RequestMapping(\"/refreshtoken\")\n       public AjaxResponse refresh(@RequestHeader(\"${jwt.header}\") String token){\n           return AjaxResponse.success(jwtAuthService.refreshToken(token));\n      }\n   }\n   ```\n\n   \n\n5. 测试一下，发送了一个请求得到了令牌\n\n   <img src=\"C:\\Users\\guosz\\OneDrive\\桌面\\image-20201210163610149.png\" alt=\"image-20201210163610149\" style=\"zoom:50%;\" />\n\n6. 我们鉴权需要过滤\n\n   ```java\n   import com.zhaoguoshun.jwtserver.service.MyUserDetailService;\n   import org.apache.commons.lang3.StringUtils;\n   import org.apache.logging.log4j.core.tools.picocli.CommandLine;\n   import org.springframework.beans.factory.annotation.Autowired;\n   import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\n   import org.springframework.security.core.context.SecurityContextHolder;\n   import org.springframework.security.core.userdetails.UserDetails;\n   import org.springframework.stereotype.Component;\n   import org.springframework.web.filter.OncePerRequestFilter;\n   \n   import javax.servlet.FilterChain;\n   import javax.servlet.ServletException;\n   import javax.servlet.http.HttpServletRequest;\n   import javax.servlet.http.HttpServletResponse;\n   import java.io.IOException;\n   \n   @Component\n   public class JwtAuthenticationTokenFilter extends OncePerRequestFilter {\n   \n       @Autowired\n       private JwtTokenUtil jwtTokenUtil;\n   \n       @Autowired\n       private MyUserDetailService myUserDetailService;\n   \n   \n       @Override\n       protected void doFilterInternal(HttpServletRequest request,\n                                       HttpServletResponse response,\n                                       FilterChain filterChain)\n               throws ServletException, IOException {\n           String JwtToken = request.getHeader(jwtTokenUtil.getHeader());\n           if (!StringUtils.isEmpty(JwtToken)){\n               String username=jwtTokenUtil.getUsernameFromToken(JwtToken);\n   \n               if (username!=null &&\n                       SecurityContextHolder.getContext().getAuthentication()==null){\n                   UserDetails userDetails = myUserDetailService.loadUserByUsername(username);\n                   if (jwtTokenUtil.validateToken(JwtToken,userDetails)){\n                       //给使用该JWT令牌的用户进行授权\n                       UsernamePasswordAuthenticationToken authenticationToken\n                               =new UsernamePasswordAuthenticationToken(userDetails,null,userDetails.getAuthorities());\n                       SecurityContextHolder.getContext().setAuthentication(authenticationToken);\n                   }\n               }\n           }\n   \n           filterChain.doFilter(request,response);\n       }\n   }\n   \n   ```\n\n   \n\n7. 再每次请求的时候都都再请求头上加上生成的令牌\n\n   <img src=\"C:\\Users\\guosz\\OneDrive\\桌面\\image-20201210164016061.png\" alt=\"image-20201210164016061\" style=\"zoom:50%;\" />\n\n8. ', 320, '2020-12-22', 'A');
INSERT INTO `tb_channel` VALUES (20, 'Java基础', 19, 'http://39.106.163.62:8081/cms/upload/8f529eb2-4be9-4f9c-8d1c-04c565f29e3e.jpg', 'Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 [1]  。', 'Y', '', '', '', '', '', 320, '2020-12-22', 'A');
INSERT INTO `tb_channel` VALUES (22, '分布式', 0, '', '', 'N', '', '', '', '', '', 320, '2020-12-22', 'B');
INSERT INTO `tb_channel` VALUES (23, '大数据', 0, '', '', 'N', '', '', '', '', '', 320, '2020-12-22', 'B');
INSERT INTO `tb_channel` VALUES (24, '通知公告', 0, '', '', 'N', '', '', '', '', '', 320, '2020-12-22', 'C');
INSERT INTO `tb_channel` VALUES (25, 'Spring', 0, '', '', 'N', '', '', '', '', '', 320, '2020-12-24', 'B');
INSERT INTO `tb_channel` VALUES (35, '微服务', 0, '', '', 'N', '', '', '', '', '', 353, '2021-01-01', 'A');
INSERT INTO `tb_channel` VALUES (36, 'Springboot', 35, '', '', 'N', '', '', '', '', '', 353, '2021-01-01', 'A');
INSERT INTO `tb_channel` VALUES (37, 'Vue', 35, '', '', 'N', '', '', '', '', '', 353, '2021-01-01', 'A');
INSERT INTO `tb_channel` VALUES (40, '计算机科学', 0, 'http://39.106.163.62:8081/cms/upload/85e53f5b-e7f0-44ca-ad7e-37cfc9d27b29.jpg', '计算机科学（英语：computer science，有时缩写为CS）是系统性研究信息与计算的理论基础以及它们在计算机系统中如何实现与应用的实用技术的学科。它通常被形容为对那些创造、描述以及转换信息的算法处理的系统研究', 'N', '', '', '', '', '', 353, '2021-01-05', 'A');
INSERT INTO `tb_channel` VALUES (41, '操作系统', 40, '', '操作系统（operation system，简称OS）是管理计算机硬件与软件资源的计算机程序。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入设备与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。', 'N', '', '', '', '', '', 353, '2021-01-05', 'A');
INSERT INTO `tb_channel` VALUES (42, '数据结构和算法', 40, 'http://39.106.163.62:8081/cms/upload/c229d7ec-f4aa-4ca4-9e44-a7738563e403.jpg', '数据（data）结构（structure）是一门研究组织数据方式的学科，有了编程语言也就有了数据结构。学好数据结构可以编写出更加漂亮，更加有效率的代码。 程序 = 数据结构 + 算法 数据结构是算法的基础。', 'N', '', '', '', '', '', 353, '2021-01-05', 'A');
INSERT INTO `tb_channel` VALUES (43, '数据库', 40, 'http://39.106.163.62:8081/cms/upload/a461b694-2e7e-4776-bce2-8af608295620.jpg', '数据库系统（Database System），是由数据库及其管理软件组成的系统。 数据库系统是为适应数据处理的需要而发展起来的一种较为理想的数据处理系统，也是一个为实际可运行的存储、维护和应用系统提供数据的软件系统，是存储介质 、处理对象和管理系统的集合体。', 'N', '', '', '', '', '', 353, '2021-01-05', 'A');

-- ----------------------------
-- Table structure for tb_comment
-- ----------------------------
DROP TABLE IF EXISTS `tb_comment`;
CREATE TABLE `tb_comment`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `author` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '评论者',
  `email` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '邮箱',
  `create_date` date NULL DEFAULT NULL COMMENT '创建时间',
  `content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL COMMENT '正文',
  `status` int(1) NULL DEFAULT NULL COMMENT '0 待批准，1已通过2未通过',
  `article_id` int(11) NULL DEFAULT NULL COMMENT '文章ID',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 38 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '评论' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tb_comment
-- ----------------------------

-- ----------------------------
-- Table structure for tb_friend_link
-- ----------------------------
DROP TABLE IF EXISTS `tb_friend_link`;
CREATE TABLE `tb_friend_link`  (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `url` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '链接URL',
  `title` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `target` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 10 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '友情链接' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tb_friend_link
-- ----------------------------
INSERT INTO `tb_friend_link` VALUES (8, 'http://zhaoguoshun.cn:8083/', '顺鑫博客', '_blank');
INSERT INTO `tb_friend_link` VALUES (9, 'https://www.tsinghua.edu.cn/', '清华大学', '_blank');

-- ----------------------------
-- Table structure for tb_tag
-- ----------------------------
DROP TABLE IF EXISTS `tb_tag`;
CREATE TABLE `tb_tag`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `tag_name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 18 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tb_tag
-- ----------------------------
INSERT INTO `tb_tag` VALUES (5, 'Java');
INSERT INTO `tb_tag` VALUES (6, 'Vue');
INSERT INTO `tb_tag` VALUES (8, '学习');
INSERT INTO `tb_tag` VALUES (9, '微服务');
INSERT INTO `tb_tag` VALUES (10, 'Dubbo');
INSERT INTO `tb_tag` VALUES (11, 'SpringCloud');
INSERT INTO `tb_tag` VALUES (12, '分布式');
INSERT INTO `tb_tag` VALUES (13, '操作系统');
INSERT INTO `tb_tag` VALUES (14, '其他');
INSERT INTO `tb_tag` VALUES (15, 'Mysql');
INSERT INTO `tb_tag` VALUES (16, '数据结构');
INSERT INTO `tb_tag` VALUES (17, '算法');

-- ----------------------------
-- Table structure for tb_user
-- ----------------------------
DROP TABLE IF EXISTS `tb_user`;
CREATE TABLE `tb_user`  (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `user_name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '用户名',
  `password` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '密码',
  `nick_name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '名称',
  `email` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '邮箱',
  `avatar` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '头像',
  `create_date` date NULL DEFAULT NULL COMMENT '创建时间',
  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 't代表正常，f代表禁用，d代表删除',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 358 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tb_user
-- ----------------------------
INSERT INTO `tb_user` VALUES (353, 'xiaoshun', '123456', '赵国顺', 'findshun@qq.com', 'http://39.106.163.62:8081/cms/upload/9c520f6c-746f-417a-94e0-a2cef02f585b.png', '2020-12-29', 'T');
INSERT INTO `tb_user` VALUES (354, 'admin', '123456', '赵国顺', 'findshun@qq.com', 'http://39.106.163.62:8081/cms/upload/f68efce6-0e96-471c-a2a5-29152fb2c202.png', '2020-12-30', 'T');
INSERT INTO `tb_user` VALUES (356, 'xieluxin', '985211', 'luxin', 'luxin046029@qq.com', 'http://39.106.163.62:8081/cms/upload/ab6cafd9-c2a2-4892-a209-13069d7602ed.png', '2021-01-01', 'T');
INSERT INTO `tb_user` VALUES (357, 'test', '123456', '测试', 'cdnsjk@qq.com', NULL, '2021-01-06', 'T');

SET FOREIGN_KEY_CHECKS = 1;
